# 1.3 프로토타입과 스코프

기본적으로 스프링의 빈은 싱글톤으로 만들어진다.  
그런데 때로는 빈을 싱글톤이 아닌 다른 방법으로 만들어 사용해야 할 때가 있다.  
빈 당 단 하나의 오브젝트만을 만드는 싱글톤 대신, 하나의 빈 설정으로 여러 개의 오브젝트를 만들어서 사용하는 경우다.

싱글톤이 아닌 빈은 크게 프로토타입 빈과 스코프 빈으로 나눌 수 있다.

## 1.3.1 프로토타입 스코프

프로토타입 스코프는 컨테이너에게 빈을 요청할 때마다 매번 새로운 오브젝트를 생성해 준다.  
@Autowired나 \<property> 같은 DI 선언도 각각 독립적인 빈 요청에 해당된다.  
따라서 프로토타입 빈은 DI에서도 매번 새로운 오브젝트가 만들어져서 주입된다.

### 프로토타입 빈의 생명주기와 종속성

**IoC의 기본 개념은 애플리케이션을 구성하는 핵심 오브젝트를 코드가 아니라 컨테이너가 관리**한다는 것이다.  
그래서 스프링이 관리하는 오브젝트인 빈은 그 생성과 다른 빈에 대한 의존 관계 주입, 초기화(메서드 호출), DI와 DL을 통한 사용, 제거에 이르기까지 모든 오브젝트의 생명주기를 컨테이너가 관리한다.  
빈에 대한 정보와 오브젝트에 대한 레퍼런스는 컨테이너가 계속 가지고 있고 필요할 때마다 요청해서 빈 오브젝트를 얻을 수 있다.

그런데 프로토타입 빈은 독특하게 이 IoC의 기본 원칙을 따르지 않는다.  
프로토타입 스코프를 가지는 빈은 요청이 있을 때마다 컨테이너가 생성하고 초기화하고 DI까지 해주기도 하지만 일단 빈을 제공하고 나면 컨테이너는 더 이상 빈 오브젝트를 관리하지 않는다.  
따라서 프로토타입 빈 오브젝트는 한번 DI나 DL을 통해 컨테이너 밖으로 전달된 후에는 이 오브젝트는 더 이상 스프링이 관리하는 빈이 아니다.  
한번 만들어진 프로토타입 빈 오브젝트는 다시 컨테이너를 통해 가져올 방법이 없고, 빈이 제거되기 전에 빈이 사용한 리소스를 정리하기 위해 호출하는 메서드도 이용할 수 없다.

### 프로토타입 빈의 용도

프로토타입 빈은 코드에서 new로 오브젝트를 생성하는 것을 대신하기 위해 사용된다.  
드물긴 하지만 생성할 오브젝트의 DI를 위해 컨테이너가 오브젝트를 만들고 초기화해 줘야 하는 경우가 존재한다.  
프로토타입 빈은 오브젝트의 생성과 DI 작업까지 마친 후에 컨테이너가 돌려준다.

### DI와 DL

프로토타입 빈은 DI 될 대상이 여러 군데라면 각기 다른 오브젝트가 생성된다.  
하지만 같은 컨트롤러에서도 매번 요청이 있을 때마다 새롭게 오브젝트가 만들어져야 하는 경우에는 적합하지 않다.

new 키워드를 대신하기 위해 사용되는 것이 프로토타입의 용도라고 본다면 DL 방식으로 사용해야 한다.

### 프로토타입 빈의 DL 전략

스프링은 프로토타입 빈처럼 DL 방식을 코드에서 사용해야 할 경우를 위해 직접 ApplicationContext를 이용하는 것 외에도 다양한 방법을 제공하고 있다.

- ApplicationContext, BeanFactory
  - @Autowired나 @Resource를 이용해 ApplicationContext 또는 BeanFactory를 DI 받은 뒤에 getBean() 메서드를 직접 호출해서 빈을 가져오는 방법
  - 사용하기 간단하나 코드에 스프링 API가 직접 등장한다는 단점이 있음
- ObjectFactory, ObjectFactoryCreatingFactoryBean
  - 중간에서 컨텍스트에 getBean()을 호출해 주는 역할을 맡은 오브젝트
  - 평범하고 간단한 메서드만 가지고 있기 때문에 복잡한 ApplicationContext를 직접 사용하는 것보다 훨씬 깔끔하고 테스트하기 좋음
  - 프로토타입 빈 뿐 아니라 DL을 이용해 빈을 가져와야 하는 모든 경우에 적용 가능
- ServiceLocatorFactoryBean
  - DL 방식으로 가져올 빈을 리턴하는 임의의 이름을 가진 메서드가 정의된 인터페이스가 있으면 됨 (스프링이 미리 정의해 준 인터페이스를 사용하지 않아도 됨)
  - 정의한 인터페이스를 이용해 스프링의 ServiceLocatorFactoryBean으로 등록
- 메서드 주입
  - 스프링 API에 의존적인 코드를 만드는 불편함과 빈을 새로 추가하는 번거로운 문제를 해결한 방식
  - 메서드를 통한 주입이 아니라 메서드 코드 자체를 주입하는 것을 의미함
  - 일정한 규칙을 따르는 추상 메서드를 작성해 두면 ApplicationContext의 getBean() 메서드를 사용해서 새로운 프로토타입 빈을 가져오는 기능을 담당하는 메서드를 런타임 시에 추가해 주는 기술
  - 추상 클래스이므로 테스트에서 사용할 때 상속을 통한 추상 메서드를 오버라이드한 뒤에 사용해야 한다는 번거로움이 존재
- Provider\<T>
  - JSR-330에 추가된 표준 인터페이스인 Provider를 이용하는 방법
  - Provider는 ObjectFactory와 거의 유사하게 \<T> 타입 파라미터와 get()이라는 팩토리 메서드를 가진 인터페이스
  - 기본 개념과 사용 방법은 ObjectFactory와 유사하지만 ObjectFactoryCreatingFactoryBean을 이용해 빈을 등록해 주지 않아도 되기 때문에 사용이 편리함
  - Provider 인터페이스를 @Inject, @Autowired, @Resource 중의 하나를 이용해 DI 되도록 지정해 주기만 하면 스프링이 자동으로 Provider를 구현한 오브젝트를 생성해서 주입해 줌
  - 스프링 외에 JSR-330 표준을 구현한 여타 DI 프레임워크에서도 같은 방식으로 동작하는 것이 보장됨

## 1.3.2 스코프

### 스코프의 종류

스프링은 싱글톤, 프로토타입 외에 네 가지 스코프를 기본적으로 제공한다.  
이 스코프는 모두 웹 환경에서만 의미가 있다.

- 요청(request) 스코프
  - 하나의 웹 요청 안에서 만들어지고 해당 요청이 끝날 때 제거됨
  - 하나의 웹 요청을 처리하는 동안에 참조하는 요청 스코프 빈은 항상 동일한 오브젝트임이 보장됨
  - 요청 스코프의 주요 용도는 애플리케이션 코드에서 생성한 정보를 프레임워크 레벨의 서비스나 인터셉터 등에 전달하는 것
- 세션(session) 스코프, 글로벌 세션(globalSession) 스코프
  - HTTP 세션과 같은 존재 범위를 갖는 빈으로 만들어 주는 스코프
  - 웹 페이지가 바뀌고 여러 요청을 거치는 동안에도 세션 스코프 빈은 계속 유지됨
  - 글로벌 세션 스코프는 포틀릿에서만 존재하는 글로벌 세션에 저장되는 빈
- 애플리케이션(application) 스코프
  - 웹 애플리케이션마다 만들어지는 서블릿 컨텍스트에 저장되는 빈 오브젝트
  - 컨텍스트가 존재하는 동안 유지되는 싱글톤 스코프와 비슷한 존재 범위를 가짐

### 스코프 빈의 사용 방법

스코프 빈은 싱글톤에서 일반적인 방법으로 DI 하는 것은 불가능하다.  
직접 스코프 빈을 DI 하는 대신 스코프 빈에 대한 프록시를 DI 해주면 평범한 싱글톤 빈을 이용하듯이 스코프 빈을 사용할 수 있다.  
`@Scope` 애노테이션으로 스코프를 설정했다면 `proxyMode` 엘리먼트를 이용해서 프록시를 이용한 DI가 되도록 지정할 수 있다.  
클라이언트는 스코프 프록시(Scoped Proxy) 오브젝트를 실제 스코프 빈처럼 사용하면 프록시에게 현재 스코프에 맞는 실제 빈 오브젝트로 작업을 위임해 준다.  
프록시 빈이 인터페이스를 구현하고 있고, 클라이언트에서 인터페이스로 DI 받는다면 proxyMode를 ScopeProxyMode.INTERFACE로 지정해 주고, 프록시 빈 클래스를 직접 DI 한다면 ScopedProxyMode.TARGET_CLASS로 지정하면 된다.

### 커스텀 스코프와 상태를 저장하는 빈 사용하기

스프링이 기본적으로 제공하는 스코프 외에도 임의의 스코프를 만들어 사용할 수 있다.  
스프링에서는 Scope 인터페이스를 구현해서 새로운 스코프를 작성할 수 있지만 스코프를 새로 작성하고 적용하는 건 상당히 복잡한 작업이다.
