# 1.2 IoC/DI를 위한 빈 설정 메타정보 작성

IoC 컨테이너의 가장 기본적인 역할은 코드를 대신해서 애플리케이션을 구성하는 오브젝트를 생성하고 관리하는 것이다.  
POJO로 만들어진 애플리케이션 클래스와 서비스 오브젝트들이 그 대상이다.

## 1.2.1 빈 설정 메타 정보

`BeanDefinition`에는 IoC 컨테이너가 빈을 만들 때 필요한 핵심 정보가 담겨 있다.  
몇 가지 필수 항목을 제외하면 컨테이너에 미리 설정된 디폴트 값이 그대로 적용된다.

### 빈 설정 메타 정보 항목

스프링의 IoC/DI 기술은 단순하게 클래스로 오브젝트를 만들고 프로퍼티 설정하는 것이 전부가 아니다.  
스프링은 오브젝트를 컨테이너가 생성하고 관리하는 과정에서 필요한 매우 세밀하고 유연한 방법을 제공한다.

## 1.2.2 빈 등록 방법

빈 등록은 빈 메타 정보를 작성해서 컨테이너에게 건네주면 된다.  
가장 직접적이고 원시적인 방법은 BeanDefinition 구현 오브젝트를 직접 생성하는 것이지만 스프링을 확장해서 프레임워크를 만들거나 스프링의 내부 동작 원리를 학습하려는 게 목적이 아니라면 이 방법은 무리가 있다.  
그래서 보통 XML 문서, 프로퍼티 파일, 소스코드 애노테이션과 같은 외부 리소스로 빈 메타 정보를 작성하고 이를 적절한 리더나 변환기를 통해 애플리케이션 컨텍스트가 사용할 수 있는 정보로 변환해 주는 방법을 사용한다.

### 자동 인식을 이용한 빈 등록: 스테레오타입 애노테이션과 빈 스캐너

빈으로 사용될 클래스에 특별한 애노테이션을 부여해 주면 이런 클래스를 자동으로 찾아서 빈으로 등록해 주게 할 수 있다.  
이렇게 특정 애노테이션이 붙은 클래스를 자동으로 찾아서 빈으로 등록해 주는 방식을 빈 스캐닝(scanning)을 통한 자동 인식 빈 등록 기능이라고 하고, 이런 스캐닝 작업을 담당하는 오브젝트를 빈 스캐너(scanner)라고 한다.

스프링의 빈 스캐너는 **지정된 클래스패스 아래에 있는 모든 패키지의 클래스를 대상으로 필터를 적용해서 빈 등록을 위한 클래스들을 선별**해낸다.  
빈 스캐너에 내장된 디폴트 필터는 `@Component` 애노테이션 또는 @Component를 메타 애노테이션으로 가진 애노테이션이 부여된 클래스를 선택하도록 되어 있다.  
@Component를 포함해 디폴트 필터에 적용되는 애노테이션을 스프링에서는 `스테레오타입(stereotype) 애노테이션`이라고 부른다.

### 자바 코드에 의한 빈 등록: @Configuration 클래스의 @Bean 메서드

빈 설정 메타 정보를 담고 있는 자바 코드는 `@Configuration` 애노테이션이 달린 클래스를 이용해 작성한다.  
클래스에 `@Bean`이 붙은 메서드를 정의할 수 있는데, 이 @Bean 메서드를 통해 빈을 정의할 수 있다.

스프링은 @Bean이 붙은 메서드를 이용해서 빈을 만들 때, 싱글톤 빈이라면 한 개의 오브젝트만 생성이 되고 더 이상 새로운 오브젝트가 만들어지지 않도록 특별한 방법으로 @Bean 메서드를 조작해둔다.

자바 코드에 의한 설정이 XML과 같은 외부 설정 파일을 이용하는 것보다 유용한 점은 다음과 같다.

- 컴파일러나 IDE를 통한 타입 검증 가능
- 자동 완성과 같은 IDE 지원 기능을 최대한 이용 가능
- 이해하기 쉬움
- 복잡한 빈 설정이나 초기화 작업을 손쉽게 적용할 수 있음

### 자바 코드에 의한 빈 등록: 일반 빈 클래스의 @Bean 메서드

일반 POJO 클래스에서도 @Bean을 사용할 수 있다.  
이 경우에도 @Bean은 동일하게 새로운 빈을 정의하는 설정 메타 정보로 사용되고, 그 리턴 오브젝트가 빈 오브젝트가 된다.

그런데 @Configuration이 붙지 않은 @Bean 메서드는 @Configuration 클래스의 @Bean과 미묘한 차이점이 있기 때문에 주의해야 한다.  
**빈의 싱글톤 스코프가 보장되는 경우는 @Configuration 클래스 안에서 사용된 @Bean에만 해당**된다.  
일반 빈 클래스에 @Bean을 사용한 경우, 메서드를 호출할 때마다 매번 다른 객체를 얻게 된다.

## 1.2.3 빈 의존 관계 설정 방법

### 애노테이션: @Resource

@Resource는 \<property> 선언과 비슷하게 주입할 빈을 아이디로 지정하는 방법이다.  
@Resource는 자바 클래스의 수정자와 필드에 붙일 수 있다.  
@Resource는 기본적으로 참조할 빈의 이름을 이용해서 빈을 찾는다.  
만약 @Resource에 name 엘리먼트를 지정하지 않았고 디폴트 이름으로는 참조할 빈을 찾을 수 없는 경우 타입을 이용해 다시 한번 빈을 찾는다.

@Resource를 타입으로 빈을 찾게 하는 건, 컨텍스트가 자신에 대한 레퍼런스를 직접 제공하는 경우에만 적합하다.

### 애노테이션: @Autowired/@Inject

이 두 가지 애노테이션은 기본적으로 타입에 의한 자동 와이어링 방식으로 동작한다.  
@Autowired는 스프링 2.5부터 적용된 스프링 전용 애노테이션이고 @Inject는 JavaEE 6의 표준 스펙인 JSR-330(Dependency Injection for Java)에 정의되어 있는 것으로, 스프링 외에도 JavaEE 6의 스펙을 따르는 여타 프레임워크에서도 동일한 의미로 사용되는 DI를 위한 애노테이션이다.

### 자바 코드에 의한 의존 관계 설정

@Configuration과 @Bean을 이용해서 자바 코드로 빈을 등록하는 경우에 빈의 의존 관계를 설정하는 세 가지 방법이 있다.

- 애노테이션에 의한 설정 @Autowired, @Resource
  @Autowired와 같은 애노테이션을 통한 의존 관계 설정은 빈 오브젝트 등록을 마친 후에 후처리기에 의해 별도의 작업으로 진행됨
- @Bean 메서드 호출
  - 자바 코드로 DI 하는 가장 직관적인 방법
  - 코드를 보고 예상할 수 있는 일반적인 자바 코드의 동작 방식과 다르게 동작하기 때문에 스프링의 특별한 목적을 위해 사용되는 코드로 받아들이지 않으면 설정 정보에 대해 오해할 소지가 있음
- @Bean과 메서드 자동 와이어링
  - 빈의 레퍼런스를 파라미터로 주입받는 방식
  - 다른 빈의 레퍼런스를 메서드 호출이 아니라 파라미터로 받기 때문에 @Bean 메서드 호출을 이용했을 때보다 자바 코드가 자연스러움

## 1.2.4 프로퍼티 값 설정 방법

DI를 통해 빈에 주입되는 것은 두 가지다.

- 다른 빈 오브젝트의 레퍼런스
- 단순 값

스프링에서 말하는 값이란 스프링이 관리하는 빈이 아닌 모든 것을 의미한다.

### 메타 정보 종류에 따른 값 설정 방법

빈이 사용해야 할 단순한 값이나 오브젝트를 코드에 담지 않고 설정을 통해 런타임 시에 주입해야 하는 이유는 두 가지가 있다.

- 환경에 따라 매번 달라질 수 있는 값
- 초깃값 대신 다른 값을 사용하고 싶은 경우

@Value 애노테이션의 주요 용도는 자바 코드 외부의 리소스나 환경 정보에 담긴 값을 사용하도록 지정해 주는 데 있다.
@Value는 필드와 수정자, 메서드 파라미터에 사용 가능하다.  
@Value는 스프링 컨테이너가 참조하는 정보이지 그 자체로 클래스의 필드에 값을 넣어주는 기능이 있는 것은 아니다.  
따라서 테스트 코드와 같이 컨테이너 밖에서 사용된다면 @Value 애노테이션은 무시된다.

### PropertyEditor와 ConversionService

XML의 value 애트리뷰트나 @Value의 엘리먼트는 모두 텍스트 문자로 작성된다.  
값을 넣을 프로퍼티 타입이 스트링이면 아무 문제가 없겠지만, 그 외의 타입인 경우라면 타입을 변경하는 과정이 필요하다.  
이를 위해 스프링은 두 가지 종류의 타입 변환 서비스를 제공한다.
디폴트로 제공되는 타입 변환기는 `PropertyEditor`라는 java.beans의 인터페이스를 구현한 것이다.

스프링이 기본적으로 지원하는 변환 가능한 타입은 다음과 같다.

- 기본 타입
  - int 같은 기본 타입은 물론이고 Integer 같은 오브젝트 타입도 함께 지원
  - 변환을 지원하는 기본 타입
    - boolean (Boolean)
    - byte (Byte)
    - short (Short)
    - int (Integer)
    - long (Long)
    - float (Float)
    - double (Double)
    - BigDecimal
    - char (Character)
    - String
- 배열
  - 기본 타입의 배열로 선언된 프로퍼티에는 값을 콤마로 구분하여 한 번에 배열 값 주입 가능
  - 변환을 지원하는 기본 타입의 배열
    - byte[]
    - char[]
    - short[]
    - int[]
    - long[]
- 기타
  - Charset
    - UTF-8, ISO-8859-1과 같은 값을 java.nio.charset.Charset 타입으로 변환
  - Class
    - "java.lang.String"과 같이 문자열로 된 클래스 이름을 Class 타입으로 변환
    - Class[] 타입도 지원
  - Currency
    - ISO 4217 코드를 따르는 java.util.Currency 타입으로 변환
  - File
    - java.io.File 타입으로 변환
    - 스프링의 리소스 로더에 사용하는 표현을 사용할 수 있음 (file:, classpath:와 같은 접두어 사용 가능)
  - InputStream
    - java.io.InputStream 타입으로 변환
  - Locale
    - java.util.Locale 타입으로 변환
  - Pattern
    - java.util.regex.Pattern 타입으로 변환
  - Resource
    - 스프링의 리소스 타입으로 변환
    - 배열 지원
  - Timezone
    - java.util.Timezone 타입으로 변환
  - URI, URL
    - java.net.URI 또는 java.net.URL 타입으로 변환

스프링 3.0부터는 PropertyEditor 대신 사용할 수 있는 ConversionService를 지원하기 시작했다.  
ConversionService는 자바빈에서 차용해서 사용해오던 PropertyEditor와 달리 스프링이 직접 제공하는 타입 변환 API다.  
PropertyEditor보다 변환기의 작성이 간편하며 PropertyEditor와 달리 멀티 스레드 환경에서 공유해 사용될 수 있다.  
하지만 컨테이너가 스프링 빈의 값을 주입하는 작업에는 기본 변환기인 PropertyEditor로 충분하다.

### 프로퍼티 파일을 이용한 값 설정

환경에 따라 자주 변경될 수 있는 내용은 프로퍼티 파일로 분리하는 것이 가장 깔끔하다.

별도의 프로퍼티 파일로 분리한 정보를 빈의 프로퍼티 값으로 사용하는 방법은 두 가지가 있다.

- 수동 변환: PropertyPlaceHolderConfigurer
  - 프로퍼티 치환자(placeholder)를 이용하는 방법
  - 프로퍼티 치환자는 프로퍼티 파일의 키값을 ${} 안에 넣어서 생성
  - PropertyPlaceHolderConfigurer 빈이 ${}으로 선언된 값을 프로퍼티 파일의 내용으로 변경
  - 대체할 위치를 치환자로 지정해 두고 별도의 후처리기가 치환자 값을 변경해 주기를 기대하는 것이기 때문에 수동적임
  - 수동적인 접근 방법이기 때문에 치환자의 값이 변경되지 않더라도 예외가 발생하지 않음
- 능동 변환: SpEL
  - 다른 빈 오브젝트에 직접 접근할 수 있는 표현식을 이용해 원하는 프로퍼티 값을 능동적으로 가져오는 방법
  - 다른 빈의 프로퍼티에 접근 가능
  - 메서드 호출 가능
  - 다양한 연산 지원
  - 클래스 정보에 접근 가능
  - 생성자를 호출하여 오브젝트 생성 가능
  - 능동적으로 접근하는 방식이기 때문에 오타와 같은 실수가 있을 때 에러 검증이 가능하다는 장점이 있음

## 1.2.5 컨테이너가 자동등록하는 빈

스프링 컨테이너는 초기화 과정에서 몇 가지 빈을 기본적으로 등록해 준다.

### ApplicationContext, BeanFactory

컨텍스트 자신은 이름을 가진 빈으로 등록되어 있지 않기 때문에 타입으로 접근하면 된다.  
만약 애노테이션을 이용한 의존 관계 설정을 하지 않는다면 @Autowired를 사용할 수 없다.  
이때는 `ApplicationContextAware`라는 특별한 인터페이스를 구현해 주면 된다.  
ApplicationContextAware 인터페이스에는 setApplicationContext() 메서드가 있어서 스프링이 애플리케이션 컨텍스트 오브젝트를 DI 해줄 수 있다.

ApplicationConxtext의 구현 클래스는 기본적으로 BeanFactory의 기능을 직접 구현하고 있지 않고 내부에 빈 팩토리 오브젝트를 별도로 만들어 두고 위임하는 방식을 사용한다.  
컨텍스트 내부에 만들어진 빈 팩토리 오브젝트를 직접 사용하고 싶다면 BeanFactory 타입으로 DI 해줄 필요가 있다.  
빈 팩토리는 ApplicationContext 구현 클래스 안에 내부적으로 따로 생성해 두기 때문에 BeanFactory로 DI 받는 오브젝트는 ApplicationContext로 가져오는 오브젝트와 다르다.

### ResourceLoader, ApplicationEventPublisher

스프링 컨테이너는 ResourceLoader이기도 하기 때문에 서버 환경에서 다양한 Resource를 로딩할 수 있는 기능을 제공한다.  
컨테이너를 ResourceLoader 타입으로 DI 받거나 ResourceLoaderAware 인터페이스를 구현해 주는 방법으로 사용할 수 있다.

ApplicationEventPublisher는 ApplicationListener 인터페이스를 구현한 빈에게 이벤트를 발생시킬 수 있는 publishEvent() 메서드를 가진 인터페이스다.  
이 역시 ApplicationContext가 상속하고 있는 인터페이스의 한 가지다.  
스프링 컨테이너에는 빈 사이에 이벤트를 발생시키고 이를 전달받을 수 있는 기능이 포함되어 있지만 거의 사용되지 않는다.  
빈 사이에 독자적인 이벤트/리스너 구성을 하면 충분하기 때문에 굳이 컨테이너에 의존적인 방식을 이용할 필요는 없기 때문이다.  
그래도 이 기능을 사용하고 싶다면 ApplicationEventPublisher 타입을 DI 받아서 사용하면 된다.

### systemProperties, systemEnvironment

스프링 컨테이너가 직접 등록하는 빈 중에서 타입이 아니라 이름을 통해 접근할 수 있는 두 가지 빈이다.  
각각 Properties 타입과 Map 타입이라 다른 빈에서도 흔히 발견될 수 있는 타입이기 때문에 타입에 의한 접근 방법은 적절치 않다.

systemProperties 빈은 System.getProperties() 메서드가 돌려주는 Properties 타입의 오브젝트를 읽기 전용으로 접근할 수 있게 만든 빈 오브젝트다.  
JVM이 생성해 주는 시스템 프로퍼티 값을 읽을 수 있게 해준다.

systemEnvironment는 System.getEnv()에서 제공하는 환경 변수가 담긴 Map 오브젝트다.  
JVM이 직접 정의해 주는 시스템 프로퍼티와 달리 환경 변수의 이름은 OS의 종류나 서버 환경 설정에 따라 달라질 수 있기 때문에 서버 환경이 바뀌면 주의해야 한다.

systemProperties, systemEnvironment라는 이름의 빈을 직접 정의해두면 스프링이 이 빈들을 자동으로 추가해 주지 못하기 때문에 주의해야 한다.
