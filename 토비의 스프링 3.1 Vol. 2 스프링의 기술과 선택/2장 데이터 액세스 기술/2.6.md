# 2.6 트랜잭션

`선언적 트랜잭션 경계 설정` 기능을 이용하면 코드 내에서 직접 트랜잭션을 관리하고 트랜잭션 정보를 파라미터로 넘겨서 사용하지 않아도 된다.  
트랜잭션이 시작되고 종료되는 지점은 별도의 설정을 통해 결정된다.  
또 작은 단위로 분리되어 있는 데이터 액세스 로직과 비즈니스 로직 컴포넌트와 메서드를 조합해서 하나의 트랜잭션에서 동작하게 만드는 것도 선언적 트랜잭션이 제공하는 트랜잭션 전파 기능 적분에 가능하다.

## 2.6.1 트랜잭션 추상화와 동기화

스프링이 제공하는 트랜잭션 서비스는 `트랜잭션 추상화`와 `트랜잭션 동기화` 두 가지로 생각해 볼 수 있다.  
스프링은 데이터 액세스 기술과 트랜잭션 서비스 사이의 종속성을 제거하고 스프링이 제공하는 트랜잭션 추상 계층을 이용해서 트랜잭션 기능을 활용하도록 만들어준다.  
이를 통해 트랜잭션 서비스의 종류나 환경이 바뀌더라도 트랜잭션을 사용하는 코드는 그대로 유지할 수 있는 유연성을 얻을 수 있다.  
스프링의 트랜잭션 동기화는 트랜잭션을 일정 범위 안에서 유지해 주고, 어디서든 자유롭게 접근할 수 있게 만들어준다.

### PlatformTransactionManager

스프링 트랜잭션 추상화의 핵심 인터페이스는 `PlatformTransactionManager`다.  
모든 스프링의 트랜잭션 기능과 코드는 이 인터페이스를 통해서 로우 레벨의 트랜잭션 서비스를 이용할 수 있다.  
PlatformTransactionManager는 세 개의 메서드를 가지고 있다.

```java
public interface PlatformTransactionManager extends TransactionManager {
    TransactionStatus getTransaction(@Nullable TransactionDefinition definition) throws TransactionException;
    void commit(TransactionStatus status) throws TransactionException;
    void rollback(TransactionStatus status) throws TransactionException;
}
```

getTransaction() 메서드는 트랜잭션 속성에 따라서 새로 시작하거나 진행 중인 트랜잭션에 참여하거나, 진행 중인 트랜잭션을 무시하고 새로운 트랜잭션을 만드는 식으로 상황에 따라 다르게 동작한다.  
TransactionDefinition은 트랜잭션의 네 가지 속성을 나타내는 인터페이스다.  
TransactionStatus는 현재 참여하고 있는 트랜잭션의 ID와 구분 정보를 담고 있다.  
커밋 또는 롤백 시에 이 TransactionStatus을 사용한다.

### 트랜잭션 매니저의 종류

- DataSourceTransactionManager
  - Connection의 트랜잭션 API를 이용해서 트랜잭션을 관리해 주는 트랜잭션 매니저
  - DataSourceTransactionManager를 사용하려면 트랜잭션을 적용할 DataSource가 스프링의 빈으로 등록되어야 함
  - JDBC API를 이용해서 트랜잭션을 관리하는 데이터 액세스 기술인 JDBC와 iBatis SqlMap으로 만든 DAO에 적용할 수 있음
  - DataSourceTransactionManager가 사용할 DataSource는 getConnection()이 호출될 때마다 매번 새로운 Connection을 돌려줘야 함
- JpaTransactionManager
  - JPA를 이용하는 DAO에서 사용되며 JTA로 트랜잭션 서비스를 이용하는 경우에는 필요하지 않음
  - LocalContainerEntityManagerFactoryBean 타입의 빈을 프로퍼티로 설정해야 함
  - DataSourceTransactionManager가 제공하는 DataSource 레벨의 트랜잭션 관리 기능을 동시에 제공하기 때문에 JpaTransactionManager를 사용하면서 동시에 트랜잭션이 적용된 JDBC DAO 사용 가능
- HibernateTransactionManager
  - 하이버네이트 DAO에 사용
  - SessionFactory 타입의 빈을 프로퍼티로 설정해야 함
  - DataSource 레벨의 트랜잭션 관리 기능을 동시에 제공
- JtaTransactionManager
  - 하나 이상의 DB 또는 트랜잭션 리소스가 참여하는 글로벌 트랜잭션을 적용하기 위해 사용
  - 여러 개의 트랜잭션 리소스(DB, JMS 등)에 대한 작업을 하나의 트랜잭션으로 묶을 수 있고, 여러 대의 서버에 분산되어 진행되는 작업을 트랜잭션으로 연결해 주기도 함
  - JTA 트랜잭션을 이용하려면 트랜잭션 서비스를 제공하는 WAS를 이용하거나 독립 JTA 서비스를 제공해 주는 프레임워크를 사용해야 함

## 2.6.2 트랜잭션 경계 설정 전략

### 코드에 의한 트랜잭션 경계 설정

트랜잭션을 처리하기 위해 PlatformTransactionManager의 메서드를 직접 사용해도 되지만 트랜잭션 안에서 작업 중에 예외가 발생한 경우 트랜잭션을 롤백해 주도록 만들어야 하기 때문에 try/catch 블록을 써야 하는 번거로움이 발생한다.  
그래서 PlatformTransactionManager의 메서드를 직접 사용하는 대신 템플릿/콜백 방식의 TransactionTemplate을 이용하면 편리하다.

### 선언적 트랜잭션 경계 설정

선언적 트랜잭션을 이용하면 코드에는 전혀 영향을 주지 않으면서 특정 메서드 실행 전후에 트랜잭션이 시작되고 종료되거나 기존 트랜잭션에 참여하도록 만들 수 있다.  
이를 위해서는 **데코레이터 패턴을 적용한 트랜잭션 프록시 빈**을 사용해야 한다.

AOP를 이용해 트랜잭션 기능을 부여하는 방법은 다양하지만 보통 다음의 두 가지 방법이 가장 많이 사용된다.

- aop와 tx 네임스페이스
  - 스프링은 AOP 기능과 트랜잭션 설정을 위해 편리하게 사용할 수 있는 전용 태그 제공
  - aop 스키마의 태그와 tx 스키마의 태그 사용 가능
- @Transactional
  - 트랜잭션이 적용될 타깃 인터페이스나 클래스, 메서드 등에 @Transactional 애노테이션을 부여해서 트랜잭션 대상으로 지정하고 트랜잭션의 속성 제공

### 프록시 모드: 인터페이스와 클래스

스프링의 AOP는 기본적으로 다이내믹 프록시 기법을 이용해 동작한다.  
다이내믹 프록시를 적용하려면 인터페이스가 있어야 한다.  
하지만 특별한 경우에 인터페이스를 구현하지 않은 클래스에 트랜잭션을 적용해야 할 수 있다.  
이때는 스프링이 지원하는 `클래스 프록시 모드`를 사용하면 된다.  
스프링에서는 JDK 다이내믹 프록시 외에도 `CGLib` 라이브러리가 제공해 주는 클래스 레벨의 프록시도 사용할 수 있다.

### AOP 방식: 프록시와 AspectJ

스프링의 AOP는 기본적으로 프록시 방식이다.  
인터페이스를 이용하는 JDK 다이내믹 프록시든 클래스에 바로 프록시를 만드는 CGLib이든, 모두 프록시 오브젝트를 타깃 오브젝트 앞에 두고 호출 과정을 가로채서 트랜잭션과 같은 부가적인 작업을 진행해 준다.

프록시는 기능을 사용하려는 오브젝트인 클라이언트와 서비스를 제공하는 오브젝트인 타깃 오브젝트 사이에 데코레이터 패턴을 써서 투명하게 추가된다.  
투명하게 추가된다는 것은 프록시가 추가되더라도 클라이언트와 타깃 오브젝트의 코드를 수정할 필요도 없고 기본 기능에도 영향을 주지 않는다는 뜻이다.

## 2.6.3 트랜잭션 속성

### 트랜잭션 전파: propagation

트랜잭션을 시작하거나 기존 트랜잭션에 참여하는 방법을 결정하는 속성이다.  
스프링이 지원하는 트랜잭션 전파 속성은 다음 여섯 가지가 있다.  
모든 속성이 모든 종류의 트랜잭션 매니저와 데이터 액세스 기술에서 다 지원되진 않음을 주의해야 한다.

- REQUIRED
  - 디폴트 속성
  - 모든 트랜잭션 매니저가 지원함
  - 이미 시작된 트랜잭션이 있으면 참여하고, 없으면 새로 시작
- SUPPORTS
  - 이미 시작된 트랜잭션이 있으면 참여하고, 없으면 트랜잭션 없이 진행
  - 트랜잭션이 없지만 해당 경계 안에서 Connection이나 하이버네이트 Session 등을 공유할 수 있음
- MANDATORY
  - 이미 시작된 트랜잭션이 있으면 참여하고, 없으면 예외 발생
  - 혼자서는 독립적으로 트랜잭션을 진행하면 안 되는 경우 사용
- REQUIRES_NEW
  - 항상 새로운 트랜잭션 시작
  - 이미 시작된 트랜잭션이 있으면 기존 트랜잭션 잠시 보류
  - JTA 트랜잭션 매니저를 사용한다면 서버의 트랜잭션 매니저에 트랜잭션 보류가 가능하도록 설정되어 있어야 함
- NOT_SUPPORTED
  - 트랜잭션을 사용하지 않게 함
  - 이미 시작된 트랜잭션이 있으면 보류
- NEVER
  - 트랜잭션을 사용하지 않도록 강제함
  - 이미 시작된 트랜잭션이 있으면 예외 발생
- NESTED
  - 이미 시작된 트랜잭션이 있으면 중첩 트랜잭션 시작
  - 중첩된 트랜잭션은 먼저 시작된 부모 트랜잭션의 커밋과 롤백에 영향을 받지만 자신의 커밋과 롤백은 부모 트랜잭션에 영향을 주지 않음

### 트랜잭션 격리 수준: isolation

트랜잭션 격리 수준은 동시에 여러 트랜잭션이 진행될 때 트랜잭션의 작업 결과를 다른 트랜잭션에게 어떻게 노출할 것인지를 결정하는 기준이다.  
스프링은 다음 다섯 가지의 격리 수준 속성을 지원한다.

- DEFAULT
  - 사용하는 데이터 액세스 기술 또는 DB 드라이버의 디폴트 설정을 따름
  - 보통 DB 드라이버의 격리 수준은 DB의 격리 수준을 따르는 게 일반적임
- READ_UNCOMMITED
  - 하나의 트랜잭션이 커밋 되기 전에 그 변화가 다른 트랜잭션에 그대로 노출됨
- READ_COMMITED
  - 가장 많이 사용되는 격리 수준
  - 다른 트랜잭션이 커밋하지 않은 정보는 읽을 수 없음
  - 하지만 하나의 트랜잭션이 읽은 로우를 다른 트랜잭션이 수정할 수 있음
- REPEATABLE_READ
  - 하나의 트랜잭션이 읽은 로우를 다른 트랜잭션이 수정하는 것을 막아줌
  - 하지만 새로운 로우를 추가하는 것은 제한하지 않음
- SERIALIZABLE
  - 트랜잭션을 순차적으로 진행시켜주기 때문에 여러 트랜잭션이 동시에 같은 테이블의 정보를 액세스할 수 없음

### 트랜잭션 제한 시간: timeout

이 속성을 이용하면 트랜잭션에 제한 시간을 지정할 수 있으며, 값은 초 단위로 지정한다.

### 읽기 전용 트랜잭션: read-only, readOnly

성능을 최적화하기 위해 사용할 수도 있고 특정 트랜잭션 작업 안에서 쓰기 작업이 일어나는 것을 의도적으로 방지하기 위해 사용할 수도 있다.  
일반적으로는 읽기 전용 트랜잭션이 시작된 이후 INSERT, UPDATE, DELETE 같은 쓰기 작업이 진행되면 예외가 발생한다.

### 트랜잭션 롤백 예외: rollback-for, rollbackFor, rollbackForClassName

선언적 트랜잭션에서는 런타임 예외가 발생하면 롤백한다.  
반면에 예외가 전혀 발생하지 않거나 체크 예외가 발생하면 커밋한다.  
체크 예외를 커밋 대상으로 삼은 이유는 체크 예외가 예외적인 상황에서 사용되기보다는 리턴 값을 대신해서 비즈니스적인 의미를 담은 결과를 돌려주는 용도로 많이 사용되기 때문이다.  
스프링에서는 데이터 액세스 기술의 예외는 런타임 예외로 전환되어서 던져지므로 런타임 예외만 롤백 대상으로 삼은 것이다.

하지만 원한다면 기본 동작 방식을 바꿀 수 있다.  
체크 예외지만 롤백 대상으로 삼아야 하는 것이 있다면 XML의 rollback-for 애트리뷰트나 애노테이션의 rollbackFor 또는 rollbackForClassName 엘리먼트를 사용해서 예외를 지정하면 된다.

### 트랜잭션 커밋 예외: no-rollback-for, noRollbackFor, noRollbackForClassName

rollback-for 속성과는 반대로 기본적으로는 롤백 대상인 런타임 예외를 트랜잭션 커밋 속성으로 지정해 준다.
