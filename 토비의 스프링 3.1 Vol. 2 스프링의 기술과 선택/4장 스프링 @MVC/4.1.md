# 4.1 @RequestMapping 핸들러 매핑

@MVC의 가장 큰 특징은 핸들러 매핑과 핸들러 어댑터의 대상이 오브젝트가 아니라 메서드라는 점이다.  
@MVC의 핸들러 매핑을 위해서는 `DefaultAnnotationHandlerMapping`이 필요하다.  
DefaultAnnotationHandlerMapping은 디폴트 핸들러 매핑 전략이므로 다른 핸들러 매핑 빈을 명시적으로 등록하지 않았다면 기본적으로 사용할 수 있다.

## 4.1.1 클래스/메서드 결합 매핑 정보

DefaultAnnotationHandlerMapping의 핵심은 매핑 정보로 `@RequestMapping` 애노테이션을 활용한다는 점이다.  
@RequestMapping은 타입 레벨뿐 아니라 메서드 레벨에도 붙일 수 있어서 스프링은 이 두 가지 위치에 붙은 @RequestMapping의 정보를 결합해서 최종 매핑 정보를 생성한다.

### @RequestMapping 애노테이션

@RequestMapping 애노테이션에는 다음과 같은 엘리먼트를 지정할 수 있다.

- String[] value(): URL 패턴
  - 디폴트 엘리먼트인 value는 스트링 배열 타입으로 URL 패턴을 지정하도록 되어 있음
  - 대부분의 핸들러 매핑은 요청 정보 중에서 URL만을 사용함
  - 다른 핸들러 매핑에서 사용하는 URL 패턴처럼 ANT 스타일의 와일드카드를 사용할 수 있음
- RequestMethod[] method(): HTTP 요청 메서드
  - RequestMethod는 HTTP 메서드를 정의한 enum(GET, HEAD, POST, PUT, PATCH, DELETE, OPTIONS, TRACE)
  - 설정한 메서드 외의 HTTP 메서드로 접근 시 HTTP 405 - Method Not Allowed 응답 리턴
- String[] params(): 요청 파라미터
  - 같은 URL을 사용하더라도 HTTP 요청 파라미터에 따라 별도의 작업을 해주고 싶을 때 사용
  - params에 지정한 파라미터는 URL에 포함된 것뿐 아니라 POST로 전송한 파라미터도 비교 대상임
  - 파라미터 앞에 "!"를 붙여서 특정 파라미터가 존재하지 않아야 한다는 조건 지정 가능
- String[] headers(): HTTP 헤더
  - HTTP 헤더의 값에 따라 별도의 작업을 해주고 싶을 때 사용

### 타입 레벨 매핑과 메서드 레벨 매핑의 결합

타입(클래스와 인터페이스) 레벨에 붙는 @RequestMapping은 타입 내의 모든 매핑용 메서드의 공통 조건을 지정할 때 사용한다.  
메서드 레벨의 매핑은 클래스 레벨의 매핑을 상속받는다고 보면 된다.

타입 레벨의 URL 패턴에 \*나 \*\*를 사용했을 때도 URL을 결합할 수 있다.

### 메서드 레벨 단독 매핑

메서드 레벨의 매핑 조건에 공통점이 없는 경우라면 타입 레벨에서는 조건을 주지 않고 메서드 레벨에서 독립적으로 매핑 정보를 지정할 수도 있다.  
이때 타입 레벨에는 조건이 없는 @RequestMapping을 붙여두면 된다.  
이마저 생략하면 아예 클래스 자체가 매핑 대상이 되지 않으니 내용이 없는 @RequestMapping이라도 꼭 부여해 줘야 한다.  
컨트롤러 클래스에 @Controller 애노테이션을 붙여서 빈 자동 스캔 방식으로 등록되게 했다면, 스프링이 @Controller 애노테이션을 보고 애노테이션 방식을 사용한 클래스라고 판단하기 때문에 이때는 클래스 레벨의 @RequestMapping을 생략할 수 있다.

### 타입 레벨 단독 매핑

핸들러 매핑은 원래 핸들러 오브젝트를 결정하는 전략이다.  
애노테이션의 영향으로 매핑 방법이 메서드 레벨까지 세분화되기는 했지만 다른 타입 컨트롤러와의 일관성을 위해 애노테이션 방식의 핸들러 매핑에서도 일단 오브젝트까지만 매핑을 하고, 최종 실행할 메서드는 핸들러 어댑터가 선정한다.

## 4.1.2 타립 상속과 매핑

@RequestMapping이 적용된 클래스를 상속해서 컨트롤러로 사용하는 경우에는 기본 원칙 두 가지만 기억하면 된다.

- @RequestMapping 정보는 상속됨
- 서브클래스에서 @RequestMapping을 재정의하면 슈퍼클래스의 정보는 무시됨

애노테이션의 상속이라는 개념은 클래스나 메서드의 상속과는 성격이 다르긴 하지만 @RequestMapping의 경우는 서브클래스에서 재정의하지 않는 한 상속을 통해서도 유지된다고 보면 된다.

인터페이스의 @RequestMapping은 인터페이스를 구현한 클래스의 매핑 정보로 사용된다.  
같은 인터페이스 안에서 타입(인터페이스) 레벨과 메서드 레벨 사이의 관계와 매핑 조건 결합은 클래스와 동일하게 적용된다.  
인터페이스 구현에 의한 @RequestMapping 정보 상속은 클래스 상속과 거의 비슷하지만 몇 가지 차이점이 있으니 주의해야 한다.

### 매핑 정보 상속의 종류

다음은 클래스 상속이나 인터페이스 구현에서 매핑 정보가 어떻게 상속되고 적용되는지에 대한 몇 가지 대표적인 경우다.  
클래스 상속의 경우와 인터페이스 구현의 경우는 모두 동일하다.

- 상위 타입과 메서드의 @RequestMapping 상속
  - 슈퍼클래스에 정의된 모든 매핑 정보를 그대로 서브클래스가 물려받음
  - 서브클래스에서 메서드를 오버라이드했더라도 메서드에 @RequestMapping을 붙이지 않으면 슈퍼클래스 메서드의 매핑 정보 그대로 상속
- 상위 타입의 @RequestMapping과 하위 타입 메서드의 @RequestMapping 결합
  - 마치 서브클래스의 타입 레벨에 @RequestMapping이 정의되어 있는 것처럼 각 메서드의 매핑 정보가 결합되어서 최종적인 메서드 레벨의 매핑 조건 생성
- 상위 타입 메서드의 @RequestMapping과 하위 타입의 @RequestMapping 결합
  - 상위 타입 메서드의 @RequestMapping이 상속되어 하위 타입의 @RequestMapping과 결합
- 하위 타입과 메서드의 @RequestMapping 재정의
  - 상속 또는 구현을 통해 만들어진 하위 타입이나 메서드에 @RequestMapping을 부여하면 상위 타입이나 메서드에서 지정한 @RequestMapping 매핑 정보를 대체해서 적용
  - 슈퍼클래스의 @RequestMapping은 모두 무시되고(URL, HTTP 메서드, 파라미터 등) 새로 정의한 서브클래스의 @RequestMapping이 적용됨
