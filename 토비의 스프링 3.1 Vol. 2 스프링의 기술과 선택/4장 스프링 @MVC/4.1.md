# 4.1 @RequestMapping 핸들러 매핑

@MVC의 가장 큰 특징은 핸들러 매핑과 핸들러 어댑터의 대상이 오브젝트가 아니라 메서드라는 점이다.  
@MVC의 핸들러 매핑을 위해서는 `DefaultAnnotationHandlerMapping`이 필요하다.  
DefaultAnnotationHandlerMapping은 디폴트 핸들러 매핑 전략이므로 다른 핸들러 매핑 빈을 명시적으로 등록하지 않았다면 기본적으로 사용할 수 있다.

## 4.1.1 클래스/메서드 결합 매핑 정보

DefaultAnnotationHandlerMapping의 핵심은 매핑 정보로 `@RequestMapping` 애노테이션을 활용한다는 점이다.  
@RequestMapping은 타입 레벨뿐 아니라 메서드 레벨에도 붙일 수 있어서 스프링은 이 두 가지 위치에 붙은 @RequestMapping의 정보를 결합해서 최종 매핑 정보를 생성한다.

### @RequestMapping 애노테이션

@RequestMapping 애노테이션에는 다음과 같은 엘리먼트를 지정할 수 있다.  

- String[] value(): URL 패턴
  - 디폴트 엘리먼트인 value는 스트링 배열 타입으로 URL 패턴을 지정하도록 되어 있음
  - 대부분의 핸들러 매핑은 요청 정보 중에서 URL만을 사용함
  - 다른 핸들러 매핑에서 사용하는 URL 패턴처럼 ANT 스타일의 와일드카드를 사용할 수 있음
- RequestMethod[] method(): HTTP 요청 메서드
  - RequestMethod는 HTTP 메서드를 정의한 enum(GET, HEAD, POST, PUT, PATCH, DELETE, OPTIONS, TRACE)
  - 설정한 메서드 외의 HTTP 메서드로 접근 시 HTTP 405 - Method Not Allowed 응답 리턴
- String[] params(): 요청 파라미터
  - 같은 URL을 사용하더라도 HTTP 요청 파라미터에 따라 별도의 작업을 해주고 싶을 때 사용
  - params에 지정한 파라미터는 URL에 포함된 것뿐 아니라 POST로 전송한 파라미터도 비교 대상임
  - 파라미터 앞에 "!"를 붙여서 특정 파라미터가 존재하지 않아야 한다는 조건 지정 가능
- String[] headers(): HTTP 헤더
  - HTTP 헤더의 값에 따라 별도의 작업을 해주고 싶을 때 사용

### 타입 레벨 매핑과 메서드 레벨 매핑의 결합

타입(클래스와 인터페이스) 레벨에 붙는 @RequestMapping은 타입 내의 모든 매핑용 메서드의 공통 조건을 지정할 때 사용한다.  
메서드 레벨의 매핑은 클래스 레벨의 매핑을 상속받는다고 보면 된다.

타입 레벨의 URL 패턴에 *나  **를 사용했을 때도 URL을 결합할 수 있다.  

### 메서드 레벨 단독 매핑

메서드 레벨의 매핑 조건에 공통점이 없는 경우라면 타입 레벨에서는 조건을 주지 않고 메서드 레벨에서 독립적으로 매핑 정보를 지정할 수도 있다.  
이때 타입 레벨에는 조건이 없는 @RequestMapping을 붙여두면 된다.  
이마저 생략하면 아예 클래스 자체가 매핑 대상이 되지 않으니 내용이 없는 @RequestMapping이라도 꼭 부여해 줘야 한다.  
컨트롤러 클래스에 @Controller 애노테이션을 붙여서 빈 자동 스캔 방식으로 등록되게 했다면, 스프링이 @Controller 애노테이션을 보고 애노테이션 방식을 사용한 클래스라고 판단하기 때문에 이때는 클래스 레벨의 @RequestMapping을 생략할 수 있다.

### 타입 레벨 단독 매핑

핸들러 매핑은 원래 핸들러 오브젝트를 결정하는 전략이다.  
애노테이션의 영향으로 매핑 방법이 메서드 레벨까지 세분화되기는 했지만 다른 타입 컨트롤러와의 일관성을 위해 애노테이션 방식의 핸들러 매핑에서도 일단 오브젝트까지만 매핑을 하고, 최종 실행할 메서드는 핸들러 어댑터가 선정한다.
