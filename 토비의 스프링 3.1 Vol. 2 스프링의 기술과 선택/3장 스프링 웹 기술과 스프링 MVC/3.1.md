# 3.1 스프링의 웹 프레젠테이션 계층 기술

프레젠테이션 계층은 복잡하고 다양한 기술의 조합으로 구성될 수 있다.  
스프링은 의도적으로 서블릿 웹 애플리케이션의 컨텍스트를 두 가지로 분리해놓았다.

- 웹 기술에서 완전히 독립적인 비즈니스 서비스 계층과 데이터 액세스 계층을 담은 `루트 애플리케이션 컨텍스트`
- 스프링 웹 기술을 기반으로 동작하는 웹 관련 빈을 담은 `서블릿 애플리케이션 컨텍스트`

이렇게 스프링 컨텍스트를 두 가지로 분리해둔 이유는 스프링 웹 서블릿 컨텍스트를 통째로 다른 기술로 대체할 수 있도록 하기 위해서다.

## 3.1.1 스프링에서 사용되는 웹 프레임워크의 종류

### 스프링 웹 프레임워크

다음은 스프링이 직접 제공하는 웹 프레임워크다.

- 스프링 서블릿/스프링 MVC
  - 스프링이 직접 제공하는 서블릿 기반의 MVC 프레임워크
  - `프론트 컨트롤러` 역할을 하는 `DispatcherServlet`을 핵심 엔진으로 사용
  - MVC 프레임워크의 많은 기능을 자유롭게 확장 가능
  - 스프링 서블릿의 모든 컴포넌트는 스프링의 서블릿 애플리케이션 컨텍스트의 빈으로 등록되어 동작하기 때문에 루트 컨텍스트에 존재하는 서비스 계층의 빈 사용 가능
- 스프링 포틀릿
  - 스프링이 제공하는 포틀릿 MVC 프레임워크
  - 서블릿과 유사한 포틀릿 컨테이너에서 동작

### 스프링 포트폴리오 웹 프레임워크

다음은 스프링 서블릿을 기반으로 하는 고급 웹 프레임워크다.

- Spring Web Flow
  - 스프링 서블릿을 기반으로 해서 상태 유지(stateful) 스타일의 웹 애플리케이션을 작성하게 해주는 프레임워크
- Spring JavaScript
  - 자바스크립트 툴킷인 Dojo를 추상화한 것으로, 스프링 서블릿과 스프링 웹 플로우에 연동해서 손쉽게 Ajax 기능을 구축할 수 있도록 만들어짐
- Spring Faces
  - JSF를 스프링 MVC와 스프링 SWF의 뷰로 손쉽게 사용할 수 있게 해주는 프레임워크
- Spring Web Service
  - 스프링 MVC와 유사한 방식으로 SOAP 기반의 웹 서비스 개발을 가능하게 해주는 프레임워크
- Spring BlazeDS Integration
  - 어도비 플렉스(Adobe Flex)의 BlazeDS와 스프링을 통합해서 빠르고 쉽게 플렉스를 지원하는 스프링 애플리케이션을 개발할 수 있도록 해주는 연동 프레임워크

### 스프링을 기반으로 두지 않는 웹 프레임워크

다음은 스프링 서블릿/MVC 대신 사용할 수 있는 웹 기술이나 웹 프레임워크다.

- JSP/Servlet
  - 기존에 만들어뒀던 모델 1 방식의 JSP나 서블릿을 스프링 애플리케이션의 웹 프레젠테이션 계층으로 사용 가능
- Struts1
  - 한때 사실상의 표준 웹 프레임워크라고 불릴 만큼 큰 인기를 누렸던 MVC 프레임워크
- Struts2
  - 스트럿츠 2와 스프링을 함께 사용하려면 개발팀이 직접 제공하는 플러그인의 하나인 struts2-spring 플러그인을 사용해야 함

## 3.1.2 스프링 MVC와 DispatcherServlet 전략

프레임워크 기술은 두 가지 방향으로 발전하고 있다.

- 스프링과 같은 범용적 프레임워크
  - 유연성과 확장성에 중점을 두고 어떤 종류의 시스템 개발이나 환경, 요구 조건에도 잘 들어맞도록 재구성 가능
  - 각 계층과 기술 사이의 독립성을 중요하게 생각하기 때문에 계층과 기술이 서로의 내부를 잘 알고 강하게 결합되는 것을 극도로 꺼림
  - 각 계층을 독립적으로 개발하고 테스트할 수 있으며 한 계층의 기술이나 구현은 다른 계층의 코드에 영향을 주지 않은 채로 자유롭게 변경하거나 교체 가능
  - 유연한 아키텍처를 가지고 장기적으로 많은 인원이 큰 규모의 시스템을 개발할 때 적합한 프레임워크
- 루비 기반의 RoR과 같은 일체형 고속 개발 프레임워크
  - 기술에 대한 자기주장이 강하고 기술 선호도가 분명하기 때문에 제한적인 기술만을 사용하도록 강제함
  - 전 계층이 매우 긴밀하게 연동하고 있기 때문에 계층 간의 느슨한 연결을 유지해야 하는 부담이 없고 강하게 결합된 최적화된 코드를 만들 수 있음
  - 계층과 구조는 단순하고 각 기술의 장점을 극대화할 수 있고, 미리 정해진 관례를 따르기만 하면 많은 코드와 설정을 생략하고 빠르게 개발 가능

스프링은 분명히 유연성과 확장성, 다양성에 무게를 두고 있는 프레임워크다.  
스프링은 집착에 가까울 정도로 모든 기능을 다양한 방법으로 확장하도록 설계되어 있다.  
스프링을 잘 사용하는 비결은 이러한 **스프링의 유연한 확장성을 최대한 활용해서 위의 두 번째 스타일의 프레임워크를 지향하는 것**이다.

스프링은 특정 기술이나 방식에 매이지 않으면서 웹 프레젠테이션 계층의 각종 기술을 조합, 확장해서 사용할 수 있는 매우 유연한 웹 애플리케이션 개발의 기본 틀을 제공해 준다.  
이 틀이 제공하는 다양한 전략의 확장 포인트를 이용해서 스프링 스스로 기본적인 MVC 프레임워크를 만들어뒀다.  
스프링의 MVC 프레임워크는 꾸준히 발전해 오면서 점점 더 다양하고 편리한 기능과 개발 방법을 제공하고 있다.

스프링을 사용하는 개발자는 스프링이 제공해 준 MVC 프레임워크 위에 필요한 전략을 추가해서 사용할 수 있어야 한다.  
스프링 MVC 프레임워크를 이미 완성된 고정적인 프레임워크로 보지 말고, 진행하려는 프로젝트의 특성에 맞게 빠르고 편리한 개발이 가능하도록 자신만의 웹 프레임워크를 만드는 데 쓸 수 있는 도구라고 생각할 필요가
있다.  
이것이 스프링이 제공하는 가치를 누리며 스프링을 잘 사용할 수 있는 비결이다.

스프링 웹 기술의 핵심이자 기반이 되는 것은 `DispatcherServlet`이다.  
이 서블릿은 **스프링의 웹 기술을 구성하는 다양한 전략을 DI로 구성해서 확장하도록 만들어진 스프링 서블릿/MVC의 엔진과 같은 역할**을 한다.

### DispatcherServlet과 MVC 아키텍처

스프링의 웹 기술은 MVC 아키텍처를 근간으로 하고 있다.  
MVC는 프레젠테이션 계층의 구성 요소를 담은 모델(M), 화면 출력 로직을 담은 뷰(V), 그리고 제어 로직을 담은 컨트롤러(C)로 분리하고 이 세 가지 요소가 서로 협력해서 하나의 웹 요청을 처리하고 응답을 만들어내는 구조다.

MVC 아키텍처는 보통 `프론트 컨트롤러(front controller) 패턴`과 함께 사용된다.  
프론트 컨트롤러 패턴은 **중앙 집중형 컨트롤러를 프레젠테이션 계층의 제일 앞에 둬서 서버로 들어오는 모든 요청을 먼저 받아서 처리**하게 만든다.  
프론트 컨트롤러는 클라이언트가 보낸 요청을 받아서 공통적인 작업을 먼저 수행한 후에 적절한 세부 컨트롤러로 작업을 위임해 주고, 클라이언트에게 보낼 뷰를 선택해서 최종 결과를 생성하는 등의 작업을 수행한다.

다음은 서버나 브라우저가 여타 HTTP 클라이언트로부터 HTTP 요청을 받기 시작해서 다시 HTTP로 결과를 응답해 주기까지의 과정이다.

1. DispatcherServlet의 HTTP 요청 접수
    - 자바 서버의 서블릿 컨테이너는 HTTP 프로토콜을 통해 들어오는 요청이 스프링의 DispatcherServlet에 할당된 것이라면 HTTP 요청 정보를 DispatcherServlet에 전달
    - DispatcherServlet은 모든 요청에 대해 공통적으로 진행해야 하는 전처리 작업이 등록된 것이 있다면 이를 먼저 수행(보안, 파라미터 조작, 한글 디코딩 등)
2. DispatcherServlet에서 컨트롤러로 HTTP 요청 위임
    - DispatcherServlet은 URL이나 파라미터 정보, HTTP 명령 등을 참고로 해서 어떤 컨트롤러에게 작업을 위임할지 결정
    - 컨트롤러를 선정하는 것은 DispatcherServlet의 핸들러 매핑 전략(사용자 요청을 기준으로 어떤 핸들러에게 작업을 위임할지를 결정해 주는 것) 이용
    - 어떤 컨트롤러/핸들러가 요청을 처리하게 할지를 결정했다면 해당 컨트롤러 오브젝트의 메서드를 호출해서 실제로 웹 요청을 처리하는 작업을 위임
    - DispatcherServlet은 컨트롤러의 종류에 따라 적절한 어댑터를 사용하기 때문에 동시에 여러 가지 타입의 컨트롤러를 사용할 수 있음
    - DispatcherServlet이 핸들러 어댑터에 웹 요청을 전달할 때는 모든 웹 요청 정보가 담긴 HttpServletRequest 타입의 오브젝트를 전달해 주고, 이를 어댑터가 컨트롤러의 메서드가 받을
      수 있는 파라미터로 변환해서 전달
3. 컨트롤러의 모델 생성과 정보 등록
    - 모델을 생성하고 모델에 정보를 넣어주는 게 컨트롤러가 해야 할 중요한 작업 중 하나에 해당함
4. 컨트롤러의 결과 리턴: 모델과 뷰
    - 모델이 준비됐으면 다음으로 뷰를 결정해야 함
    - 컨트롤러가 뷰 오브젝트를 직접 리턴할 수도 있지만, 보통은 뷰의 논리적인 이름을 리턴해주면 DispatcherServlet의 전략인 뷰 리졸버가 이를 이용해 뷰 오브젝트를 생성함
    - ModelAndView 오브젝트는 DispatcherServlet이 최종적으로 어댑터를 통해 컨트롤러로부터 돌려받는 오브젝트
    - 모델과 뷰를 넘기는 것으로 컨트롤러의 책임은 끝이며, 다시 작업은 DispatcherServlet으로 넘어감
5. DispatcherServlet의 뷰 호출과 모델 참조
    - DispatcherServlet은 컨트롤러로부터 모델과 뷰를 받은 뒤 뷰 오브젝트에게 모델을 전달해 주고 클라이언트에게 돌려줄 최종 결과물을 생성해달라고 요청함
    - 뷰 작업을 통한 최종 결과물은 HttpServletResponse 오브젝트 안에 담김
6. HTTP 응답 돌려주기
    - 뷰 생성까지의 모든 작업을 마쳤으면 DispatcherServlet은 등록된 후처리기가 있는지 확인하고, 있다면 후처리기에서 후속 작업을 진행한 뒤에 뷰가 만들어준 HttpServletResponse에
      담긴 최종 결과를 서블릿 컨테이너에게 돌려줌
    - 서블릿 컨테이너는 HttpServletResponse에 담긴 정보를 HTTP 응답으로 만들어 사용자의 브라우저나 클라이언트에게 전송하고 작업 종료

### DispatcherServlet의 DI 가능한 전략

DispatcherServlet에는 DI로 동작 방식과 기능을 확장, 변경할 수 있도록 준비된 전략들이 존재한다.  
스프링 MVC는 자주 사용되는 전략을 디폴트로 설정해 주고 있다.  
필요한 전략만 확장해서 사용하고 나머지는 디폴트 전략을 이용해도 된다.

- `HandlerMapping`
  - **URL과 요청 정보를 기준으로 어떤 핸들러 오브젝트, 즉 컨트롤러를 사용할 것인지를 결정하는 로직 담당**
  - HandlerMapping 인터페이스를 구현해서 만들 수 있음
  - DispatcherServlet은 하나 이상의 핸들러 매핑을 가질 수 있음
  - 디폴트로는 `BeanNameUrlHandlerMapping`, `DefaultAnnotationHandlerMapping` 두 가지가 설정되어 있음
- `HandlerAdapter`
  - **핸들러 매핑으로 선택한 컨트롤러/핸들러를 DispatcherServlet이 호출할 때 사용하는 어댑터**
  - 컨트롤러의 타입에는 제한이 없으며, 컨트롤러 호출 방법은 타입에 따라 다르기 때문에 컨트롤러를 결정했다고 해도 호출 방법을 DispatcherServlet이 알 길이 없으므로 컨트롤러 타입을 지원하는 HandlerAdapter가 필요함
  - 디폴트로 등록되어 있는 핸들러 어댑터는 `HttpRequestHandlerAdapter`, `SimpleControllerHandlerAdapter`, `AnnotationMethodHandlerAdapter` 세 가지가 있음
  - 핸들러 매핑과 어댑터는 서로 관련이 있을 수도 있고 없을 수도 있음
- `HandlerExceptionResolver`
  - **예외가 발생했을 때 이를 처리하는 로직을 가지고 있음**
  - 예외가 발생했을 때 예외의 종류에 따라 에러 페이지를 표시한다거나, 관리자에게 통보해 주는 등의 작업은 개발 컨트롤러가 아니라 프론트 컨트롤러인 DispatcherServlet을 통해 처리되어야 함
  - DispatcherServlet은 등록된 HandlerExceptionResolver 중에서 발생한 예외에 적합한 것을 찾아서 예외 처리 위임
  - 디폴트 전략은 `AnnotationMethodHandlerExceptionResolver`, `ResponseStatusExceptionResolver`, `DefaultHandlerExceptionResolver` 세 가지가 등록되어 있음
- `ViewResolver`
  - **컨트롤러가 리턴한 뷰 이름을 참고해서 적절한 뷰 오브젝트를 찾아주는 로직을 가진 전략 오브젝트**
  - 스프링이 지원하는 뷰의 종류는 매우 다양함
- LocaleResolver
  - **지역(locale) 정보를 설정해 주는 전략**
  - 디폴트인 AcceptHeaderLocaleResolver는 HTTP 헤더의 정보를 보고 지역 정보 설정
  - 이 전략을 변경하면 지역 정보를 HTTP 헤더 대신 세션이나 URL 파라미터, 쿠키 등 다양한 방식으로 결정할 수 있음
- ThemeResolver
  - 테마를 가지고 이를 변경해서 사이트를 구성할 경우 쓸 수 있는 테마 정보를 결정해 주는 전략
- RequestToViewNameTranslator
  - 컨트롤러에서 뷰 이름이나 뷰 오브젝트를 제공해 주지 않았을 경우 URL과 같은 요청 정보를 참고해서 자동으로 뷰 이름을 생성해 주는 전략
  - 디폴트는 DefaultRequestToViewNameTranslator

DispatcherServlet은 각 전략의 디폴트 설정을 DispatcherServlet.properties라는 전략 설정 파일로부터 가져와서 초기화한다.  
DispatcherServlet은 서블릿 컨테이너가 생성하고 관리하는 오브젝트이지, 스프링의 컨텍스트에서 관리하는 빈 오브젝트가 아니다.  

스프링 서블릿/MVC의 기능은 워낙 다양하고 수많은 옵션과 확장 포인트가 있기 때문에 설정을 바꾸면 동작하는 방식도 다양하게 바뀐다.  
먼저 스프링이 제공하는 옵션을 충분히 살펴보고, 자신의 프로젝트에 적용하기 적합한 전략 조합과 필요한 설정을 결정하고 필요에 따라 확장 기능을 만들기도 해야 한다.
