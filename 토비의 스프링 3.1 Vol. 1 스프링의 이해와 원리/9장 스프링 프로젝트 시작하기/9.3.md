# 9.3 애플리케이션 아키텍처

아키텍처는 여러 가지 방식으로 정의되고 이해될 수 있는 용어다.  
가장 단순한 정의는 **어떤 경계 안에 있는 내부 구성 요소들이 어떤 책임을 가지고 있고, 어떤 방식으로 서로 관계를 맺고 동작하는지를 규정하는 것**이라고 할 수 있다.  
아키텍처는 단순히 정적인 구조를 나타내는 것으로만 생각하기 쉽지만 실제로는 그 구조에서 일어나는 동적인 행위와 깊은 관계가 있다.

## 9.3.1 계층형 아키텍처

성격이 다른 모듈이 강하게 결합되어 한데 모여 있으면 한 가지 이유로 변경이 일어날 때 그와 상관이 없는 요소도 함께 영향을 받게 된다.  
따라서 불필요한 부분까지 변경이 일어나고 그로 인해 작업은 더뎌지고 오류가 발생할 가능성이 높아지고, 어느 부분을 수정해야 할지를 파악하기도 쉽지 않다.  
따라서 인터페이스와 같은 유연한 경계를 만들어 두고 분리하거나 모아주는 작업이 필요하다.

### 아키텍처와 SoC

성격이 다른 것은 아키텍처 레벨에서 분리해 주는 게 좋다.  
분리된 각 오브젝트는 독자적으로 개발과 테스트가 가능해서 개발과 변경 작업이 모두 빨라질 수 있다.  
이렇게 책임과 성격이 다른 것을 크게 그룹으로 만들어 분리해두는 것을 아키텍처 차원에서는 `계층형 아키텍처(layered architecture)`라고 부른다.  
또는 계층이라는 의미를 가진 영어 단어인 티어(tier)를 사용해서 **멀티 티어 아키텍처**라고도 한다.  
보통 웹 기반의 엔터프라이즈 애플리케이션은 일반적으로 세 개의 계층을 갖는다고 해서 **3계층(3-tier 또는 3-layer) 애플리케이션**이라고도 한다.

### 3계층 아키텍처와 수직 계층

3계층 아키텍처는 백엔드의 DB나 레거시 시스템과 연동하는 인터페이스 역할을 하는 `데이터 액세스 계층`, 비즈니스 로직을 담고 있는 `서비스 계층`, 주로 웹 기반의 UI를 만들어 내고 그 흐름을 관리하는 `프레젠테이션 계층`으로 구분한다.

- 데이터 액세스 계층
  - 장기적인 데이터 저장을 목적으로 하는 DB 이용이 주된 책임
  - 외부 시스템을 호출해서 서비스를 이용하는 것은 `기반(infrastructure) 계층`으로 따로 분류하기도 함
- 서비스 계층
  - 잘 만들어진 스프링 애플리케이션의 서비스 계층 클래스는 이상적인 POJO로 작성됨
  - 특별한 경우가 아니라면 추상화 수직 계층 구조를 가질 필요가 없음
- 프레젠테이션 계층
  - 웹과 프레젠테이션 기술은 끊임없이 발전하기 때문에 매우 다양한 기술과 프레임워크의 조합을 가질 수 있음
  - 엔터프라이즈 애플리케이션의 프레젠테이션 계층은 클라이언트의 종류와 상관없이 HTTP 프로토콜을 사용하는 서블릿이 바탕이 됨

### 계층형 아키텍처 설계의 원칙

각 계층은 응집도가 높으면서 다른 계층과는 낮은 결합도를 유지할 수 있어야 한다.  
자신의 역할과 기술에만 충실한 계층을 만들면 각 계층 사이의 결합도는 자연스럽게 낮아진다.  
각 계층이 자신의 책임에 충실하게 작성되어 있다면 필요한 그 밖의 정보는 다른 계층에 요청하게 될 것이다.  
이때는 계층 레벨에 정의한 인터페이스를 통해서 요청을 하게 되고, **계층 간에 사용되는 인터페이스 메서드에는 특정 계층의 기술이 최대한 드러나지 않게 만들어야 한다**.

## 9.3.2 애플리케이션 정보 아키텍처

엔터프라이즈 시스템은 본질적으로 동시에 많은 작업이 빠르게 수행되어야 하는 시스템이다.  
사용자의 작업 상태를 오래 유지할 수 있는 독립 애플리케이션과 달리 엔터프라이즈 애플리케이션은 일반적으로 사용자의 요청을 처리하는 동안만 간단한 상태를 유지한다.

애플리케이션을 사이에 두고 흘러 다니는 정보를 어떤 식으로 다룰지를 경정하는 일도 아키텍처를 결정할 때 매우 중요한 기준이 된다.  
엔터프라이즈 애플리케이션에 존재하는 정보를 단순히 데이터로 다루는 경우와 오브젝트로 다루는 경우, 두 가지 기준으로 구분해 볼 수 있다.

### DB/SQL 중심의 로직 구현 방식

데이터 중심 구조의 특징은 하나의 업무 트랜잭션에 모든 계층의 코드가 종속되는 경향이 있다는 점이다.  
대부분의 코드는 대응되는 작업 단위에 1:1로 매핑된다.  
하나의 업무 트랜잭션을 모두 담은 서비스 계층 코드와 해당 업무에 특화된 SQL을 담은 하나 또는 여러 개의 DAO 메서드로 구성된다.  
서비스 계층이 프레젠테이션 계층에 전달하는 결과의 포맷은 보통 DAO의 SQL 결과와 같고, 웹 페이지의 출력 내용과도 1:1로 대응된다.  

- 장점
  - 초기 개발이 쉬움
- 단점
  - 변화에 매우 취약함
  - 각 계층의 코드가 긴밀하게 연결되어 있기 때문에 객체지향의 장점이 별로 활용되지 못함
  - 중복을 제거하기가 어려움
  - 테스트하기 어려움

### 거대한 서비스 계층 방식

비즈니스 로직을 DB나 SQL에 담는 경우에는 항상 최종 결과만 DAO에서 서비스 계층으로 전달된다.  
반면에 거대 서비스 계층 방식에서는 DAO에서 좀 더 단순한 결과를 돌려준다.  
DAO가 돌려준 정보를 분석, 가공하면서 비즈니스 로직을 적용하는 것은 서비스 계층 코드의 책임이 된다.

- 장점
  - 애플리케이션 코드에 비즈니스 로직이 담겨 있기 때문에 자바 언어의 장점을 활용해 로직 구현 가능
  - 테스트하기 수월함
  - DAO가 다루는 SQL이 복잡하지 않고 프레젠테이션 계층의 뷰와 1:1로 매핑되지 않아도 되기 때문에 일부 DAO 코드를 여러 비즈니스 로직에서 공유 가능
  - 초기 개발 속도가 빠름
  - 개발자 사이에 간섭 없이 독립적인 개발 가능
- 단점
  - 데이터 액세스 계층의 SQL은 서비스 계층의 비즈니스 로직의 필요에 따라 만들어지기 쉬우므로 계층 간의 결합도가 높음
  - 서비스 계층의 메서드는 크기가 큰 업무 트랜잭션 단위로 만들어지기 때문에 비슷한 기능의 코드가 여러 메서드에 중복되어서 나타나기 쉬움

## 9.3.3 오브젝트 중심 아키텍처

오브젝트 중심 아키텍처가 데이터 중심 아키텍처와 다른 가장 큰 특징은 **도메인 모델을 반영하는 오브젝트 구조를 만들어 두고 그것을 각 계층 사이에서 정보를 전송하는 데 사용**한다는 것이다.  
대개 도메인 모델은 DB의 엔티티 설계에도 반영되기 때문에 관계형 DB의 엔티티 구조와도 유사한 형태일 가능성이 높다.

### 데이터와 오브젝트

오브젝트 방식에서는 애플리케이션에서 사용되는 정보가 도메인 모델의 구조를 반영해서 만들어진 오브젝트 안에 담긴다.  
도메인 모델은 애플리케이션 전 계층에서 동일한 의미를 갖는다.  
따라서 도메인 모델이 반영된 도메인 오브젝트도 전 계층에서 일관된 구조를 유지한 채로 사용될 수 있다.  
SQL이나 웹 페이지의 출력 포맷, 입력 폼 등에 종속되지 않는 일관된 형식의 애플리케이션의 정보를 다룰 수 있게 된다.

도메인 모델을 따르는 오브젝트 구조를 만들려면 DB에서 가져온 데이터를 도메인 오브젝트 구조에 맞게 변환해 줄 필요가 있다.  
DAO는 자신이 DB에서 가져와서 도메인 모델 오브젝트에 담아주는 정보가 어떤 업무 트랜잭션에서 어떻게 사용될지는 신경 쓰지 않아도 된다.

### 도메인 오브젝트를 사용하는 코드

오브젝트 구조로 정보를 가지고 있으면 어떤 식으로든 활용하기 편리하다.  
테스트할 때도 간단히 테스트 값을 담은 도메인 오브젝트를 생성해서 쉽게 검증할 수 있다.

### 도메인 오브젝트 사용의 문제점

일관된 의미를 가지고 유연하며 애플리케이션 전반에 공유 가능한 도메인 모델을 따르는 오브젝트로 정보를 다루면 많은 장점이 있다.

- 코드를 이해하기 쉽고 로직을 작성하기 수월함
- 프레젠테이션 영역에서도 이미 정의된 도메인 오브젝트 구조만 알고 있다면 아직 DAO가 작성되지 않았어도 뷰를 미리 생성 가능
- 코드의 재사용성이 높아짐
- DAO를 더 작고 효율적으로 만들 수 있음

하지만 단점도 존재한다.

- 최적화된 SQL을 매번 만들어 사용하는 경우에 비해 성능 면에서 조금은 손해를 감수해야 할 수 있음
- 오브젝트 관계에서도 필요 없는 연관된 객체 정보까지 다 조회해서 가져오게 되면 자원이 낭비됨
- 오브젝트 관계에서 필요한 정보만 가져오는 DAO를 만들더라도 연관 관계가 설정된 객체에 접근할 경우 NPE 발생의 여지가 있음

위와 같은 문제를 해결하기 위해 도메인 오브젝트를 사용하는 오브젝트 중심 아키텍처에서는 가능하다면 지연된 로딩(lazy loading) 기법을 지원하는 ORM과 같은 오브젝트 중심 데이터 액세스 기술을 사용하는 것을 권장한다.

도메인 오브젝트는 자바 오브젝트다.  
오브젝트는 원래 데이터를 저장하기 위해서만 사용하는 것이 아니라 내부의 정보를 이용하는 기능도 함께 가지고 있어야 한다.  
**클래스는 속성(attribute)과 행위(operation)의 조합**이다.

오브젝트 중심 아키텍처는 오브젝트의 활용 방법을 기준으로 다시 구분해 볼 수 있다.

### 빈약한 도메인 오브젝트 방식

도메인 오브젝트에 정보만 담겨 있고, 정보를 활용하는 아무런 기능도 가지고 있지 않다면 이는 온전한 오브젝트라고 보기 힘들다.  
그래서 이런 오브젝트를 빈약한(anemic) 오브젝트라고 부른다.

### 풍성한 도메인 오브젝트 방식

풍성한 도메인 오브젝트(rich domain object) 또는 영리한 도메인 오브젝트(smart domain object) 방식은 빈약한 도메인 오브젝트의 단점을 극복하고 도메인 오브젝트의 객체지향적인 특징을 잘 사용할 수 있도록 개선한 것이다.  
어떤 비즈니스 로직은 특정 도메인 오브젝트나 그 관련 오브젝트가 가진 정보와 깊은 관계가 있다.  
이런 로직을 서비스 계층의 코드가 아니라 도메인 오브젝트에 넣어주고, 서비스 계층의 비즈니스 로직에서 재사용하게 만드는 것이다.

서비스 계층은 도메인 오브젝트를 DB나 외부 리소스에서 가져오고 변경된 정보나 새로 등록된 정보를 DB에 반영하는 등의 작업과 함께 도메인 오브젝트가 가지고 있는 기능이 있다면 이를 활용해서 비즈니스 로직을 처리해야 한다.

### 도메인 계층 방식

도메인 계층의 역할과 비증을 극대화하다 보면 기존의 풍성한 도메인 오브젝트 방식으로는 만족할 수 없다.  
그래서 등장한 것이 바로 도메인 오브젝트가 기존 3계층과 같은 레벨로 격상되어 하나의 계층을 이루게 하는 도메인 계층 방식이다.  
도메인 오브젝트들이 하나의 독립적인 계층을 이뤄서 서비스 계층과 데이터 액세스 계층의 사이에 존재하게 하는 것이다.

도메인 오브젝트가 독립된 계층을 이뤘기 때문에 기존 방식과는 다른 두 가지 특징을 가지게 된다.

- 도메인에 종속적인 비즈니스 로직의 처리는 서비스 계층이 아니라 도메인 계층의 오브젝트 안에서 진행됨
- 도메인 오브젝트가 기존 데이터 액세스 계층이나 기반 계층의 기능을 직접 활용할 수 있음

### DTO와 리포트 쿼리

도메인 계층 방식의 경우 도메인 계층을 벗어난 정보를 DTO라 불리는 특정 계층에 종속되지 않는 정보 전달의 목적을 가진 단순 오브젝트에 담아 사용하기도 한다.  
그 외에도 DTO의 사용이 꼭 필요한 대표적인 예는 리포트 쿼리(report query)라고 불리는 DB 쿼리의 실행 결과를 담는 경우다.  
리포트 쿼리는 리포트를 출력하기 위해 생성하는 쿼리라는 의미인데, 보통 종합 분석 리포트처럼 여러 테이블에 걸쳐 존재하는 자료를 분석하고 그에 따른 분석/통계 결과를 생성하는 쿼리라는 의미다.  
이런 경우에는 DB 쿼리의 실행 결과를 담을 만한 적절한 도메인 오브젝트를 찾을 수 없다.  
그래서 이런 리포트 쿼리의 결과는 DTO라고 불리는 단순한 자바빈이나, 키와 쌍 값을 갖는 맵에 담아서 전달해야 한다.

## 9.3.4 스프링 애플리케이션을 위한 아키텍처 설계

### 계층형 아키텍처

3계층 구조는 스프링을 사용하는 엔터프라이즈 애플리케이션에서 가장 많이 사용되는 구조다.  
단, 3계층이라는 것은 논리적이고 개념적인 구분이지 꼭 오브젝트 단위로 끊어져서 만들어지는 게 아님을 염두에 둬야 한다.

### 상태 관리와 빈 스코프

아키텍처 설계에서 한 가지 더 신경 써야 할 사항은 상태 관리다.  
크게는 사용자 로그인 관리 세션 관리부터, 작게는 하나의 단위 작업이지만 여러 페이지에 걸쳐 진행되는 위저드 기능까지 애플리케이션은 하나의 HTTP 요청의 범위를 넘어서 유지해야 하는 상태 정보가 있다.  
엔터프라이즈 애플리케이션은 특정 사용자가 독점해서 배타적으로 사용되지 않는다.  
하나의 애플리케이션이 동시에 수많은 사용자의 요청을 처리하기 위해 매번 간단한 요청을 받아서 그 결과를 돌려주는 방식으로 동작한다.  
따라서 서버의 자원이 특정 사용자에게 일정하게 할당되지 않기 때문에 서버 기반의 애플리케이션은 원래 지속적으로 유지되는 상태를 갖지 않는다(stateless)는 특징이 있다.

상태를 저장, 유지하는 데 어떤 방식을 사용할지 결정하는 일은 매우 중요하다.  
**스프링은 기본적으로 상태가 유지되지 않는 빈과 오브젝트를 사용하는 것을 권장**한다.

상태는 클라이언트, 백엔드에 저장해 두거나 서블릿의 HTTP 세션 정도에 일시적으로 저장해 두는 것이 대부분이지만 경우에 따라서는 장기간 유지되며 중첩될 수 있는 상태를 다루는 고급 상태 관리 기법을 이용할 수도 있다.  
애플리케이션의 특징에 따라서 스프링을 이용해서 상태 유지(stateful) 스타일의 애플리케이션을 얼마든지 만들 수 있다.  
빈의 스코프를 잘 활용하면 스프링이 관리하는 빈이면서 사용자별로 또는 단위 작업별로 독립적으로 생성되고 유지되는 오브젝트를 만들어 상태를 저장하고 이를 DI를 통해 서비스 빈에서 사용하게 만들 수 있다.

### 서드파티 프레임워크, 라이브러리 적용

스프링은 거의 대부분의 자바 표준 기술과 함께 사용될 수 있다.  
표준 기술 외에도 많이 사용되는 오픈소스 프레임워크, 라이브러리나 상용 제품도 스프링과 함께 사용할 수 있다.  
스프링이 지원하는 기술이라는 것은 다음을 의미한다.

- 해당 기술을 스프링의 DI 패턴을 따라 사용 가능
  - 프레임워크나 라이브러리의 핵심 클래스를 빈으로 등록할 수 있게 지원해 주는 것
  - 코드를 이용해 초기화해야만 사용할 수 있는 기능을 빈을 등록하는 것만으로 바로 사용 가능
- 스프링의 서비스 추상화가 적용됨
  - 비슷한 기능을 제공하는 기술에 대한 일관된 접근 방법을 정의
  - 서드파티 프레임워크를 적용할 수 있을 뿐만 아니라 필요에 따라 호환 가능한 기술로 손쉽게 교체하여 사용 가능
- 스프링이 지지하는 프로그래밍 모델 적용
  - 대표적인 예시는 스프링의 데이터 액세스 기술에 대한 일관된 예외 적용
  - 기술에 독립적인 코드를 작성할 수 있도록 예외 추상화, 불필요하게 예외를 처리하는 코드를 피하도록 런타임 위주의 예외를 사용하는 등의 스프링 개발 철학 적용
- 템플릿/콜백 지원
  - 스프링은 JDBC, JMS, JCA 등 많은 기술을 지원하는 템플릿/콜백 제공
  - 대부분의 템플릿 클래스는 빈으로 등록해서 필요한 빈에서 DI 받아서 사용

스프링이 어떤 기술을 지원한다는 건, 결국 스프링이 지지하는 개발 철학과 프로그래밍 모델을 따르면서 해당 기술을 사용할 수 있다는 의미다.
