# 6.8 트랜잭션 지원 테스트

## 6.8.1 선언적 트랜잭션과 트랜잭션 전파 속성

AOP를 이용해 코드 외부에서 트랜잭션 기능을 부여해 주고 속성을 지정할 수 있게 하는 방법을 `선언적 트랜잭션(declarative transaction)`이라고 한다.  
반대로 TransactionTemplate이나 개별 데이터 기술의 트랜잭션 API를 사용해 직접 코드 안에서 사용하는 방법은 `프로그램에 의한 트랜잭션(programmatic transaction)`이라고 한다.  
스프링은 이 두 가지 방법을 모두 지원하고 있으며, 특별한 경우가 아니라면 선언적 방식의 트랜잭션을 사용하는 것이 바람직하다.

## 6.8.2 트랜잭션 동기화와 테스트

### 트랜잭션 매니저와 트랜잭션 동기화

트랜잭션 추상화 기술의 핵심은 트랜잭션 매니저와 트랜잭션 동기화다.  
PlatformTransactionManager 인터페이스를 구현한 트랜잭션 매니저를 통해 구체적인 트랜잭션 기술의 종류에 상관없이 일관된 트랜잭션 제어가 가능했다.  
또한 트랜잭션 동기화 기술이 있었기에 시작된 트랜잭션 정보를 저장소에 보관해 뒀다가 DAO에서 공유할 수 있었다.

### 롤백 테스트

`롤백 테스트`는 테스트 코드로 트랜잭션을 제어해서 적용할 수 있는 테스트 기법이다.  
롤백 테스트는 테스트 내의 모든 DB 작업을 하나의 트랜잭션 안에서 동작하게 하고 테스트가 끝나면 무조건 롤백해버리는 테스트를 말한다.

롤백 테스트는 DB 작업이 포함된 테스트가 수행돼도 DB에 영향을 주지 않기 때문에 장점이 많다.  
DB를 사용하는 코드를 테스트하는 건 여러 가지 이유로 작성하기 힘들다.  
복잡한 데이터를 바탕으로 동작하는 기능을 테스트하려면 테스트가 실행될 때의 DB 데이터와 상태가 매우 중요하다.

## 6.8.3 테스트를 위한 트랜잭션 애노테이션

스프링의 컨텍스트 테스트 프레임워크는 애너테이션을 이용해 테스트를 편리하게 만들 수 있는 여러 가지 기능을 추가하게 해준다.

### @Transactional

테스트 클래스 또는 메서드에 @Transactional 애너테이션을 부여해 주면 마치 타깃 클래스나 인터페이스에 적용된 것처럼 테스트 메서드에 트랜잭션 경계가 자동으로 설정된다.  
물론 테스트에서 사용하는 @Transactional은 AOP를 위한 것은 아니다.  
단지 컨텍스트 테스트 프레임워크에 의해 트랜잭션을 부여해 주는 용도로 쓰일 뿐이다.  
테스트에 적용된 @Transactional은 기본적으로 트랜잭션을 강제 롤백시키도록 설정되어 있다.

### @Rollback

테스트 메서드 안에서 진행되는 작업을 하나의 트랜잭션으로 묶고 싶기는 하지만 강제 롤백을 원하지 않는다면 `@Rollback` 애너테이션을 이용하면 된다.  
@Transactional은 기본적으로 테스트에서 사용할 용도로 만든 게 아니기 때문에 롤백 테스트에 관한 설정을 담을 수 없다.  
따라서 롤백 기능을 제어하려면 별도의 애너테이션을 사용해야 한다.

@Rollback은 메서드 레벨에만 적용할 수 있으며, 롤백 여부를 지정하는 값을 가지고 있다.  
@Rollback의 기본값은 true이며, 트랜잭션은 적용되지만 롤백을 원치 않는다면 @Rollback(false)라고 하면 된다.

### @TransactionConfiguration

테스트 클래스의 모든 메서드에 트랜잭션을 적용하면서 모든 트랜잭션이 롤백 되지 않고 커밋 되게 하려면 클래스 레벨에 부여할 수 있는 `@TransactionConfiguration` 애너테이션을 이용하여 롤백에 대한 공통 속성을 지정할 수 있다.

### NotTransactional과 Propagation.NEVER

트랜잭션이 필요 없는 메서드는 트랜잭션이 만들어지든 말든 상관없다면 그냥 놔둬도 되지만 필요하지도 않은 트랜잭션이 만들어지는 것이 꺼림칙하거나 트랜잭션이 적용되면 안 되는 경우에는 해당 메서드에만 테스트 메서드에 의한 트랜잭션이 시작되지 않도록 만들어 줄 수 있다.  
@NotTransactional을 테스트 메서드에 부여하면 클래스 레벨의 @Transactional 설정을 무시하고 트랜잭션을 시작하지 않은 채로 테스트를 진행한다.  
@NotTransactional은 스프링 3.0에서 제거 대상이 되었다.  
스프링의 개발자들은 **트랜잭션 테스트와 비 트랜잭션 테스트를 아예 클래스를 구분해서 만들도록 권장**한다.  
@NotTransactional 대신 @Transactional의 트랜잭션 전파 속성을 사용하는 방법도 있다.  
@Transactional의 propagation 속성을 NEVER 전파 속성으로 지정해 주면 @NotTransactional과 마찬가지로 트랜잭션이 시작되지 않는다.

### 효과적인 DB 테스트

테스트 내에서 트랜잭션을 제어할 수 있는 네 가지 애너테이션을 잘 활용하면 DB가 사용되는 통합 테스트를 만들 때 매우 편리하다.  
일반적으로 **의존, 협력 오브젝트를 사용하지 않고 고립된 상태에서 테스트를 진행하는 단위 테스트와, DB 같은 외부 리소스나 여러 계층의 클래스가 참여하는 통합 테스트는 아예 클래스를 구분**해서 따로 만드는 게 좋다.  
**DB가 사용되는 통합 테스트를 별도의 클래스로 만들어 둔다면 기본적으로 클래스 레벨에 @Transactional을 부여**해준다.  
DB가 사용되는 통합 테스트는 가능한 한 롤백 테스트로 만드는 게 좋다.  
애플리케이션의 모든 테스트를 한꺼번에 실행하는 빌드 스크립트 등에서 테스트에서 공통으로 이용할 수 있는 테스트 DB를 셋업 해주고, 각 테스트는 자신이 필요한 테스트 데이터를 보충해서 테스트를 진행하게 만든다.  
테스트가 기본적으로 롤백 테스트로 되어 있다면 테스트 사이에 서로 영향을 주지 않으므로 독립적이고 자동화된 테스트로 만들기가 매우 편하다.

**테스트는 어떤 경우에도 서로 의존하면 안 된다.**  
테스트가 진행되는 순서나 앞 테스트의 성공 여부에 따라서 다음 테스트의 결과가 달라지는 테스트를 만들면 안 된다.  
코드가 바뀌지 않는 한 어떤 순서로 진행되더라도 테스트는 일정한 결과를 내야 한다.
