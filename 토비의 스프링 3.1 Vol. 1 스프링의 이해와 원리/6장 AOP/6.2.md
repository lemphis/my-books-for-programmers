# 6.2 고립된 단위 테스트

**가장 편하고 좋은 테스트 방법은 가능한 한 작은 단위로 쪼개서 테스트하는 것**이다.  
작은 단위의 테스트가 좋은 이유는 테스트가 실패했을 때 그 원인을 찾기 쉽기 때문이다.

## 6.2.2 테스트 대상 오브젝트 고립시키기

테스트의 대상이 환경이나 외부 서버, 다른 클래스의 코드에 종속되고 영향을 받지 않도록 고립시킬 필요가 있다.  
테스트를 의존 대상으로부터 분리해서 고립시키는 방법은 테스트를 위한 대역을 사용하는 것이다.

### 테스트 수행 성능의 향상

고립된 테스트를 하면 테스트가 다른 의존 대상에 영향을 받는 경우를 대비해 복잡하게 준비할 필요가 없을 뿐만 아니라, 테스트 수행 성능도 크게 향상된다.

## 6.2.3 단위 테스트와 통합 테스트

단위 테스트의 단위는 정하기 나름이다.  
사용자 관리 기능 전체를 하나의 단위로 볼 수도 있고 하나의 클래스나 하나의 메서드를 단위로 볼 수도 있다.  
중요한 것은 **하나의 단위에 초점을 맞춘 테스트**라는 점이다.  
이 책에서는 **테스트 대상 클래스를 목 오브젝트 등의 테스트 대역을 이용해 의존 오브젝트나 외부의 리소스를 사용하지 않도록 고립시켜서 테스트**하는 것을 `단위 테스트`라고 하고, **성격이나 계층이 다른 두 개 이상의 오브젝트가 연동하도록 만들어 테스트하거나 외부의 DB나 파일, 서비스 등의 리소스가 참여하는 테스트**를 `통합 테스트`라고 하고 있다.

테스트는 코드가 작성되고 빠르게 진행되는 편이 좋다.  
테스트를 먼저 만들어두는 TDD는 코드를 만들자마자 바로 테스트가 가능하다는 장점이 있다.  
테스트를 코드를 작성한 후에 만드는 경우에도 가능한 한 빨리 작성하도록 해야 한다.  
코드를 만들고 나서 오랜 시간이 지난 뒤에 작성하는 테스트는 테스트 대상 코드에 대한 이해가 떨어지기 때문에 불완전하기 쉽고 작성하기도 번거롭다.

## 6.2.4 목 프레임워크

### Mockito 프레임워크

Mockito와 같은 목 프레임워크의 특징은 목 클래스를 일일이 준비해둘 필요가 없다는 점이다.  
간단히 메서드 호출만으로 다이내믹하게 특정 인터페이스를 구현한 테스트용 목 오브젝트를 만들 수 있다.  
Mockito 목 오브젝트는 다음의 네 단계를 거쳐서 사용하면 된다.  
두 번째와 네 번째는 각각 필요한 경우에만 사용할 수 있다.

1. 인터페이스를 통해 목 오브젝트를 만든다.
2. 목 오브젝트가 리턴할 값이 있으면 이를 지정해 준다. 메서드가 호출되면 예외를 강제로 던지게 만들 수도 있다.
3. 테스트 대상 오브젝트에 DI 해서 목 오브젝트가 테스트 중에 사용되도록 만든다.
4. 테스트 대상 오브젝트를 사용한 후에 목 오브젝트의 특정 메서드가 호출됐는지, 어떤 값을 가지고 몇 번 호출됐는지를 검증한다.
