# 6.3 다이내믹 프록시와 팩토리 빈

## 6.3.1 프록시와 프록시 패턴, 데코레이터 패턴

자신이 클라이언트가 사용하려고 하는 실제 대상인 것처럼 위장해서 클라이언트의 요청을 받아주는 것을 대리자, 대리인과 같은 역할을 한다고 해서 `프록시(proxy)`라고 부른다.  
프록시를 통해 최종적으로 요청을 위임받아 처리하는 실제 오브젝트를 `타깃(target)` 또는 `실체(real subject)`라고 한다.  
프록시의 특징은 타깃과 같은 인터페이스를 구현했다는 것과 프록시가 타깃을 제어할 수 있는 위치에 있다는 것이다.  
프록시는 사용 목적에 따라 두 가지로 구분할 수 있다.

- 클라이언트가 타깃에 접근하는 방법을 제어
- 타깃에 부가적인 기능을 부여

### 데코레이터 패턴

`데코레이터 패턴`은 **타깃에 부가적인 기능을 런타임 시 다이내믹하게 부여해 주기 위해 프록시를 사용하는 패턴**을 말한다.  
다이내믹하게 기능을 부가한다는 의미는 컴파일 시점, 즉 코드상에서는 어떤 방법과 순서로 프록시와 타깃이 연결되어 사용되는지 정해져 있지 않다는 뜻이다.  
데코레이터 패턴에서는 프록시가 꼭 한 개로 제한되지 않는다.  
이를 위해 데코레이터 패턴에서는 같은 인터페이스를 구현한 타깃과 여러 개의 프록시를 사용할 수 있다.  
프록시가 여러 개인 만큼 순서를 정해서 단계적으로 위임하는 구조를 만들면 된다.

### 프록시 패턴

일반적으로 사용하는 프록시라는 용어와 디자인 패턴에서 말하는 프록시 패턴은 구분할 필요가 있다.

- 프록시
  - 클라이언트와 사용 대상 사이에 대리 역할을 맡은 오브젝트를 두는 방법
- 프록시 패턴
  - 프록시를 사용하는 방법 중에서 타깃에 대한 접근 방법을 제어하려는 목적을 가진 경우

프록시 패턴의 프록시는 타깃의 기능을 확장하거나 추가하지 않는다.  
대신 클라이언트가 타깃에 접근하는 방식을 변경해 준다.  
타깃 오브젝트를 생성하기가 복잡하거나 당장 필요하지 않은 경우에는 꼭 필요한 시점까지 오브젝트를 생성하지 않는 편이 좋다.

프록시 패턴은 타깃의 기능 자체에는 관여하지 않으면서 접근하는 방법을 제어해 주는 프록시를 이용하는 것이다.  
구조적으로 보자면 프록시와 데코레이터는 유사하다.  
다만 프록시는 코드에서 자신이 만들거나 접근할 타깃 클래스 정보를 알고 있는 경우가 많다.  
생성을 지연하는 프록시라면 구체적인 생성 방법을 알아야 하기 때문에 타깃 클래스에 대한 직접적인 정보를 알아야 한다.

## 6.3.2 다이내믹 프록시

프록시는 기존 코드에 영향을 주지 않으면서 타깃의 기능을 확장하거나 접근 방법을 제어할 수 있는 유용한 방법이다.  
자바에는 java.lang.reflect 패키지 안에 프록시를 손쉽게 만들 수 있도록 지원해 주는 클래스들이 있다.  
기본적인 아이디어는 목 프레임워크와 비슷하다.  
일일이 프록시 클래스를 정의하지 않고도 몇 가지 API를 이용해 프록시처럼 동작하는 오브젝트를 다이내믹하게 생성하는 것이다.

### 리플렉션

다이내믹 프록시는 `리플렉션` 기능을 이용해서 프록시를 만들어준다.  
리플렉션은 **자바의 코드 자체를 추상화**해서 접근하도록 만든 것이다.  
자바의 모든 클래스는 그 클래스 자체의 구성 정보를 담은 Class 타입의 오브젝트를 하나씩 가지고 있다.  
'클래스 이름.class'라고 하거나 오브젝트의 getClass() 메서드를 호출하면 클래스 정보를 담은 Class 타입의 오브젝트를 가져올 수 있다.  
클래스 오브젝트를 이용하면 클래스 코드에 대한 메타 정보를 가져오거나 오브젝트를 조작할 수 있다.

### 다이내믹 프록시 적용

다이내믹 프록시는 프록시 팩토리에 의해 런타임 시 다이내믹하게 만들어지는 오브젝트다.  
다이내믹 프록시 오브젝트는 타깃의 인터페이스와 같은 타입으로 만들어진다.  
클라이언트는 다이내믹 프록시 오브젝트를 타깃 인터페이스를 통해 사용할 수 있다.  
이 덕분에 프록시를 만들 때 인터페이스를 모두 구현해가면서 클래스를 정의하는 수고를 덜 수 있다.  
프록시 팩토리에게 인터페이스 정보만 제공해 주면 해당 인터페이스를 구현한 클래스의 오브젝트를 자동으로 만들어주기 때문이다.

다이내믹 프록시가 인터페이스 구현 클래스의 오브젝트는 만들어주지만, 프록시로서 필요한 부가 기능 제공 코드는 직접 작성해야 한다.  
부가 기능은 프록시 오브젝트와 독립적으로 `InvocationHandler`를 구현한 오브젝트에 담는다.
InvocationHandler 인터페이스는 다음과 같은 메서드 한 개만 가진 간단한 인터페이스다.

```java
public Object invoke(Object proxy, Method method, Object[] args)
```

다이내믹 프록시 오브젝트는 클라이언트의 모든 요청을 리플렉션 정보로 변환해서 InvocationHandler 구현 오브젝트의 invoke() 메서드로 넘긴다.  
타깃 인터페이스의 모든 메서드 요청이 하나의 메서드로 집중되기 때문에 중복되는 기능을 효과적으로 제공할 수 있다.  
다이내믹 프록시의 생성은 Proxy 클래스의 newProxyInstance() 스태틱 팩토리 메서드를 이용하면 된다.

```java
Hello proxiedHello = (Hello) Proxy.newProxyInstance(
    getClass().getClassLoader(), // 동적으로 생성되는 다이내믹 프록시 클래스의 로딩에 사용할 클래스 로더
    new Class[]{Hello.class}, // 구현할 인터페이스
    new UppercaseHandler(new HelloTarget()) // 부가 기능과 위임 코드를 담은 InvocationHandler
);
```

## 6.3.4 다이내믹 프록시를 위한 팩토리 빈

### 팩토리 빈

스프링은 클래스 정보를 가지고 디폴트 생성자를 통해 오브젝트를 만드는 방법 외에도 빈을 만들 수 있는 여러 가지 방법을 제공한다.  
대표적으로 `팩토리 빈`을 이용한 빈 생성 방법을 들 수 있다.  
팩토리 빈이란 스프링을 대신해서 오브젝트의 생성 로직을 담당하도록 만들어진 특별한 빈을 말한다.

팩토리 빈을 만드는 방법에는 여러 가지가 있는데, 가장 간단한 방법은 스프링의 FactoryBean이라는 인터페이스를 구현하는 것이다.  
아래는 FactoryBean 인터페이스이다.

```java
package org.springframework.beans.factory;

public interface FactoryBean<T> {
    T getObject() throws Exception; // 빈 오브젝트를 생성해서 리턴
    Class<?> getObjectType(); // 생성되는 오브젝트의 타입 정보 리턴
    boolean isSingleton(); // getObjecT()가 리턴해주는 오브젝트의 싱글톤 오브젝트 여부 리턴
}
```

FactoryBean 인터페이스를 구현한 클래스를 스프링의 빈으로 등록하면 팩토리 빈으로 동작한다.  
스프링은 FactoryBean 인터페이스를 구현한 클래스가 빈의 클래스로 지정되면, 팩토리 빈 클래스의 오브젝트의 getObject() 메서드를 이용해 오브젝트를 가져오고, 이를 빈 오브젝트로 사용한다.

### 다이내믹 프록시를 만들어주는 팩토리 빈

Proxy의 newProxyInstance() 메서드를 통해서만 생성이 가능한 다이내믹 프록시 오브젝트는 일반적인 방법으로는 스프링의 빈으로 등록할 수 없다.  
대신 팩토리 빈을 사용하면 다이내믹 프록시 오브젝트를 스프링의 빈으로 만들어 줄 수가 있다.
