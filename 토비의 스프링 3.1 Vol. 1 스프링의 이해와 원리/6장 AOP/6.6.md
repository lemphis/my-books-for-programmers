# 6.6 트랜잭션 속성

## 6.6.1 트랜잭션 정의

트랜잭션이라고 모두 같은 방식으로 동작하는 것은 아니다.  
물론 트랜잭션의 기본 개념인 더 이상 쪼갤 수 없는 최소 단위의 작업이라는 개념은 항상 유효하다.  
따라서 트랜잭션 경계 안에서 진행된 작업은 commit()을 통해 모두 성공하든지 아니면 rollback()을 통해 모두 취소돼야 한다.  
그런데 이 밖에도 트랜잭션의 동작 방식을 제어할 수 있는 몇 가지 조건이 있다.

`DefaultTransactionDefinition`이 구현하고 있는 `TransactionDefinition` 인터페이스는 트랜잭션의 동작 방식에 영향을 줄 수 있는 네 가지 속성을 정의하고 있다.

1. `트랜잭션 전파 (transaction propagation)`
    - 트랜잭션 경계에서 이미 진행 중인 트랜잭션이 있을 때 또는 없을 때 어떻게 동작할 것인가를 결정하는 방식
    - 다음과 같은 트랜잭션 전파 속성을 부여할 수 있음
      - PROPAGATION_REQUIRED
        - 진행 중인 트랜잭션이 없으면 새로 시작하고, 이미 시작된 트랜잭션이 있으면 이에 참여
        - 가장 많이 사용되는 트랜잭션 전파 속성
      - PROPAGATION_REQUIRES_NEW
        - 항상 새로운 트랜잭션을 시작
        - 앞에서 시작된 트랜잭션이 있든 없든 상관없이 새로운 트랜잭션을 만들어서 독자적으로 동작하게 함
        - 독립적인 트랜잭션이 보장돼야 하는 코드에 적용
      - PROPAGATION_NOT_SUPPORTED
        - 트랜잭션 없이 동작하게 함 (진행 중인 트랜잭션이 있어도 무시)
        - 트랜잭션 경계 설정은 보통 AOP를 이용해 한 번에 많은 메서드에 동시에 적용하는 방법을 사용하기 때문에 특정 메서드의 트랜잭션 전파 속성만 PROPAGATION_NOT_SUPPORTED로 설정하여 트랜잭션 없이 동작하게 함
    - 트랜잭션 매니저를 통해 트랜잭션을 시작하려고 할 때 getTransaction()이라는 메서드를 사용하는 이유는 바로 트랜잭션 전파 속성이 있기 때문 (항상 새로 시작하는 게 아니기 때문에 beginTransaction() 등의 이름을 사용하지 않음)
2. `격리 수준 (isolation level)`
    - 모든 DB 트랜잭션은 격리 수준을 가지고 있어야 함
    - 적절하게 격리 수준을 조정해서 가능한 한 많은 트랜잭션을 동시에 진행시키면서도 문제가 발생하지 않게 하는 제어가 필요
    - 격리 수준은 기본적으로 DB에 설정되어 있지만 JDBC 드라이버나 DataSource 등에서 재설정 가능하며, 필요하다면 트랜잭션 단위로 격리 수준 조정 가능
    - DefaultTransactionDefinition에 설정된 격리 수준은 ISOLATION_DEFAULT (DataSource에 설정되어 있는 디폴트 격리 수준을 따름)
    - 기본적으로는 DB나 DataSource에 설정된 디폴트 격리 수준을 따르는 편이 좋지만, 특별한 작업을 수행하는 메서드의 경우에는 독자적인 격리 수준을 지정할 필요가 있음
3. `제한 시간 (timeout)`
    - 트랜잭션을 수행하는 제한 시간 설정 가능
    - DefaultTransactionDefinition의 기본 설정은 제한 시간이 없음
    - 트랜잭션을 직접 시작할 수 있는 PROPAGATION_REQUIRED, PROPAGATION_REQUIRES_NEW와 함께 사용해야만 의미가 있음
4. `읽기 전용 (readonly)`
    - 읽기 전용으로 설정해두면 트랜잭션 내에서 데이터를 조작하는 시도를 막을 수 있음
    - 데이터 액세스 기술에 따라서 성능이 향상될 수 있음

## 6.6.2 트랜잭션 인터셉터와 트랜잭션 속성

메서드별로 다른 트랜잭션 정의를 적용하려면 어드바이스의 기능을 확장해야 한다.

### TransactionInterceptor

스프링에는 편리하게 트랜잭션 경계 설정 어드바이스로 사용할 수 있도록 만들어진 `TransactionInterceptor`가 존재한다.  
TransactionInterceptor는 PlatformTransactionManager와 Properties 타입의 두 가지 프로퍼티를 가지고 있다.  
Properties 타입의 두 번째 프로퍼티 이름은 transactionAttributes로, 트랜잭션 속성을 정의한 프로퍼티다.  
트랜잭션 속성은 TransactionDefinition의 네 가지 기본 항목에 rollbackOn()이라는 메서드를 하나 더 가지고 있는 `TransactionAttribute` 인터페이스로 정의된다.

스프링이 제공하는 TransactionInterceptor에는 기본적으로 두 가지 종류의 예외 처리 방식이 있다.

- 런타임 예외
  - 트랜잭션 롤백
- 체크 예외
  - 예외 상황으로 해석하지 않고 일종의 비즈니스 로직에 따른, 의미가 있는 리턴 방식의 한 가지로 인식하여 트랜잭션 커밋

스프링의 기본적인 예외 처리 원칙에 따라 비즈니스적인 의미가 있는 예외 상황에만 체크 예외를 사용하고, 그 외의 모든 복구 불가능한 순수한 예외의 경우는 런타임 예외로 포장돼서 전달하는 방식을 따른다고 가정하기 때문이다.

그런데 TransactionInterceptor의 이러한 예외 처리 기본 원칙을 따르지 않는 경우가 있을 수 있다.  
그래서 TransactionAttribute는 rollbackOn()이라는 속성을 둬서 기본 원칙과 다른 예외 처리가 가능하게 해준다.  

## 6.6.3 포인트컷과 트랜잭션 속성의 적용 전략

다음은 포인트컷 표현식과 트랜잭션 속성을 정의할 때 따르면 좋은 몇 가지 전략이다.

- 트랜잭션 포인트컷 표현식은 타입 패턴이나 빈 이름을 이용한다
  - 일반적으로 트랜잭션을 적용할 타깃 클래스의 메서드는 모두 트랜잭션 적용 후보가 되는 것이 바람직함
  - 쓰기 작업이 없는 단순한 조회 작업만 하는 메서드에서 모두 트랜잭션을 적용하는 게 좋음
  - 따라서 **트랜잭션 용 포인트컷 표현식에는 메서드나 파리미터, 예외에 대한 패턴을 정의하지 않는 게 바람직함**
- 공통된 메서드 이름 규칙을 통해 최소한의 트랜잭션 어드바이스와 속성을 정의한다
  - 실제로 하나의 애플리케이션에서 사용할 트랜잭션 속성의 종류는 그다지 다양하지 않음
- **프록시 방식 AOP는 같은 타깃 오브젝트 내의 메서드를 호출할 때는 적용되지 않는다**
  - 프록시 방식의 AOP에서는 프록시를 통한 부가 기능의 적용은 클라이언트(인터페이스를 통해 타깃 오브젝트를 호출하는 다른 모든 오브젝트)로부터 호출이 일어날 때만 가능
  - 타깃 안에서의 호출에는 프록시가 적용되지 않는 문제를 해결할 수 있는 방법은 두 가지가 있음
    - 스프링 API를 이용해 프록시 오브젝트에 대한 레퍼런스를 가져온 뒤에 같은 오브젝트의 메서드 호출도 프록시를 이용하도록 강제하는 방법
    - AspectJ와 같은 타깃의 바이트코드를 직접 조작하는 방식의 AOP 방식 적용

## 6.6.4 트랜잭션 속성 적용

### 트랜잭션 경계 설정의 일원화

트랜잭션 경계 설정의 부가 기능을 여러 계층에서 중구난방으로 적용하는 건 좋지 않다.  
일반적으로 **특정 계층의 경계를 트랜잭션 경계와 일치**시키는 것이 바람직하다.  
비즈니스 로직을 담고 있는 서비스 계층 오브젝트의 메서드가 트랜잭션 경계를 부여하기에 가장 적절한 대상이다.

서비스 계층을 트랜잭션이 시작되고 종료되는 경계로 정했다면, 테스트와 같은 특별한 이유가 아니고는 다른 계층이나 모듈에서 DAO에 직접 접근하는 것은 차단해야 한다.
