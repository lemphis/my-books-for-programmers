# 6.7 애노테이션 트랜잭션 속성과 포인트컷

포인트컷 표현식과 트랜잭션 속성을 이용해 트랜잭션을 일괄적으로 적용하는 방식은 복잡한 트랜잭션 속성이 요구되지 않는 한 대부분의 상황에 잘 들어맞는다.  
그런데 가끔은 클래스나 메서드에 따라 제각각 속성이 다른, 세밀하게 튜닝된 트랜잭션 속성을 적용해야 하는 경우도 있다.  
이런 경우라면 메서드 이름 매턴을 이용해서 일괄적으로 트랜잭션 속성을 부여하는 방식은 적합하지 않다.  
기본 속성과 다른 경우가 있을 때마다 일일이 프인트컷과 어드바이스를 새로 추가해 줘야 하기 때문이다.  
이런 세밀한 트랜잭션 속성의 제어가 필요한 경우를 위해 스프링이 제공하는 다른 방법이 있다.  
설정 파일에서 패턴으로 분류 가능한 그룹을 만들어서 일괄적으로 속성을 부여하는 대신에 직접 타깃에 트랜잭션 속성 정보를 가진 애너테이션을 지정하는 방법이다.

## 6.7.1 트랜잭션 애노테이션

타깃에 부여할 수 있는 트랜잭션 애너테이션은 다음과 같이 정의되어 있다.  
스프링 3.0은 자바 5에서 등장한 애너테이션을 많이 사용한다.

### @Transactional

`@Transactional` 애너테이션의 타깃은 메서드와 타입이다. 따라서 메서드, 클래스, 인터페이스에 사용할 수 있다.  
@Transactional 애너테이션을 트랜잭션 속성 정보로 사용하도록 지정하면 **스프링은 @Transactional이 부여된 모든 오브젝트를 자동으로 타깃 오브젝트로 인식**한다.  
이때 사용되는 포인트컷은 `TransactionAttributeSourcePointcut`이다.  
TransactionAttributeSourcePointcut은 스스로 표현식과 같은 선정 기준을 가지고 있진 않지만 @Transactional이 타입 레벨이든 메서드 레벨이든 상관없이 부여된 빈 오브젝트를 모두 찾아서 포인트컷의 선정 결과로 돌려준다.  
@Transactional은 기본적으로 트랜잭션 속성을 정의하는 것이지만, 동시에 포인트컷의 자동 등록에도 사용된다.

### 트랜잭션 속성을 이용하는 포인트컷

TransactionInterceptor는 메서드 이름 패턴을 통해 부여되는 일괄적인 트랜잭션 속성 정보 대신 @Transactional 애너테이션의 엘리먼트에서 트랜잭션 속성을 가져오는 `AnnotationTransactionAttributeSource`를 사용한다.  
@Transactional은 메서드마다 다르게 설정할 수도 있으므로 매우 유연한 트랜잭션 속성 설정이 가능해진다.  
동시에 포인트컷도 @Transactional을 통한 트랜잭션 속성 정보를 참조하도록 만든다.  
@Transactional로 트랜잭션 속성이 부여된 오브젝트라면 포인트컷의 선정 대상이기도 하기 때문이다.

### 대체 정책

스프링은 @Transactional을 적용할 때 4단계의 대체(fallback) 정책을 이용하게 해 준다.  
메서드의 속성을 확인할 때 타깃 메서드, 타깃 클래스, 선언 메서드, 선언 타입(클래스, 인터페이스)의 순서에 따라서 @Transactional이 적용됐는지 차례로 확인하고, 가장 먼저 발견되는 속성 정보를 사용하게 하는 방법이다.

@Transactional을 사용하면 대체 정책을 잘 활용해서 애너테이션 자체는 최소한으로 사용하면서도 세밀한 제어가 가능하다.  
@Transactional은 **먼저 타입 레벨에 정의**되고 **공통 속성을 따르지 않는 메서드에 대해서만 메서드 레벨에 다시 @Transactional을 부여**해주는 식으로 사용해야 한다.
