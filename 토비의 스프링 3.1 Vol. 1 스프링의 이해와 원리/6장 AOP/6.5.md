# 6.5 스프링 AOP

## 6.5.1 자동 프록시 생성

### 빈 후처리기를 이용한 자동 프록시 생성기

스프링은 OCP의 가장 중요한 요소인 유연한 확장이라는 개념을 스프링 컨테이너 자신에게도 다양한 방법으로 적용하고 있다.  
스프링의 DI를 이용해 만들어지는 애플리케이션의 코드가 OCP에 충실할 수 있다면 스프링 스스로도 그런 가치를 따르는 게 마땅하다.  
그래서 **스프링은 컨테이너로서 제공하는 기능 중에서 변하지 않는 핵심적인 부분 외에는 대부분 확장할 수 있도록 확장 포인트를 제공**해준다.

그중에서 관심을 가질 만한 확장 포인트는 바로 `BeanPostProcessor` 인터페이스를 구현해서 만드는 빈 후처리기다.  
빈 후처리기는 이름 그대로 스프링 빈 오브젝트로 만들어지고 난 후에, 빈 오브젝트를 다시 가공할 수 있게 해준다.

스프링이 제공하는 빈 후처리기인 `DefaultAdvisorAutoProxyCreator`는 **어드바이저를 이용한 자동 프록시 생성기**다.  
빈 후처리기를 스프링에 적용하려면 빈 후처리기 자체를 빈으로 등록하면 된다.  
스프링은 빈 후처리기가 빈으로 등록되어 있으면 빈 오브젝트가 생성될 때마다 빈 후처리기에 보내서 후처리 작업을 요청한다.  
빈 후처리기는 빈 오브젝트의 프로퍼티를 강제로 수정할 수도 있고 별도의 초기화 작업을 수행할 수도 있다.  
따라서 스프링이 설정을 참고해서 만든 오브젝트가 아닌 다른 오브젝트를 빈으로 등록시키는 것이 가능하다.  
이를 잘 이용하면 스프링이 생성하는 빈 오브젝트의 일부를 프록시로 포장하고, 프록시를 빈으로 대신 등록할 수 있다.  
바로 이것이 자동 프록시 생성 빈 후처리기다.

아래는 빈 후처리기를 이용한 자동 프록시 생성 방법이다.

1. DefaultAdvisorAutoProxyCreator 빈 후처리기가 등록되어 있으면 스프링은 빈 오브젝트를 만들 때마다 후처리기에게 빈을 보냄
2. DefaultAdvisorAutoProxyCreator는 빈으로 등록된 모든 어드바이저 내의 포인트컷을 이용해 전달받은 빈이 프록시 적용 대상인지 확인
3. 프록시 적용 대상이면 내장된 프록시 생성기에게 현재 빈에 대한 프록시를 만들게 하고, 만들어진 프록시에 어드바이저를 연결해 줌
4. 빈 후처리기는 프록시가 생성되면 원래 컨테이너가 전달해 준 빈 오브젝트 대신 프록시 오브젝트를 컨테이너에게 돌려줌
5. 컨테이너는 최종적으로 빈 후처리기가 돌려준 오브젝트를 빈으로 등록하고 사용

적용할 빈을 선정하는 로직이 추가된 포인트컷이 담긴 어드바이저를 등록하고 빈 후처리기를 사용하면 일일이 ProxyFactoryBean 빈을 등록하지 않아도 타깃 오브젝트에 자동으로 프록시가 적용되게 할 수 있다.

### 확장된 포인트컷

포인트컷은 클래스 필터와 메서드 매처 두 가지를 돌려주는 메서드를 가지고 있다.  
실제 포인트컷의 선별 로직은 이 두 가지 타입의 오브젝트에 담겨 있다.

```java
public interface Pointcut {
    ClassFilter getClassFilter(); // 프록시를 적용할 클래스인지 확인해 준다.
    MethodMatcher getMethodMatcher(); // 어드바이스를 적용할 메서드인지 확인해 준다.
}
```

Pointcut 선정 기능을 모두 적용한다면 먼저 프록시를 적용할 클래스인지 판단하고 나서, 적용 대상 클래스인 경우에는 어드바이스를 적용할 메서드인지 확인하는 식으로 동작한다.

## 6.5.2 DefaultAdvisorAutoProxyCreator의 적용

### 어드바이저를 이용하는 자동 프록시 생성기 등록

적용할 자동 프록시 생성기인 DefaultAdvisorAutoProxyCreator는 등록된 빈 중에서 Advisor 인터페이스를 구현한 것을 모두 찾는다.  
그리고 생성되는 모든 빈에 대해 어드바이저의 포인트컷을 적용해 보면서 프록시 적용 대상을 선정한다.  
빈 클래스가 프록시 선정 대상이라면 프록시를 만들어 원래 빈 오브젝트와 바꿔치기한다.

## 6.5.3 포인트컷 표현식을 이용한 포인트컷

스프링은 아주 간단하고 효과적인 방법으로 클래스와 메서드를 선정하는 알고리즘을 작성할 수 있는 방법을 제공한다.  
정규식이나 JSP의 EL과 비슷한 일종의 표현식 언어를 사용해서 포인트컷을 작성할 수 있도록 하는 방법이다.  
이것을 `포인트컷 표현식(Pointcut Expression)`이라고 부른다.

### 포인트컷 표현식

포인트컷 표현식을 지원하는 포인트컷을 사용하려면 `AspectJExpressionPointcut` 클래스를 사용하면 된다.
AspectJExpressionPointcut은 클래스와 메서드 선정 알고리즘을 포인트컷 표현식을 이용해 한 번에 지정할 수 있게 해준다.  
포인트컷 표현식은 자바의 RegEx 클래스가 지원하는 정규식처럼 간단한 문자열로 복잡한 선정 조건을 쉽게 만들어낼 수 있는 강력한 표현식을 지원한다.  
스프링이 사용하는 포인트컷 표현식은 `AspectJ`라는 유명한 프레임워크에서 제공하는 것을 가져와 일부 문법을 확장해서 사용하는 것이다.  
그래서 이를 AspectJ 포인트컷 표현식이라고도 한다.

### 포인트컷 표현식 문법

AspectJ 포인트컷 표현식은 포인트컷 지시자를 이용해 작성한다.  
포인트컷 지시자 중에서 가장 대표적으로 사용되는 것은 execution()이다.  
execution() 지시자를 이용한 포인트컷 표현식의 문법 구조는 기본적으로 다음과 같다.  
[] 괄호는 옵션 항목이기 때문에 생략이 가능하다는 의미이며, |는 OR 조건이다.

`execution([접근제한자패턴] 타입패턴 [타입패턴.]이름패턴 (타입패턴 | "..", ...) [throws 예외패턴])`

메서드 풀 시그니처를 문자열로 비교하는 개념이라고 생각하면 간단하다.  
리플렉션으로 특정 클래스의 메서드의 풀 시그니처를 비교해 보면 이해하기 쉽다.

### 포인트컷 표현식을 이용하는 포인트컷 적용

AspectJ 포인트컷 표현식은 메서드를 선정하는 데 편리하게 쓸 수 있는 강력한 표현식 언어다.  
포인트컷 표현식은 메서드의 시그니처를 비교하는 방식인 execution() 외에도 몇 가지 표현식 스타일을 가지고 있다.  
대표적으로 스프링에서 사용될 때 빈의 이름으로 비교하는 bean()이 있다.  
bean(*Service)라고 쓰면 아이디가 Service로 끝나는 모든 빈을 선택한다.

또 특정 애노테이션이 타입, 메서도, 파라미터에 적용되어 있는 것을 보고 메서드를 선정하게 하는 포인트컷도 만들 수 있다.  
아래와 같이 쓰면 @Transactional이라는 애노테이션이 적용된 메서드를 선정하게 해준다.  
까다로운 명명 규칙을 사용하지 않아도 애노테이션만 부여해놓고, 포인트컷을 통해 자동으로 선정해서, 부가 기능을 제공하게 해주는 방식은 스프링 내에서도 애용되는 편리한 방법이다.

`@annotation(org.springframework.transaction.annotation.Transactional)`

## 6.5.4 AOP란 무엇인가?

### 트랜잭션 서비스 추상화

트랜잭션 추상화란 결국 인터페이스와 DI를 통해 무엇을 하는지는 남기고, 그것을 어떻게 하는지를 분리한 것이다.  
어떻게 할지는 더 이상 비즈니스 로직 코드에는 영향을 주지 않고 독립적으로 변경할 수 있게 됐다.

### 프록시와 데코레이터 패턴

투명한 부가 기능 부여를 가능하게 하는 데코레이터 패턴의 적용 덕에 비즈니스 로직을 담당하는 클래스도 자신을 사용하는 클라이언트와 DI 관계를 맺을 이유를 찾게 됐다.  
클라이언트가 인터페이스와 DI를 통해 접근하도록 설계하고, 데코레이터 패턴을 적용해서, 비즈니스 로직을 담은 클래스의 코드에는 전혀 영향을 주지 않으면서 부가 기능을 자유롭게 부여할 수 있는 구조를 만들었다.

### 다이내믹 프록시와 프록시 팩토리 빈

프록시 클래스 없이도 프록시 오브젝트를 런타임 시에 만들어주는 JDK 다이내믹 프록시 기술을 적용하면 프록시 클래스 코드 작성의 부담도 덜고, 부가 기능 부여 코드가 여기저기 중복돼서 나타나는 문제도 일부 해결할 수 있다.

JDK 다이내믹 프록시와 같은 프록시 기술을 추상화한 스프링의 프록시 팩토리 빈을 이용해서 다이내믹 프록시 생성 방법에 DI를 도입했다.  
내부적으로 템플릿/콜백 패턴을 활용하는 스프링의 프록시 팩토리 빈 덕분에 부가 기능을 담은 어드바이스와 부가 기능 선정 알고리즘을 담은 포인트컷은 프록시에서 분리될 수 있었고 여러 프록시에서 공유해서 사용할 수 있게 됐다.

### 자동 프록시 생성 방법과 포인트컷

부가 기능 적용 대상이 되는 빈마다 일일이 프록시 팩토리 빈을 설정해 줘야 한다는 부담을 해결하기 위해 스프링 컨테이너의 빈 생성 후처리 기법을 활용해 컨테이너 초기화 시점에서 자동으로 프록시를 만들어주는 방법을 도입했다.

### 부가 기능의 모듈화

DI, 데코레이터 패턴, 다이내믹 프록시, 오브젝트 생성 후처리, 자동 프록시 생성, 포인트컷과 같은 기법은 부가 기능을 독립적인 모듈로 만들기 위해 적용한 대표적인 방법이다.

### AOP: 애스펙트 지향 프로그래밍

전통적인 객체지향 기술의 설계 방법으로는 독립적인 모듈화가 불가능한 트랜잭션 경계 설정과 같은 부가 기능을 어떻게 모듈화할 것인가를 연구해온 사람들은, 이 부가 기능 모듈화 작업은 기존의 객체지향 설계 패러다임과는 구분되는 새로운 특성이 있다고 생각했다.  
그래서 이런 부가 기능 모듈을 객체지향 기술에서 주로 사용하는 오브젝트와는 다르게 특별한 이름으로 부르기 시작했다.  
그것이 바로 `애스펙트(Aspect)`다.  
애스펙트란 그 자체로 애플리케이션의 핵심 기능을 담고 있지는 않지만, **애플리케이션을 구성하는 중요한 한 가지 요소**이고, **핵심 기능에 부가되어 의미를 갖는 특별한 모듈**을 가리킨다.  
애스펙트는 부가될 기능을 정의한 코드인 어드바이스와, 어드바이스를 어디에 적용할지를 결정하는 포인트컷을 함께 가지고 있다.

**애플리케이션의 핵심적인 기능에서 부가적인 기능을 분리해서 애스펙트라는 독특한 모듈로 만들어서 설계하고 개발하는 방법**을 `애스펙트 지향 프로그래밍(Aspect Oriented Programming)` 또는 약자로 `AOP`라고 부른다.

AOP는 결국 애플리케이션을 다양한 측면에서 독립적으로 모델링하고, 설계하고, 개발할 수 있도록 만들어주는 것이다.

## 6.5.5 AOP 적용 기술

### 프록시를 이용한 AOP

스프링은 IoC/DI 컨테이너와 다이내믹 프록시, 데코레이터 패턴, 프록시 패턴, 자동 프록시 생성 기법, 빈 오브젝트의 후처리 조작 기법 등의 다양한 기술을 조합해 AOP를 지원하고 있다.  
그 중 가장 핵심은 프록시를 이용했다는 것이다.  
따라서 스프링 AOP는 자바의 기본 JDK와 스프링 컨테이너 외에는 특별한 기술이나 환경을 요구하지 않는다.  
스프링 컨테이너인 애플리케이션 컨텍스트는 특별한 환경이나 JVM 설정 등을 요구하지 않는다.  
서버 환경이라면 가장 기초적인 서블릿 컨테이너만으로도 충분하며, 원한다면 독립형 애플리케이션에서도 사용 가능하다.  
스프링 AOP 또한 마찬가지다.

스프링 AOP의 부가 기능을 담은 어드바이스가 적용되는 대상은 오브젝트의 메서드다.  
프록시 방식을 이용했기 때문에 메서드 호출 과정에 참여해서 부가 기능을 제공해 주게 되어 있다.  
독립적으로 개발한 부가 기능 모듈을 다양한 타깃 오브젝트의 메서드에 다이내믹하게 적용해 주기 위해 가장 중요한 역할을 맡고 있는 게 바로 프록시다.  
그래서 **스프링 AOP는 프록시 방식의 AOP**라고 할 수 있다.

### 바이트코드 생성과 조작을 통한 AOP

AOP 기술의 원조이자, 가장 강력한 AOP 프레임워크로 꼽히는 AspectJ는 프록시를 사용하지 않는 대표적인 AOP 기술이다.  
AspectJ는 프록시처럼 간접적인 방법이 아니라, 타깃 오브젝트를 뜯어고쳐서 부가 기능을 직접 넣어주는 직접적인 방법을 사용한다.  
부가 기능을 넣는다고 타깃 오브젝트의 소스코드를 수정할 수는 없으니, 컴파일된 타깃의 클래스 파일 자체를 수정하거나 클래스가 JVM에 로딩되는 시점을 가로채서 바이트코드를 조작하는 복잡한 방법을 사용한다.  
AspectJ가 프록시 같은 방법이 있음에도 컴파일된 클래스 파일 수정이나 바이트코드 조작과 같은 복잡한 방법을 사용하는 이유는 두 가지가 있다.

- 스프링과 같은 DI 컨테이너의 도움을 받아서 자동 프록시 생성 방식을 사용하지 않아도 AOP 적용 가능
- 프록시 방식보다 훨씬 강력하고 유연한 AOP 가능
  - 바이트코드를 직접 조작해서 AOP를 적용하면 오브젝트의 생성, 필드 값의 조회와 조작, 스태틱 초기화 등의 다양한 작업에 부가 기능을 부여해 줄 수 있음
  - private 메서드의 호출, 스태틱 메서드 호출이나 초기화, 필드 입출력 등에 부가 기능을 부여하는 등의 작업도 가능해짐

물론 대부분의 부가 기능은 프록시 방식을 사용해 메서드의 호출 시점에 부여하는 것으로도 충분하다.  
게다가 AspectJ 같은 고급 AOP 기술은 바이트코드 조작을 위해 JVM의 실행 옵션을 변경하거나, 별도의 바이트코드 컴파일러를 사용하거나, 특별한 클래스 로더를 사용하게 하는 등의 번거로운 작업이 필요하다.  
간혹 특별한 AOP 요구사항이 생겨서 스프링의 프록시 AOP 수준을 넘어서는 기능이 필요하다면, 그때는 AspectJ를 사용하면 된다.
