# 11.2 스토어드 프로그램의 문법

프로그래밍 언어에서 사용하는 함수와 같이 스토어드 프로그램도 헤더 부분과 본문 부분으로 나눌 수 있다.  

- 헤더 부분 (정의부)
  - 스토어드 프로그램의 이름과 입출력 값 명시
  - 보안이나 스토어드 프로그램의 작동 방식에 관련된 옵션 명시 가능
- 본문 부분 (바디, Body)
  - 스토어드 프로그램이 호출됐을 때 실행하는 내용 작성

## 11.2.2 스토어드 프로시저

스토어드 프로시저는 서로 데이터를 주고받아야 하는 여러 쿼리를 하나의 그룹으로 묶어서 독립적으로 실행하기 위해 사용하는 것이다.  
배치 프로그램에서 첫 번째 쿼리의 결과를 이용해 두 번째 쿼리를 실행해야 할 때를 대표적인 예로 볼 수 있다.  
이처럼 각 쿼리가 서로 연관되어 데이터를 주고받으면서 반복적으로 실행돼야 할 때 스토어드 프로시저를 사용하면 MySQL 서버와 클라이언트 간의 네트워크 전송 작업을 최소화하고 수행 시간을 줄일 수 있다.

### 스토어드 프로시저 생성 및 삭제

스토어드 프로시저는 CREATE PROCEDURE 명령으로 생성할 수 있다.  
스토어드 프로시저를 생성할 때는 다음 두 가지 사항에 주의해야 한다.

- 스토어드 프로시저는 기본 반환 값이 없음 (값을 반환하는 RETURN 명령 사용 불가)
- 스토어드 프로시저의 각 파라미터는 아래의 세 가지 특성 중 하나를 지님
  - IN 타입으로 정의된 파라미터
    - 입력 전용 파라미터
    - 외부에서 스토어드 프로그램을 호출할 때 프로시저에 값을 전달하는 용도로 사용, 값을 반환하는 용도로는 사용 불가
    - 스토어드 프로시저 내부에서는 읽기 전용
  - OUT 타입으로 정의된 파라미터
    - 출력 전용 파라미터
    - 스토어드 프로시저 외부에서 스토어드 프로시저를 호출할 때 어떤 값을 전달하는 용도로 사용 불가
    - 스토어드 프로시저의 실행이 완료되면 외부 호출자로 결괏값을 전달하는 용도로만 사용
  - INOUT 타입으로 정의된 파라미터
    - 입력 및 출력 용도로 모두 사용 가능

### 스토어드 프로시저 실행

스토어드 프로시저는 SELECT 쿼리에 사용될 수 없으며, 반드시 CALL 명령어로 실행해야 한다.  
MySQL 클라이언트에서 스토어드 프로시저를 실행할 때 IN 타입의 파라미터는 상숫값을 그대로 전달해도 무방하지만 OUT이나 INOUT 타입의 파라미터는 세션 변수를 이용해 값을 주고받아야 한다.

### 스토어드 프로시저의 커서 반환

스토어드 프로시저 내에서 커서를 오픈하지 않거나 SELECT 쿼리의 결과 셋을 페치(Fetch)하지 않으면 해당 쿼리의 결과 셋은 클라이언트로 바로 전송된다.  
스토어드 프로시저에서 쿼리의 결과 셋을 클라이언트로 전송하는 기능은 스토어드 프로시저의 디버깅 용도로 자주 사용된다.

## 11.2.3 스토어드 함수

스토어드 함수는 하나의 SQL 문장으로 작성이 불가능한 기능을 하나의 SQL 문장으로 구현해야 할 때 사용한다.  
SQL 문장과 관계없이 별도로 실행되는 기능이라면 굳이 스토어드 함수를 개발할 필요가 없다.  
독립적으로 실행돼도 된다면 스토어드 프로시저를 사용하는 것이 좋다.  
상대적으로 스토어드 함수는 스토어드 프로시저보다 제약 사항이 많기 때문이다.

### 스토어드 함수 생성 및 삭제

스토어드 함수는 CREATE FUNCTION 명령으로 생성할 수 있으며, 모든 입력 파라미터는 읽기 전용이라서 IN, OUT, INOUT과 같은 형식을 지정할 수 없다.  
그리고 스토어드 함수는 반드시 정의부에 RETURNS 키워드를 이용해 반환되는 값의 타입을 명시해야 한다.

스토어드 함수가 스토어드 프로시저와 크게 다른 부분은 다음 두 가지다.

- 함수 정의부에 RETURNS로 반환되는 값의 타입을 명시해야 함
- 함수 본문 마지막에 정의부에 지정된 타입과 동일한 타입의 값을 RETURN 명령으로 반환해야 함

스토어드 프로시저와는 달리 스토어드 프로그램의 본문(BEGIN ... END의 코드 블록)에서는 다음과 같은 사항을 사용하지 못한다.

- PREPARE와 EXECUTE 명령을 이용한 프리페어 스테이트먼트 사용 불가
- 명시적 또는 묵시적인 ROLLBACK/COMMIT을 유발하는 SQL 문장 사용 불가
- 재귀 호출(Recursive call) 사용 불가
- 결과 셋을 반환하는 SQL 문장 사용 불가

스토어드 함수에서 커서를 정의하면 반드시 오픈해야 하며, "SELECT .. INTO .."가 아닌 단순히 SELECT 쿼리만을 실행해서는 안 된다.

### 스토어드 함수 실행

스토어드 함수는 스토어드 프로시저와 달리 CALL 명령으로 실행할 수 없다.  
스토어드 함수는 SELECT 문장을 이용해 실행한다.

## 11.2.4 트리거

트리거는 테이블의 레코드가 저장되거나 변경될 때 미리 정의해 둔 작업을 자동으로 실행해 주는 스토어드 프로그램이다.  
MySQL의 트리거는 테이블 레코드가 INSERT나 UPDATE 또는 DELETE 될 때 시작되도록 설정할 수 있다.  
대표적으로 칼럼의 유효성 체크나 다른 테이블로의 복사나 백업을 위해 트리거를 자주 사용한다.

트리거가 생성되어 있는 테이블에 칼럼을 추가하거나 삭제할 때 실행 시간이 훨씬 더 오래 걸린다.  
테이블에 칼럼을 추가하거나 삭제하는 작업은 임시 테이블에 데이터를 복사하는 작업이 필요한데, 이때 매번 레코드마다 트리거를 한 번씩 실행해야 하기 때문이다.  
또한 AUTO_INCREMENT 속성의 칼럼이 포함된 테이블에 INSERT 하는 트리거는 마스터와 슬레이브의 데이터를 다르게 만들 가능성이 상당히 높으므로 특별히 주의해야 한다.

### 트리거 생성

트리거는 CREATE TRIGGER 명령으로 생성한다.  
스토어드 프로시저나 함수와는 달리 BEFORE나 AFTER 키워드로 트리거가 실행될 이벤트(사건)를 명시할 수 있다.

트리거의 BEGIN ... END의 코드 블록에서 사용하지 못하는 몇 가지 유형의 작업이 있다.

- PREPARE와 EXECUTE 명령을 이용한 프리페어 스테이트먼트 사용 불가
- 복재애 의해 슬레이브에 업데이트되는 데이터는 레코드 기반의 복제(Row based replication)에서는 슬레이브의 트리거를 기동시키지 않음
- 명시적 또는 묵시적인 ROLLBACK/COMMIT을 유발하는 SQL 문장 사용 불가
- RETURN 문장을 사용할 수 없으며, 트리거를 종료할 때는 LEAVE 명령 사용
- mysql DB에 존재하는 테이블에 대해서 트리거 생성 불가

### 트리거 실행

트리거는 스토어드 프로시저나 함수와 같이 작동을 확인하기 위해 명시적으로 실행해 볼 수 있는 방법이 없다.  
트리거가 등록된 테이블에 직접 레코드를 INSERT 하거나 UPDATE 또는 DELETE를 수행해서 작동을 확인해 볼 수밖에 없다.

## 11.2.5 이벤트

주어진 특정한 시간에 스토어드 프로그램을 실행할 수 있는 스케줄러 기능을 이벤트라고 한다.  
이벤트의 스케줄링만을 담당하는 스레드를 활성화해야 사용할 수 있다.  
이벤트 스케줄러 스레드를 기동하려면 MySQL 서버의 설정 파일에서 event_scheduler 시스템 변수를 ON이나 1로 설정해서 활성화해야 한다.

### 이벤트 생성

이벤트는 반복 실행 여부에 따라 크게 일회성 이벤트와 반복성 이벤트로 나눠볼 수 있다.

## 11.2.6 스토어드 프로그램 본문(Body) 작성

### BEGIN ... END 블록과 트랜잭션

스토어드 프로그램의 본문(Body)은 BEGIN으로 시작해서 END로 끝나며, 하나의 BEGIN ... END 블록은 또 다른 여러 개의 BEGIN ... END 블록을 중첩해서 포함할 수 있다.

BEGIN ... END 블록 내에서 주의해야 할 것은 트랜잭션 처리다.  
MySQL에서 트랜잭션을 시작하는 명령으로는 다음 두 가지가 있다.

- BEGIN
- START TRANSACTION

하지만 BEGIN ... END 블록 내에서 사용된 "BEGIN" 명령은 모두 트랜잭션의 시작이 아니라 BEGIN ... END 블록의 시작 키워드인 BEGIN으로 해석한다.  
결국 스토어드 프로그램의 본문에서 트랜잭션을 시작할 때는 BEGIN TRANSACTION 명령을 사용해야 한다.

### 변수

스토어드 프로그램의 BEGIN ... END 불록 사이에서 사용하는 변수는 사용자 변수와는 다르므로 혼동하지 않도록 주의해야 한다.  
여기서 언급하는 변수는 스토어드 트로그램의 BEGIN ... END 불록 내에서만 사용할 수 있다.  
로컬 변수는 DECLARE로 정의되고 반드시 타입이 함께 명시돼야 한다.  
로컬 변수에 값을 할당하는 방법은 SET 명령 또는 SELECT .. INTO .. 문장으로 가능하다.

스토어드 프로그램의 BEGIN ... END 불록에서는 스토어드 프로그램의 입력 파라미터와 DECLARE에 의해 생성된 로컬 변수 그리고 테이블의 칼럼명 모두 같은 이름을 가질 수 있다.  
세 가지 변수가 모두 똑같은 이름을 가질 때는 다음과 같은 우선순위를 지닌다.

1. DECLARE로 정의한 로컬 변수
2. 스토어드 프로그램의 입력 파라미터
3. 테이블의 칼럼

### 핸들러(HANDLER)와 컨디션(CONDITION)을 이용한 에러 핸들링

안정적이고 견고한 스토어드 프로그램을 작성하려면 반드시 핸들러를 이용해 예외를 처리해야 한다.

MySQL 매뉴얼에서도 "예외 핸들러"라고 표현하지 않는 이유는 핸들러는 예외 상황뿐 아니라 거의 모든 SQL 문장의 처리 상태에 대해 핸들러를 등록할 수 있기 때문이다.  
핸들러는 이미 정의한 컨디션 또는 사용자가 정의한 컨디션을 어떻게 처리(핸들링) 할지 정의하는 기능이다.  
컨디션은 SQL 문장의 처리 상태에 대해 별명을 붙이는 것과 같은 역할을 수행한다.

### 커서

스토어드 프로그램의 커서(CURSOR)는 JDBC 프로그램에서 자주 사용하는 ResultSet으로 반환되는 결과와 똑같은 것이다.  
하지만 스토어드 프로그램에서 사용하는 커서는 JDBC의 ResultSet에 비해 기능이 상당히 제약적이다.

- 스토어드 프로그램의 커서는 전방향(전진) 읽기만 가능
- 스토어드 프로그램에서는 커서의 칼럼을 바로 업데이트하는 것(Updatable ResultSet)이 불가능함

DBMS의 커서는 인센서티브(Insensitive)와 센서티브(Sensitive) 커서로 구분할 수 있다.

- 센서티브 커서
  - 일치하는 레코드에 대한 정보를 실제 레코드의 포인터만으로 유지하는 형태
  - 커서를 이용해 칼럼의 데이터를 변경하거나 삭제하는 것이 가능
  - 칼럼의 값이 변경돼서 커서를 생성한 SELECT 쿼리의 조건에 더는 일치하지 않거나 레코드가 삭제되면 커서에서도 즉시 반영
  - 별도로 임시 테이블로 레코드를 복사하지 않기 때문에 빠르고 다른 트랜잭션과의 충돌이 없음
- 인센서티브 커서
  - 일치하는 레코드를 별도의 임시 테이블로 복사해서 가지고 있는 형태
  - SELECT 쿼리에 부합되는 결과를 우선적으로 임시 테이블로 복사해야 하기 때문에 느림
  - 이미 임시 테이블로 복사된 데이터를 조회하는 것이라서 커서를 통해 칼럼의 값을 변경하거나 레코드를 삭제하는 작업 불가능
  - 다른 트랜잭션과의 충돌 발생하지 않음

센서티브 커서와 인센서티브 커서를 혼용해서 사용하는 방식을 어센서티브(Asensitive)라고 하는데, MySQL의 스토어드 프로그램에서 정의되는 커서는 어센서티브에 속한다.  
그래서 MySQL의 커서는 데이터가 임시 테이블로 복사될 수도 있고, 아닐 수도 있다.
