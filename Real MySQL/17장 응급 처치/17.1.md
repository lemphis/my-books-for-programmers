# 17.1 서버 과부하

실제 사용자의 수가 늘었거나 사용자의 행동 패턴이 바뀌었을 때 MySQL 서버의 부하가 높아질 수 있다.  
사용자의 행동 패턴이 바뀌는 것은 주로 애플리케이션의 업그레이드나 기능 개선으로 발생할 때가 많은데, 이는 쿼리나 실행 빈도를 적절히 튜닝한 후 애플리케이션을 배포하거나 릴리즈해서 충분히 예방할 수 있다.  
사용자의 수가 늘어나는 부분에 대비해서는 MySQL 서버가 평상시에는 대략 2~30%의 자원만 사용하도록 유지하기도 한다.  
하지만 너무 과다하게 서버를 투입하는 것은 비용적인 문제도 있으므로 사용자 수가 급작스럽게 증가할 때를 대비해 확장 가능한 구성으로 준비해 두는 편이 좋다.

어떤 원인이든지 MySQL 서버의 과부하 상태로 인해 어떤 쿼리도 처리하지 못하고 운영체제에 로그인할 수도 없는 상황이라면 장비 자체를 재시작하는 것이 좋다.  
운영체제에 로그인할 수 있다면 다음의 순서대로 운영체제나 MySQL 서버의 상태를 점검하자.  
물론 장애 상황에 대해 각 담당자와 의견을 교환하면서, MySQL 서버 내외부적으로 문제의 원인을 병행해서 찾는 것이 좋다.

## 17.1.1 운영체제와 유틸리티를 이용해 장비의 부하 확인

우선 서버에 접속한 뒤 운영체제의 유틸리티를 이용해 하드웨어 상태를 확인하는 것이 좋다.  
만약 서버에 MySQL 이외에 웹 서버와 같이 부하를 발생시킬 수 있는 소프트웨어가 함께 설치되어 있다면 과부하의 원인이 MySQL 서버인지 먼저 확인해야 한다.  
그리고 다음의 운영체제 명령을 이용해 CPU나 메모리, 디스크의 부하 정도를 확인해 보는 것이 좋다.

### 시스템의 전체적인 부하 확인

유닉스 계열의 운영체제에서는 `uptime` 명령으로 해당 서버의 CPU가 처리해야 하는 작업이 얼마나 쌓여 있는지 확인할 수 있는데, 이 결과로 대략 이 서버의 부하가 어느 정도인지 판단해 볼 수 있다.  
uptime 명령의 결과에서 "load average"는 최근 1분, 5분, 15분간의 CPU 작업 대기 큐에서 처리를 기다리는 프로세스의 평균 개수를 나타낸다.

현재 CPU가 어떤 작업에 주로 사용되고 있는지를 알아보려면 `vmstat`라는 유틸리티를 사용하면 된다.  
일반적으로 vmstst 명령은 초 단위의 시간 간격을 파라미터로 사용한다.  
1을 파라미터로 사용하면 vmstat 명령은 1초 동안 샘플링된 상태 값을 1초 단위로 출력한다.  
vmstat는 가상 메모리(Virtual Memory)의 상태를 보여주는 명령이지만, CPU나 프로세스 큐를 확인하는 용도로 더 많이 사용한다.

### 메모리 사용률

운영체제가 사용하는 물리적 메모리나 스왑 영역의 상태를 확인하려면 `free` 유틸리티를 사용하면 된다.  
free 명령은 "-m"과 "-t" 옵션을 함께 사용하는데, "-m" 옵션은 단위를 MB로 표시하게 하고 "-t" 옵션은 합계가 계산된 "Total" 라인을 표시한다.

### 디스크 사용량

`iostat` 명령은 장착된 디스크가 얼마나 사용되고 있는지 보여주는 유틸리티이며, 초 단위의 시간 간격을 파라미터로 사용한다.  
"-dx" 옵션은 확장된 형태의 보고서를 출력해 준다.

## 17.1.2 MySQL 서버의 에러 로그 확인

많은 사용자가 쉽게 간과하는 부분이지만, MySQL 서버에서 특별히 이상 징후나 에러가 발생하면 기본적으로 에러 로그에 기록하게 되어 있다.  
그래서 긴급한 상황일수록 에러 로그의 마지막 부분은 반드시 확인해 보는 것이 좋다.  
MySQL 에러 로그 파일은 별도로 파일명을 지정하지 않으면 MySQL 서버의 데이터 디렉터리에 "호스트명.err"이라는 파일로 기록된다.

## 17.1.3 MySQL 서버의 프로세스 리스트 확인

로그 파일을 확인했는데, 특별한 문제가 없다면 MySQL 서버에 로그인해서 상태를 확인한다.  
우선 MySQL 서버가 어떤 쿼리를 실행하고 있는지, 어떤 프로세스가 특히 오랜 시간 동안 실행되고 있는지 확인하는 것이 좋다.  
MySQL의 "show processlist"라는 명령은 다음과 같은 다양한 프로세스의 정보를 보여주므로 MySQL 서버에 로그인해서 가장 먼저 확인해 보는 것이 좋다.

- 현재 MySQL 서버에 존재하는 전체 프로세스 목록
- 각 프로세스가 어떤 작업(SQL)을 실행하고 있는지
- 각 작업의 현재 상태
- 각 작업의 실행 시간

"show processlist" 명령은 MySQL 서버에 접속된 클라이언트 수만큼의 레코드를 출력한다.  
이때 스레드라 함은 실제 클라이언트와 연결되어 있는 상태의 스레드만을 의미한다.  
즉 이 명령의 결과로 출력되는 내용에서 한 레코드는 하나의 프로세스를 의미함과 동시에 하나의 커넥션을 의미한다.  
"show processlist" 명령의 실행 결과에서 주의 깊게 봐야 할 항목은 Command 칼럼의 값과 Time 칼럼이며, 때로는 Info 칼럼에 출력되는 SQL도 간단히 문제의 원인을 찾는 데 많은 도움이 된다.

- Command가 "Sleep"이나 "Binlog Dump" 상태가 아닌 프로세스는 대부분 클라이언트의 요청으로 SQL을 실행하고 있음을 의미함
  - 이때 Time 칼럼의 값이 그 작업을 몇 초 동안 실행하고 있는지 알려줌
- 특정 쿼리를 실행하고 있는 프로세스가 오랜 시간 동안 실행되고 있다면 해당 프로세스의 State 칼럼 값 확인 필요
- State 칼럼은 그 작업이 어떤 상태인지를 보여 주는데, 주로 다음 두 가지가 자주 표시됨
  - Waiting ...
    - 다른 프로세스가 선점하고 있는 잠금을 기다리는 것을 의미함
    - 테이블 잠금을 기다릴 때만 해당되며, InnoDB의 레코드 잠금은 "update"라고만 표시됨
  - Copy to tmp table
    - 쿼리의 처리를 위해 내부적인 임시 테이블로 복사하는 작업이 실행되고 있음을 의미함
    - 테이블의 구조를 변경하는 ALTER TABLE 명령이 실행되거나 적절히 튜닝되지 못한 쿼리가 동시에 많이 실행될 때 발생함
- 많은 프로세스가 Command 칼럼의 값이 모두 비슷하고 Info 칼럼에 똑같은 SQL이 표시될 때가 많은데, 일반적으로 이런 현상은 최적화되지 못한 한두 개의 쿼리가 MySQL 서버의 부하를 유발할 때 자주 나타남
- 프로세스 목록에 다양한 값의 Command나 State가 출력된다면, 이는 단순히 한두 개의 쿼리가 부하를 유발하는 것이 아니라 여러 쿼리가 전체적으로 부하를 유발하고 있다고 볼 수 있음
  - MySQL 서버를 느리게 만드는 MySQL 서버상의 외부적인 요인이 있는지 확인해 보는 것이 좋음
- MySQL 서버의 부하가 전체적으로 높은 상태임에도 프로세스 목록에 Command 칼럼이 대부분 "Sleep" 상태이고 Time 칼럼의 값이 0이라면 이는 MySQL 서버가 빠르게 처리되는 쿼리를 아주 빈번히 처리하고 있음을 보여줌
  - 일반적으로 쿼리는 최적화되어 있지만 사용자의 수나 쿼리의 요청이 증가한 상황으로 해석해 볼 수 있음
  - MySQL 서버의 확장을 고려해 보는 것이 좋음

MySQL의 "show processlist" 명령은 MySQL 서버의 각 스레드가 현재 실행 중인 쿼리의 앞부분만 잘라서 Info 칼럼에 보여준다.  
만약 쿼리의 앞부분만으로는 명확히 어떤 SQL이 문제인지 파악하기 어렵다면 "show full processlist" 명령을 이용하면 된다.

쿼리의 실행 빈도는 MySQL 서버의 상태를 확인해 보는 가장 좋은 방법은 MySQL Enterprise Monitor와 같은 모니터링 도구를 이용하는 것이다.  
만약 모니터링 도구가 설치되어 있지 않다면 mysqladmin 명령으로 간단히 어느 정도의 쿼리나 단위 작업이 처리되는지 살펴볼 수 있다.

## 17.1.4 MySQL 서버의 최대 커넥션 설정 확인

외부의 광고나 뉴스 기사로 인해 사용자가 갑작스럽게 유입되면 커넥션을 더 생성하지 못하는 현상이 나타날 수 있다.  
이때는 평상시보다 많은 사용자가 웹 서버로 유입되고, 웹 서버는 많은 처리를 동시에 수행하기 위해 MySQL 서버의 커넥션을 더 많이 생성하는 과정에서 비정상적으로 커넥션을 요청하기 때문이다.  
이런 상황에서는 단순히 MySQL 서버를 재시작한다고 해서 문제가 해결되지는 않는다.

MySQL 서버에서 허용하는 최대 커넥션의 수를 터무니없이 크게 설정해 뒀다면 MySQL 서버는 동시에 너무 많은 요청을 받아 제대로 처리하지 못하는 현상이 발생할 수 있다.  
이럴 때는 최대 허용 커넥션의 수를 적절히 줄여서 가능한 범위 내에서 MySQL 서버가 최대한 요청을 처리할 수 있게 해주는 것이 좋다.  
만약 초기 최대 허용 커넥션 수가 너무 낮게 설정되어 있어 서버의 처리 용량에 여유가 있다면 최대 커넥션 수를 조금 더 늘려서 설정해 주는 것이 좋다.  
MySQL의 최대 커넥션 수는 max_connections 시스템 설정 변수로 조정할 수 있으며, 이 시스템 변수는 동적 변수이므로 MySQL 서버의 재시작 없이 즉시 적용할 수 있다.

## 17.1.5 MySQL 서버의 슬로우 쿼리 분석

지금까지 특별히 문제가 되는 부분을 찾지 못했다면 MySQL 서버의 슬로우 쿼리 로그를 확인해 보는 것이 좋다.  
MySQL 서버는 슬로우 쿼리 로그 설정을 통해 지정된 시간 이상 실행되는 느린 쿼리를 별도의 로그 파일로 기록할 수 있다.  
우선은 간략하게 파일을 직접 열어서 마지막 부분에서 자주 나타나는 쿼리 위주로 성능에 문제가 있는 쿼리인지 아닌지를 검토해 보는 것이 좋다.  
만약 이 부분에서 특별히 큰 문제가 될 만한 쿼리를 찾지 못했다면 mysqldumpslow 유틸리티를 이용해 슬로우 쿼리 로그의 통계를 확인할 수 있다.

## 17.1.6 쿼리의 실행 빈도 확인

MySQL Enterprise Monitor와 같은 모니터링 도구가 설치되어 있다면 MySQL 서버나 해당 장비에 로그인하지 않아도 여러 가지 수집된 내용을 확인할 수 있으므로 MySQL 서버에 로그인할 수 없을 때나 이미 지난 시점의 장애를 분석할 때 아주 유용하다.

MySQL 서버에서 실행되는 쿼리가 아무리 최적화되어 있어라도 처리할 수 있는 쿼리의 수에는 한계가 있다.  
만약 현재 처리되는 초당 쿼리의 수가 평상시에 비해 차이가 많이 난다면 사용량이 해당 장비의 처리 한계를 넘어선 것이 아닌지 확인해 보는 것이 좋다.  
그리고 이때는 슬레이브 MySQL 서버를 투입해 부하를 분산하거나, 최대 커넥션 수를 강제로 줄여 MySQL 서버가 응답 불능 상태가 되는 것을 막는 것이 좋다.

## 17.1.7 각 원인별 조치

지금까지 소개된 운영체제나 MySQL 서버의 유틸리티를 이용해 어느 정도는 서버 과부하의 원인을 찾을 수 있다.  
대부분의 MySQL 서버 과부하는 다음 세 가지 중 하나가 원인이며, 각 상황별 대처법은 다음과 같다.

- 튜닝되지 않은 쿼리
  - 일반적으로 서비스에서 사용되는 쿼리 중에서 상대적으로 부하가 높은 쪽에 속한 쿼리가 "show processlist" 항목에 많이 표시됨
  - "show processlist"에 많이 표시되는 쿼리를 집중적으로 찾아서 튜닝하면 됨
  - MySQL 서버의 슬로우 쿼리 로그를 mysqldumpslow 유틸리티로 분석해 높은 부하를 유발하는 쿼리 순서대로 튜닝하는 것이 좋음
- 잘못 사용된 쿼리
  - 애플리케이션의 버그나 사용자의 실수로 트랜잭션이 종료되지 않고 잠금이 계속 유지되면서 다른 서비스용 쿼리에 영향을 미치는 것을 의미함
  - 주로 이런 상황에서는 "show processlist" 결과를 보면 특정 테이블에 대해 INSERT, UPDATE, DELETE 쿼리가 "Waiting..." 또는 "updating..." 상태(State)로 표시될 때가 많음
  - 이렇게 하나의 잘못된 쿼리가 다른 서비스용 쿼리에 영향을 미친다면 잠금을 해제하지 않는 해당 트랜잭션을 찾아서 종료해주면 됨
- 실제 사용자가 많은 경우
  - 실제 사용자가 많아서 MySQL 서버가 과부하 상태로 된 것이라면 최대한 빨리 MySQL 서버를 더 투입해서 부하를 분산하는 것이 좋음
  - 만약 빠른 시간 내에 장비를 투입하기가 어렵다면 임시방편으로 바이너리 로그의 동기화 방식이나 InnoDB 트랜잭션 커밋의 동기화 방식을 조금 느슨한 형태로 변경해서 디스크의 병목을 줄여 서비스를 유지하는 것도 한 가지 방법임

위의 세 가지와도 전혀 관련이 없다면 MySQL 서버가 실행되고 있는 장비의 하드웨어 설정이 변경된 것이 없는지 또는 MySQL 서버를 사용하는 애플리케이션에서 뭔가 변화가 있는지 검토해 봐야 한다.
