# 12.2 SQL 문장별로 사용하는 잠금

## 12.2.1 SELECT 쿼리의 잠금

- SELECT ... FROM ...
  - 기본 형태의 SELECT 쿼리(잠금 옵션이나 INSERT와 같이 사용하지 않는)는 별도의 잠금을 사용하지 않음
  - 만약 읽어야 할 레코드가 다른 트랜잭션에 의해 변경되거나 삭제되는 중이라면 InnoDB에서 관리하고 있는 데이터의 변경 이력(언두 로그)을 이용해 레코드를 읽음
  - DDL 문장으로 테이블 구조가 변경되는 중에도 처리 가능
  - 트랜잭션 격리 수준이 SERIALIZABLE인 경우 LOCK IN SHARE MODE 옵션이 자동으로 덧붙여져서 실행되므로 읽기 잠금을 획득 후 읽기 실행
- SELECT ... FROM ... LOCK IN SHARE MODE
  - WHERE 절에 일치하는 레코드뿐 아니라 검색을 위해 접근한 모든 레코드에 대해 공유 넥스트 키 락(Shared next-key lock) 필요
  - 읽기 잠금을 걸어야 하는 레코드가 다른 트랜잭션에 의해 쓰기 잠금이 걸려 있다면 그 잠금이 해제될 때까지 기다려야 함
  - 다른 트랜잭션에 의해 읽기 잠금이 걸려있을 때는 읽기 잠금끼리는 상호 호환이 되므로 별도의 대기 없이 읽기 잠금 획득 가능
- SELECT ... FROM ... FOR UPDATE
  - WHERE 절에 일치하는 레코드뿐 아니라 검색을 위해 접근한 모든 레코드에 대해 배타적 넥스트 키 락(Exclusive next-key lock) 필요
  - 대상 레코드가 다른 트랜잭션에 의해 읽기 잠금이나 쓰기 잠금으로 사용되고 있다면 반드시 그 잠금이 해제될 때까지 대기해야 함
  - 스냅 샷을 이용한 읽기를 사용하지 못하기 때문에 일관된 읽기(Consistent read)가 무시됨

## 12.2.2 INSERT 쿼리의 잠금

INSERT 잠금은 기본적으로 배타적 레코드 잠금을 사용한다.  
만약 해당 테이블에 프라이머리 키나 유니크 키가 존재한다면 중복 체크를 위해 공유 레코드 잠금을 먼저 획득해야 한다.  
또한 MySQL의 INSERT 문장은 추가적으로 `인서트 인텐션 락(INSERT INTENTION LOCK)`이라는 조금 색다른 잠금 방식도 사용한다.

인서트 인텐션 락은 INSERT를 실행할 의도를 지닌 쿼리가 획득해야 하는 잠금으로, 모든 INSERT 쿼리는 인서트 인텐션 락을 획득한 후 INSERT를 실행한다.  
그리고 INSERT된 레코드에 대해서는 배타적 레코드 잠금을 자동으로 획득하게 된다.  
인서트 인텐션 락은 갭 락의 일종으로, 인서트 인텐션 락끼리는 서로 호환된다.  
즉 여러 트랜잭션이 동시에 인서트 인텐션 락을 획득할 수 있지만, 이미 다른 트랜잭션이 레코드나 갭 락을 걸고 있다면 인서트 인텐션 락을 걸기 위해 기다려야 한다.

INSERT를 실행하는 도중에 프라이머리 키나 유니크 키와 같이 중복이 허용되지 않는 칼럼에 대해 중복된 값이 이미 존재한다면 InnoDB는 반드시 기존의 중복된 레코드에 공유 레코드 락을 걸어야 한다.  
이는 중복 키 오류를 발생시킨 트랜잭션이 COMMIT이나 ROLLBACK 명령으로 종료될 때까지는 중복된 값을 가진 레코드가 다른 트랜잭션에 의해 변경되거나 삭제되면 안 되기 때문이다.

> 배타적 잠금은 내가 쓰기를 하는 동안 남들이 쓰지 못하게 하는 것이며,  
> 공유 잠금은 내가 읽는 동안 남들이 내가 읽고 있는 데이터를 변경하거나 삭제하지 못하게 만드는 장치다.

- INSERT INTO ... ON DUPLICATE KEY UPDATE ...
  - INSERT 하려는 레코드에 대해 중복된 키값이 이미 있는지 판단하기 위해 공유 잠금을 걸어야 함
  - 레코드가 존재한다면 배타적 잠금을 걸고 업데이트를 수행하며, 레코드가 존재하지 않는다면 일반적인 INSERT 문장과 같이 인서트 인텐션 락을 걸고 INSERT를 실행하며, 새로이 INSERT된 레코드에 대해서는 배타적 잠금 획득
- REPLACE ...
  - 중복된 키값이 이미 있는지 판단하기 위해 공유 잠금 필요
  - 중복된 레코드가 존재한다면 배타적 잠금을 걸고 레코드 삭제
- INSERT INTO tb_new ... SELECT ... FROM tb_old ...
  - tb_new 테이블에는 새로 INSERT 되는 레코드에 대해 배타적 레코드 락 설정
  - 레코드를 읽어오는 tb_old 테이블의 대상 레코드에는 공유 넥스트 키 락 설정 (tb_old 테이블에서 복사하는 원본 레코드가 변경되지 않도록 보장하기 위함)
- REPLACE INTO tb_new ... SELECT ... FROM tb_old ...
  - INSERT INTO ... SELECT ... 쿼리 문장과 마찬가지로 읽어 오는 테이블인 tb_old 테이블에는 공유 잠금이 걸리고 tb_new 테이블의 레코드는 배타적 레코드 락이 걸림

## 12.2.3 UPDATE 쿼리의 잠금

- UPDATE ... WHERE ...
  - 단순 업데이트 문장은 WHERE 조건에 일치하는 레코드를 찾기 위해 참조(스캔)한 모든 레코드에 배타적 넥스트 키 락 설정
  - 단순 레코드만 잠그지 않고 간격까지 잠그는 것은 팬텀 레코드의 발생을 막기 위한 것
  - 일반적으로 넥스트 키 락(레코드와 레코드 간의 갭을 동시에 잠그는 락)을 설정하는 이유는 이 처리가 수행되는 동안 다른 트랜잭션에 의해 처리 범위의 레코드가 영향을 받지 않게 하기 위함
- UPDATE tb_text1 a, tb_test2 b ON ... SET a.column = b.column ...
  - 최종적으로 UPDATE 되는 칼럼이 포함된 모든 테이블의 레코드에는 배타적 넥스트 키 락 설정, 그 밖의 단순 참조용으로만 사용되는 테이블에는 공유 넥스트 키 락 설정
  - 단순 참조 테이블에 공유 넥스트 키 락을 설정하는 이유는 팬텀 레코드의 발생을 방지하고 복제에서 마스터와 슬레이브의 데이터 동기화를 유지하기 위함
