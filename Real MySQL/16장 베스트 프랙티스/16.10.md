# 16.10 SQL 작성 표준

여기서 언급하려는 SQL 작성 표준은 실수나 결과의 오류를 만들어 내기 쉬운 형태의 쿼리를 작성하지 않게 하기 위한 내용이다.

## 16.10.1 조인 조건은 항상 ON 절에 기재

LEFT JOIN뿐 아니라 INNER JOIN에서도 가능하면 SQL 표준 조인 표기법으로 작성하고 반드시 조인 조건은 WHERE 절이 아니라 조인의 ON 절에 명시하는 습관을 들이는 것이 좋다.

## 16.10.2 테이블 별칭(Alias) 사용 및 칼럼 명에 테이블 별칭 포함

일반적으로 테이블이 하나만 사용되는 쿼리에서는 특정 칼럼이 어느 테이블의 칼럼인지 고민할 필요가 없지만, 여러 테이블이 조인되는 쿼리에서는 테이블의 별칭을 표기하지 않으면 구분하기가 쉽지 않다.  
가능하다면 **여러 테이블의 조인 여부와 상관없이 짧은 이름으로 테이블의 별칭(Alias)을 부여**하고, **모든 칼럼의 이름 앞에는 테이블의 별칭**을 붙이는 습관을 들이자.  
테이블의 별칭을 붙이는 작업 때문에 투자해야 할 시간은 그리 많지 않지만 붙이지 않았을 때 발생할 수 있는 불편함은 작지 않다.

## 16.10.3 서버 사이드 프리페어 스테이트먼트 사용

MySQL의 JDBC 드라이버는 두 가지 방식의 프리페어 스테이트먼트 기능을 제공한다.  
우리가 흔히 알고 있는 프리페어 스테이트먼트는 서버 사이드 프리페어 스테이트먼트에 해당하지만 서버 사이드 프리페어 스테이트먼트는 디폴트 옵션으로는 활성화되지 않는다.  
이에 대한 자세한 내용은 [13.1.2절의 프리페어 스테이트먼트의 종류](../13장%20프로그램%20연동/13.1.md#프리페어-스테이트먼트의-종류)에서 확인할 수 있다.

## 16.10.4 FULL GROUP BY 사용

MySQL의 GROUP BY는 FULL GROUP BY의 제약이 없다.  
오라클과 같은 DBMS에서는 쿼리에 GROUP BY를 사용하면 GROUP BY 절에 명시된 칼럼 이외의 모든 칼럼은 집합 함수를 통해서만 조회할 수 있는데,  이를 FULL GROUP BY라고 한다.  
FULL GROUP BY를 사용하지 않는 쿼리는 가독성을 떨어뜨리고 사용자가 실수를 유발할 가능성이 높으므로 가능하다면 **FULL GROUP BY 조건을 충족해서 쿼리를 작성**하는 습관을 들이자.

## 16.10.5 DELETE, UPDATE 쿼리에서 ORDER BY .. LIMIT .. 사용 자제

복제가 구축된 MySQL에서는 이러한 쿼리가 마스터와 슬레이브의 데이터를 달라지게 만들 수도 있다.  
그래서 MySQL 5.1부터는 이러한 쿼리가 마스터 MySQL에서 실행되면 경고 메시지를 출력하고, 때로는 MySQL 서버가 에러를 발생시키고 쿼리를 강제 종료할 때도 있다.  
경고 메시지는 쿼리가 실행될 때마다 MySQL 서버의 에러 로그에도 기록하는데, 이렇게 쌓인 에러 로그 때문에 디스크의 여유 공간이 남지 않아서 MySQL 서버가 아무것도 처리하지 못하는 상황이 발생할 수 있다.  
복제로 구축된 MySQL 서버에서 프라이머리 키로 정렬을 수행하더라도 여전히 경고 메시지를 기록하게 되어 있으므로 주의할 필요가 있다.

## 16.10.6 문자열 리터럴 표기는 홑따옴표만 사용

SQL 표준에서는 문자열 리터럴은 홑따옴표만 사용 가능하고, 쌍따옴표는 식별자(Identifier)에 사용하지만 MySQL에서는 문자열 리터럴 표기를 위해 쌍따옴표까지 사용할 수 있다.  
MySQL에서는 식별자를 표기할 때 역따옴표(`)를 사용하므로 문자열 리터럴로 표기에 홑따옴표와 쌍따옴표를 모두 사용할 수 있는 것이다.  
문자열 리터럴은 하나만 선정해서 사용하는 것이 좋은데, 가능하다면 **SQL 표준인 홑따옴표를 사용**할 것을 권장한다.

## 16.10.7 서브 쿼리는 조인으로 변경

쿼리를 작성할 때 많은 사람들의 공통적인 성향 중 하나가 뼈대 쿼리를 작성하고, 그 쿼리를 괄호로 묶어 서브 쿼리(주로 인라인 뷰)로 만들어 버린다는 것이다.  
쿼리를 작성할 때 FROM 절에 사용된 괄호의 개수만큼 MySQL 서버는 임시 테이블을 만들어 처리한다고 가정하면 될 정도로 서브 쿼리를 최적화하는 능력이 상당히 부족하다.  
임시 테이블은 가급적 사용하지 않는 편이 좋은데, 이를 위해서는 가장 먼저 **불필요한 FROM 절의 서브 쿼리를 제거**하는 것이 좋다.  
서브 쿼리로만 해결할 수밖에 없는 요건이 아니라면 반드시 **쿼리 개발 후 조인으로 다시 풀어서 작성**하는 습관을 들이는 것이 좋다.

## 16.10.8 UNION [ALL]은 사용 자제

MySQL의 UNION은 UNION DISTINCT든지 UNION ALL이든지 관계없이 항상 내부적으로 임시 테이블을 만들어 버퍼링한 다음에 사용자에게 결과를 반환한다.  
이 작업은 대량의 레코드를 처리하는 쿼리에서는 상당히 부담될 것이다.  
여러 집합의 중복된 레코드를 제거해야 하는 UNION(UNION DISTINCT)을 꼭 사용해야 한다면 특별한 우회 방법은 없다.  
하지만 중복 제거 없이 **UNION ALL로 가능한 쿼리는 두 개의 쿼리 문장으로 분리해서 쿼리를 실행**하는 편이 훨씬 더 효율적으로 처리될 수 있다.

## 16.10.9 스토어드 함수는 가능하면 DETERMINISTIC으로 정의

**스토어드 함수나 프로시저를 개발할 때는 반드시 DETERMINISTIC 키워드를 추가해서 그 함수나 프로시저가 입력 값이 똑같으면 출력값도 같다는 것을 옵티마이저에게 알려주는 것이 좋다.**  
그렇지 않으면 MySQL 옵티마이저는 칼럼과 비교 조건에 사용된 함수에 대해 접근하는 레코드의 수만큼 함수를 호출할 것이다.  
이는 단순히 함수의 호출 횟수만 많아지는 것이 아니라 비교 대상 칼럼의 인덱스를 사용하지 못하게 만들어 버리므로 상당한 성능 저하를 초래할 수 있다.

## 16.10.10 스토어드 프로그램에서는 예외 처리 코드를 작성

스토어드 프로시저나 함수는 의외로 디버깅이 쉽지 않다.  
예외 핸들링이 적절하지 않아서 스토어드 프로시저나 함수에 버그가 있어도 찾아내지 못하고 잘못된 데이터가 누적될 수도 있다.  
그래서 항상 **스토어드 프로그램을 작성할 때는 예외 핸들러 코드를 포함**시켜야 한다.

## 16.10.11 UPDATE, DELETE 쿼리와 적용 건수(Affected row counts) 체크

일반적으로 한 건의 레코드를 INSERT하는 쿼리는 성공하면 1, 실패하면 0으로 처리된 레코드 건수가 에러 여부에 따라 상당히 명확하다.  
하지만 UPDATE나 DELETE 문장은 쿼리의 성공적인 실행 여부를 업무적인 정상 처리 여부로 판단하기에는 부족할 수 있다.  
그래서 **프로그램을 작성할 때는 처리된 레코드 건수(Affected row count)를 반드시 검증하는 형태의 프로그램 로직**을 추가하는 습관을 들이자.

## 16.10.12 숫자 값은 반드시 숫자 타입의 칼럼으로 정의

문자열 타입에 숫자 값이 저장될 때, 문자열 타입에 저장된 숫자 값을 비교하기 위해 "char_type_column=2"와 같은 형태로 쿼리를 사용할 때가 많다.  
하지만 이 조건을 위해 MySQL 옵티마이저는 뒤의 숫자 값을 문자열로 바꿔서 비교하는 것이 아니라 앞의 문자열 칼럼을 모두 숫자로 변환해서 비교를 수행한다.  
그래서 칼럼에 인덱스가 있어도 이를 이용하지 못하고 풀 테이블 스캔을 수행하거나 인덱스 풀 스캔을 수행할 때가 많다.  
이런 실수를 막으려면 **순수한 숫자 값은 숫자 타입에 저장**하고 알파벳이나 숫자가 혼용되는 값은 CHAR나 VARCHAR 타입에 저장하자.
