# 16.9 MySQL 복제 구축

## 16.9.1 MySQL 복제의 형태

MySQL의 복제는 MS-SQL의 로그 쉽핑(Log shipping)이나 오라클의 데이터 가드(Data guard)보다 훨씬 유연하고 구성도 간단하다.  
MySQL의 복제는 "하나의 슬레이브 MySQL이 둘 이상의 마스터 MySQL을 가질 수 없다"라는 제약만 피한다면 어떤 형태로든 구성할 수 있다.  
다음은 가장 일반적으로 사용되는 복제의 형태다.

### 1:M 복제

하나의 마스터 MySQL 서버에 2개 이상의 슬레이브 MySQL을 연결시키는 복제 형태를 말한다.  
서비스용으로 가장 자주 사용되는 복제의 형태인데, 쿼리의 요청 수가 아주 많다면 마스터와 슬레이브 간에 적절히 분산해서 실행하는 것이 가능하다.  
또는 백업이나 통계, 배치 프로그램의 용도로 슬레이브를 사용하는 데 이 구조를 사용하기도 한다.

MySQL의 1:M 복제 구조에서 슬레이브 MySQL 서버의 대수가 많아지면 마스터 MySQL 서버가 복제를 위해 바이너리 로그를 슬레이브로 전달하는 작업이 느려질 수도 있다.  
만약 하나의 마스터 MySQL 서버에 연결된 슬레이브 MySQL 서버가 10대 이상으로 많다면 다음 절에서 살펴볼 1:M:M 구조의 복제를 고려해 보는 것이 좋다.

### 1:M:M 복제

1:M 복제 구조에서 슬레이브 MySQL 서버가 너무 많아서 마스터 MySQL 서버의 성능에 악영향이 예상된다면 1:M:M 구조의 복제를 고려해 볼 수 있다.  
MySQL 복제에서 마스터 MySQL은 슬레이브 MySQL이 요청할 때마다 계속 바이너리 로그를 읽어서 전달해야 한다.  
그래서 만약 하나의 마스터 MySQL에 연결된 슬레이브 MySQL의 개수가 많다면 바이너리 로그를 읽고 전달하는 작업 자체가 부하가 될 수도 있다.  
이럴 때는 마스터 MySQL 서버가 해야 할 바이너리 로그 배포 역할을 새로운 MySQL 서버로 넘길 수 있다.  
1차 복제 그룹은 그만큼 마스터 MySQL의 변경이 빠르게 적용될 것이므로 웹 서비스와 같은 OLTP 서비스 용도로 사용하고, 2차 복제 그룹은 통계나 배치, 그리고 백업 용도로 구분해서 사용할 수 있다.  
또한 이 복제 형태는 MySQL 서버를 업그레이드하거나 장비를 일괄 교체할 때도 많이 사용된다.  
기존 장비의 MySQL은 그대로 두고, 새로운 장비에 업그레이드한 MySQL을 설치하고 데이터를 새 장비로 옮기는 형태의 업그레이드는 이 복제 구조로 서비스 멈춤 없이 진행할 수도 있다.

## 16.9.2 확장(스케일 아웃)

MySQL의 복제는 읽기(SELECT)를 확장하는 방법이지 쓰기(INSERT, UPDATE, DELETE)를 확장하는 방법은 아니다.  
복제가 구축된 MySQL 서버라 하더라도 쓰기 작업은 마스터 MySQL로 집중될 수밖에 없으므로 최대한 읽기 작업을 슬레이브로 옮겨야 마스터 MySQL이 쓰기 작업에만 집중할 수 있다.  
그래야만 마스터 MySQL의 쓰기 작업의 병목으로 인한 서비스 장애를 최대한 줄일 수 있을 것이다.

## 16.9.3 가용성

하드웨어나 주변 상황의 문제로 마스터 MySQL 서버에 문제가 발생한다면 관련된 모든 서비스가 멈춰버리는 심각한 상황이 발생할 것이다.  
이때 슬레이브 MySQL 서버가 있다면 슬레이브 MySQL을 마스터로 승격(프로모션)시켜서 간단히 서비스를 복구하는 것이 가능하다.  
물론 슬레이브를 마스터로 승격시키기 위해 읽기 전용 모드를 해제하고 바이너리 로그를 활성화하는 등의 작업이 필요하지만 어느 정도 준비만 되어 있다면 2~3분 내외의 시간 안에 충분히 처리할 수 있다.  
또한 이렇게 마스터 MySQL 서버가 장애를 일으켰을 때 자동으로 슬레이브를 마스터로 승격하는 MMM(Multi-Master replication Manager)이라는 도구를 사용할 수 있다.  
하지만 데이터의 정합성이 생명인 DBMS에서 슬레이브를 자동으로 마스터로 변경해 버리는 것은 상당히 위험성이 있는 작업이므로 많은 주의와 테스트가 필요하다.

## 16.9.4 복제가 구축된 MySQL에서의 작업

MySQL의 복제에서 마스터 MySQL에서 사용자가 동시다발적(Concurrent, Parallel)으로 실행한 SQL이 슬레이브 MySQL에서는 하나의 스레드에 의해 직렬화(Serialization)되어 하나씩 순차적으로 실행된다.  
그래서 시간이 오래 걸리는 인덱스나 칼럼 추가와 같은 작업은 마스터 MySQL 서버에서만 실행하는 방법보다는 마스터와 슬레이브 각각의 MySQL 서버에서 별도로 실행해 주는 것이 좋다.  
이는 LOAD DATA INFILE ... 명령과 같이 파일로부터 대량의 레코드를 적재할 때도 마찬가지다.  
LOAD DATA INFILE ... 명령으로 적재하는 데이터 파일은 MySQL 복제 프로세스로 슬레이브에 복사해야 하므로 ALTER TABLE 명령보다 더 큰 복제 지연을 만들 수도 있다.

만약 슬레이브 MySQL 서버를 서비스용으로 사용하지 않는다면 크게 문제 되지 않는다.  
하지만 슬레이브 MySQL을 서비스로 사용하고 있다면 마스터 MySQL에서 인덱스를 생성하는 작업은 슬레이브 MySQL에서도 그만큼의 시간을 소모하게 되므로 인덱스를 생성하는 시간 동안은 복제가 멈춰 있는 것과 같은 효과를 낸다.  
이런 문제를 막기 위해 서비스 도중에 인덱스나 칼럼을 추가하는 작업은 복제에 참여하는 각각의 MySQL 서버에서 개별적으로 수행하는 것이 좋다.  
이때 주의해야 할 점은 마스터 MySQL에서 실행되는 인덱스나 칼럼 추가 명령이 슬레이브 MySQL로 넘어가지 않게 해야 한다는 것이다.  
이를 위해 sql_log_bin 세션 변수를 사용할 수 있는데, 간단한 사용법은 다음과 같다.

```sql
SET sql_log_bin = OFF;
ALTER TABLE employees ADD INDEX ix_lastname (last_name);
SET sql_log_bin = ON;
```

마스터 MySQL에서 "SET sql_log_bin = OFF;" 명령을 실행하면 sql_bin_log 세션 변수가 OFF인 동안 실행된 SQL은 슬레이브 MySQL로 복제되지 않는다.
