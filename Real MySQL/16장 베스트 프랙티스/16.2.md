# 16.2 페이징 쿼리

웹 프로그램에서는 테이블의 내용을 10건이나 20건 단위로 나눠서 화면에 보여주는 것이 일반적인데, 이를 위해서는 테이블의 레코드를 일정 단위로 잘라서 조회하는 기능이 필요하다.  
이를 페이징 쿼리라고 하며, MySQL 서버에서 페이징하려면 LIMIT 기능을 많이 사용한다.  
LIMIT가 사용된 페이징 쿼리가 인덱스를 이용할 수 있다면 크게 성능상의 문제없이 사용할 수 있다.

하지만 인덱스를 사용한다 하더라도 계속해서 다음 페이지로 넘어가면 조금씩 조회 쿼리가 느려질 수밖에 없는 구조다.  
단순히 LIMIT의 오프셋만 변경해 다음 페이지의 레코드를 조회하는 쿼리는 실제 필요하지 않은 레코드까지 모두 읽는 방식으로 처리된다.

## 16.2.1 지금까지의 방법

애플리케이션에서는 게시판 단위로 게시글의 목록을 조회하기 위해 다음과 같은 쿼리가 사용될 것이다.

```sql
SELECT *
FROM tb_article
WHERE board_id = 1
ORDER BY article_id DESC
LIMIT n, m;
```

여기서 "LIMIT n, m"에서 n 값은 게시판에서 첫 번째에서 두 번째 페이지로, 그리고 두 번째에서 세 번째 페이지로 이동할 때마다 페이지당 게시물 건수만큼 증가할 것이다.  
이때 MySQL은 실제 필요하지도 않은 n 건의 레코드를 읽어서 그냥 버리게 된다.  
WHERE 조건이 인덱스의 칼럼만으로 처리(커버링 인덱스) 될 수 있다면 그나마 다행이다.  
하지만 페이징 쿼리가 커버링 인덱스로 처리되지 못한다면 쓸모없는 n 건의 레코드에 대해 데이터 파일까지 읽어야 한다.

## 16.2.2 불필요한 접근을 제거하기 위한 페이징 쿼리

위와 같은 불필요한 작업을 제거하려면 제약 조건이 조금 있지만 해결 방법은 의외로 간단하다.  
**페이징 쿼리를 실행할 때 게시물 테이블의 프라이머리 키를 SELECT 쿼리의 조건절에 넣어주기만 하면 된다.**  
다음 페이징 쿼리에서는 현재 페이지의 가장 작은 프라이머리 키값보다 작은 프라이머리 키값만 쿼리하도록 변경하였다.

```sql
SELECT *
FROM tb_article
WHERE board_id = 1
    AND article_id < 165 -- 이전 페이지의 가장 마지막 article_id 값
ORDER BY article_id DESC
LIMIT 0, 20;
```

위의 페이징 쿼리에서처럼 "article_id < 165" 조건을 WHERE 절에 추가하면 MySQL 서버는 board_id가 1인 레코드에 대해 article_id가 가장 큰 레코드부터 것부터 165인 레코드까지는 전혀 읽지 않고 그냥 건너뛰게 된다.  
아주 간단한 내용이지만 자주 사용되는 쿼리라면 디스크의 읽기 부하를 상당량 줄일 수 있다.

페이징 쿼리의 검색 조건에서 LIKE나 IN 또는 BETWEEN과 같은 범위 조건이 사용될 때 주의해야 한다.  
ORDER BY 절에서 사용된 칼럼과 WHERE 절의 범위 조건에 사용된 칼럼이 서로 다른 쿼리는 인덱스를 어떻게 만들든 검색과 정렬 작업 모두 인덱스를 이용하는 것이 불가능하다.  
예를 들어, (board_id, article_status, article_id)로 인덱스가 만들어져 있는 상태에서 다음 쿼리에 article_id를 페이징 쿼리의 조건에 추가하면 잘못된 결과를 만들어 낼 수 있으므로 주의해야 한다.

```sql
SELECT *
FROM tb_article
WHERE board_id = 1
    AND article_status IN ('A', 'B')
ORDER BY article_id DESC
LIMIT 0, 20;
```
