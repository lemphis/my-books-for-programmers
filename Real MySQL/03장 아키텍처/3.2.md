# 3.2 InnoDB 스토리지 엔진 아키텍처

InnoDB는 MySQL에서 사용할 수 있는 스토리지 엔진 중에서 거의 유일하게 레코드 기반의 잠금을 제공하고 있기 때문에 높은 동시성 처리가 가능하고 안정적이며 성능이 뛰어나다.

## 3.2.1 InnoDB 스토리지 엔진의 특성

- 프라이머리 키에 의한 클러스터링
  - InnoDB의 모든 테이블은 기본적으로 프라이머리 키를 기준으로 클러스터링 되어 저장됨
  - 프라이머리 키값의 순서대로 디스크에 저장되며, 이로 인해 프라이머리 키에 의한 레인지 스캔이 상당히 빨리 처리됨
  - 쿼리의 실행 계획에서 프라이머리 키는 기본적으로 다른 보조 인덱스에 비해 비중이 높게 설정됨
- 잠금이 필요 없는 일관된 읽기 (Non-locking consistent read)
  - MVCC(Multi Version Concurrency Control)라는 기술을 이용해 락을 걸지 않고 읽기 작업 수행
- 자동 데드락 감지
  - InnoDB는 그래프 기반의 데드락 체크 방식을 사용하기 때문에 데드락이 발생함과 동시에 바로 감지됨
  - 데드락이 감지되면 관련 트랜잭션 중에서 ROLLBACK이 가장 용이한 트랜잭션(ROLLBACK 시 복구 작업이 가장 작은 트랜잭션)을 자동으로 강제 종료
- 자동화된 장애 복구
  - InnoDB는 손실이나 장애로부터 데이터를 보호하기 위한 여러 가지 메커니즘이 탑재되어 있음
  - MySQL 서버가 시작될 때, 완료되지 못한 트랜잭션이나 디스크에 일부만 기록된 데이터 페이지(Partial write) 등에 대한 일련의 복구 작업이 자동으로 진행됨

## 3.2.2 InnoDB 버퍼 풀

InnoDB 스토리지 엔진에서 가장 핵심적인 부분으로, **디스크의 데이터 파일이나 인덱스 정보를 메모리에 캐시해 두는 공간**이다.  
**쓰기 작업을 지연시켜 일괄 작업으로 처리할 수 있게 해주는 버퍼 역할**도 같이 한다.  
일반적인 애플리케이션에서는 INSERT, UPDATE, DELETE와 같이 데이터를 변경하는 쿼리는 데이터 파일의 이곳저곳에 위치한 레코드를 변경하기 때문에 랜덤한 디스크 작업을 발생시킨다.  
하지만 버퍼 풀이 이러한 변경된 데이터를 모아서 처리하게 되면 랜덤한 디스크 작업의 횟수를 줄일 수 있다.

InnoDB 버퍼 풀은 아직 디스크에 기록하지 않은 변경된 데이터를 가지고 있다(이러한 데이터를 가지고 있는 페이지를 더티 페이지(Dirty page)라고 한다).  
이러한 더티 페이지는 InnoDB에서 주기적으로 또는 어떤 조건이 되면 체크포인트 이벤트가 발생하는데, 이때 Write 스레드가 필요한 만큼의 더티 페이지만 디스크로 기록한다.

## 3.2.3 언두(Undo) 로그

`언두 영역`은 UPDATE, DELETE 같은 문장으로 **데이터를 변경했을 때 변경되기 전의 데이터를 보관하는 곳**이다.  
데이터를 변경하는 쿼리가 실행되면 트랜잭션을 커밋하지 않아도 실제 데이터 파일(데이터/인덱스 버퍼) 내용은 변경되고, 언두 영역에 변경 전의 값이 백업된다.  
이 상태에서 사용자가 커밋하게 되면 현재 상태가 그대로 유지되고, 롤백하게 되면 언두 영역의 백업된 데이터를 다시 데이터 파일로 복구한다.  
언두의 데이터는 크게 두 가지 용도로 사용된다.

- 트랜잭션의 롤백 대비
- 트랜잭션의 격리 수준을 유지하면서 높은 동시성 제공

## 3.2.4 인서트 버퍼 (Insert Buffer)

레코드가 INSERT 되거나 UPDATE 될 때는 데이터 파일을 변경하는 작업뿐 아니라 해당 테이블에 포함된 인덱스를 업데이트하는 작업도 필요하다.  
그런데 인덱스를 업데이트하는 작업은 랜덤하게 디스크를 읽는 작업이 필요하므로 테이블에 인덱스가 많다면 이 작업은 상당히 많은 자원을 소모하게 된다.  
그래서 InnoDB는 변경해야 할 인덱스 페이지가 버퍼 풀에 있으면 바로 업데이트를 수행하지만, 디스크로부터 읽어와서 업데이트해야 한다면 **즉시 업데이트하지 않고 임시 공간에 저장**해 두고 바로 사용자에게 결과를 반환하는 형태로 성능을 향상시킨다.  
이때 사용하는 임시 메모리 공간을 `인서트 버퍼(Insert Buffer)`라고 한다.  
사용자에게 결과를 전달하기 전에 반드시 중복 여부를 체크해야 하는 **유니크 인덱스는 인서트 버퍼를 사용할 수 없다**.  
인서트 버퍼에 임시로 저장되어 있는 인덱스 레코드 조각은 이후 **인서트 버퍼 머지 스레드**라는 백그라운드 스레드에 의해 병합된다.

## 3.2.5 리두(Redo) 로그 및 로그 버퍼

쿼리 문장으로 데이터를 변경하고 커밋하면 DBMS는 데이터의 ACID를 보장하기 위해 즉시 변경된 데이터의 내용을 데이터 파일로 기록해야 한다.  
하지만 이러한 데이터 파일의 변경 작업은 랜덤하게 디스크에 기록해야 하기 때문에 디스크에 부하가 가는 작업이며, 이러한 부하를 줄이기 위해 대부분의 DBMS에는 변경된 데이터를 버퍼링해 두기 위해 InnoDB 버퍼 풀과 같은 장치가 포함되어 있다.  
하지만 이 장치만으로는 ACID를 보장할 수 없는데, 이를 위해 변경된 내용을 순차적으로 디스크에 기록하는 `리두 로그` 파일을 가지고 있다.  
리두 로그 덕분에 상당한 성능 향상을 기대할 수 있지만, 사용량(특히 변경 작업)이 매우 많은 DBMS 서버의 경우에는 리두 로그의 기록 작업이 큰 문제가 된다.  
이러한 부분을 보완하기 위해 **최대한 ACID 속성을 보장하는 수준에서 버퍼링**하게 된다.  
이러한 리두 로그 버퍼링에 사용되는 공간이 로그 버퍼다.

## 3.2.6 MVCC (Multi Version Concurrency Control)

일반적으로 레코드 레벨의 트랜잭션을 지원하는 DBMS가 제공하는 기능이며, MVCC의 가장 큰 목적은 잠금을 사용하지 않는 일관된 읽기를 제공하는 데 있다.  
InnoDB는 언두 로그를 이용해 이 기능을 구현한다.

## 3.2.7 잠금 없는 일관된 읽기 (Non-locking consistent read)

InnoDB에서 격리 수준이 SERIALIZABLE이 아닌 수준인 경우 INSERT와 연결되지 않은 순수한 읽기(SELECT) 작업은 다른 트랜잭션의 변경 작업과 관계없이 항상 잠금을 대기하지 않고 실행된다.
