# 5.9 클러스터링 인덱스

인덱스에서 클러스터링은 값이 비슷한 것들을 묶어서 저장하는 형태로 구현되는데, 이는 주로 비슷한 값들을 동시에 조회하는 경우가 많다는 점에 착안된 것이다.  
MySQL에서 클러스터링 인덱스는 InnoDB와 TokuDB 스토리지 엔진에서만 지원한다.

## 5.9.1 클러스터링 인덱스

클러스터링 인덱스는 테이블의 프라이머리 키에 대해서만 적용되는 내용이다.  
즉 프라이머리 키값이 비슷한 레코드끼리 묶어서 저장하는 것을 클러스터링 인덱스라고 표현한다.  
여기서 중요한 것은 프라이머리 키값에 의해 레코드의 저장 위치가 결정된다는 것이다.  
또한 프라이머리 키값이 변경된다면 그 레코드의 물리적인 저장 위치가 바뀌어야 한다는 것을 의미하기도 한다.  
프라이머리 키값으로 클러스터링 된 테이블은 프라이머리 키값 자체에 대한 의존도가 상당히 크기 때문에 신중히 프라이머리 키를 결정해야 한다.

클러스터링 인덱스는 프라이머리 키값에 의해 레코드의 저장 위치가 결정되므로 사실 인덱스 알고리즘이라기보다 테이블 레코드의 저장 방식이라고 볼 수도 있다.  
일반적으로 InnoDB와 같이 항상 **클러스터링 인덱스로 저장되는 테이블은 프라이머리 키 기반의 검색이 매우 빠르며**, 대신 레코드의 저장이나 프라이머리 키 변경이 상대적으로 느릴 수밖에 없다.
B-Tree의 리프 노드와는 달리 클러스터링 인덱스의 리프 노드는 레코드의 모든 칼럼이 같이 저장되어 있다.  
즉 **클러스터링 테이블은 그 자체가 하나의 거대한 인덱스 구조**로 관리되는 것이다.

> MyISAM 테이블이나 기타 InnoDB를 제외한 테이블의 데이터 레코드는 프라이머리 키나 인덱스 키값이 변경된다고 해서 실제 데이터 레코드의 위치가 변경되지는 않는다.  
> 데이터 레코드가 INSERT 될 때 데이터 파일의 끝(또는 임의의 빈 공간)에 저장된다.  
> 이렇게 한 번 결정된 위치는 절대 바뀌지 않고, 레코드가 저장된 주소는 MySQL 내부적으로 레코드를 식별하는 아이디로 인식된다.

프라이머리 키가 없는 InnoDB 테이블은 InnoDB 스토리지 엔진이 다음의 우선순위대로 프라이머리 키를 대체할 칼럼을 선택한다.

1. 프라이머리 키가 있으면 기본적으로 프라이머리 키를 클러스터 키로 선택
2. NOT NULL 옵션의 유니크 인덱스(UNIQUE INDEX) 중에서 첫 번째 인덱스를 클러스터 키로 선택
3. 자동으로 유니크한 값을 가지도록 증가되는 칼럼을 내부적으로 추가한 후, 클러스터 키로 선택

프라이머리 키나 유니크 인덱스가 전혀 없는 InnoDB 테이블에서는 아무런 의미 없는 숫자 값으로 클러스터링이 되고 있는 것이며, 이것은 우리에게 아무런 혜택을 주지 않는다.

## 5.9.2 보조 인덱스(Secondary index)에 미치는 영향

MyISAM이나 MEMORY 테이블과 같은 클러스터링 되지 않은 테이블은 INSERT 될 때 한 번 저장된 공간에서 절대 이동하지 않는다.  
데이터 레코드가 저장된 주소는 내부적인 레코드 아이디(ROWID) 역할을 하며, 프라이머리 키나 보조 인덱스의 각 키는 그 주소(ROWID)를 이용해 실제 데이터 레코드를 찾아온다.  
그래서 MyISAM 테이블이나 MEMORY 테이블에서는 프라이머리 키와 보조 인덱스는 구조적으로 아무런 차이가 없다.  
만약 InnoDB 테이블에서 보조 인덱스가 실제 레코드가 저장된 주소를 가지고 있다면, 클러스터 키값이 변경될 때마다 데이터 레코드의 주소가 변경되고 그때마다 해당 테이블의 모든 인덱스에 저장된 주솟값을 변경해야 할 것이다.  
이런 번거로움을 방지하고자 InnoDB 테이블(클러스터 테이블)의 모든 보조 인덱스는 해당 레코드가 저장된 주소가 아니라 프라이머리 키값을 저장하도록 구현돼 있다.

## 5.9.3 클러스터 인덱스의 장점과 단점

- 장점
  - 프라이머리 키(클러스터 키)로 검색할 때 처리 성능이 매우 빠름 (특히 프라이머리 키를 범위 검색하는 경우 매우 빠름)
  - 테이블의 모든 보조 인덱스가 프라이머리 키를 가지고 있기 때문에 인덱스만으로 처리될 수 있는 경우가 많음 (커버링 인덱스)
- 단점
  - 테이블의 모든 보조 인덱스가 클러스터 키를 갖기 때문에 클러스터 키값의 크기가 클 경우 전체적으로 인덱스의 크기가 커짐
  - 보조 인덱스를 통해 검색할 때 프라이머리 키로 다시 한번 검색해야 하므로 처리 성능이 조금 느림
  - INSERT 할 때 프라이머리 키에 의해 레코드의 저장 위치가 결정되기 때문에 처리 성능이 느림
  - 프라이머리 키를 변경할 때 레코드를 DELETE 하고 INSERT 하는 작업이 필요하기 때문에 처리 성능이 느림

## 5.9.4 클러스터 테이블 사용 시 주의사항

MyISAM과 같이 클러스터링 되지 않은 테이블에 비해 InnoDB(클러스터 테이블)에서는 조금 더 주의해야 할 사항이 있다.

- 클러스터 인덱스 키의 크기
  - 클러스터 테이블의 경우, 모든 보조 인덱스가 프라이머리 키(클러스터 키) 값을 포함
  - 일반적으로 테이블에 보조 인덱스가 4~5개 정도 생성되는 것을 고려하면 보조 인덱스 크기는 급격히 증가
- 프라이머리 키는 AUTO-INCREMENT보다는 업무적인 칼럼으로 생성할 것 (가능한 경우)
  - 프라이머리 키로 검색하는 경우(특히 범위로 많은 레코드를 검색하는 경우) 클러스터 되지 않은 테이블에 비해 매우 빠르게 처리됨
  - MyISAM과 같이 클러스터 되지 않는 테이블에서는 프라이머리 키로 뭘 선택해도 성능의 차이는 별로 없을 수 있지만 InnoDB에서는 엄청난 차이를 만듦
- 프라이머리 키는 반드시 명시할 것
  - InnoDB 테이블에서 프라이머리 키를 정의하지 않으면 AUTO-INCREMENT와 같은 자동 증가 칼럼을 내부적으로 추가
  - InnoDB 테이블에 프라이머리 키를 정의하지 않은 경우와 AUTO-INCREMENT 칼럼을 생성하고 프라이머리 키로 설정하는 것이 결국 같음
- AUTO-INCREMENT 칼럼을 인조 식별자로 사용할 경우
  - 여러 개의 칼럼이 복합으로 프라이머리 키가 만들어지는 경우 프라이머리 키의 크기가 길어도 보조 인덱스가 필요치 않다면 그대로 프라이머리 키를 사용하는 것이 좋음
  - 만약 보조 인덱스도 필요하고 프라이머리 키의 크기도 길다면 AUTO-INCREMENT 칼럼을 추가하고, 이를 프라이머리 키로 설정하면 됨
  - 프라이머리 키를 대체하기 위해 인위적으로 추가된 프라이머리 키를 인조 식별자(Surrogate Key)라고 함
  - 로그 테이블과 같이 조회보다는 INSERT 위주의 테이블들은 AUTO-INCREMENT를 이용한 인조 식별자를 프라이머리 키로 설정하는 것이 성능 향상에 도움 됨
