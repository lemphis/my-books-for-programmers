# 7.3 MySQL 연산자와 내장 함수

여타 DBMS에서 사용되는 기본적인 연산자는 MySQL에서도 거의 비슷하게 사용되지만 MySQL에서만 사용되는 연산자나 표기법이 있다.  
가능하다면 SQL의 가독성을 높이기 위해 ANSI 표준 형태의 연산자를 사용하길 권장한다.

## 7.3.1 리터럴 표기법

### 문자열

SQL 표준에서 문자열은 항상 홑따옴표(')를 사용해서 표시한다.  
하지만 MySQL에서는 다음과 같이 쌍따옴표를 사용해서 문자열을 표기할 수도 있다.

```sql
SELECT * FROM departments WHERE dept_no='d001';
SELECT * FROM departments WHERE dept_no="d001";
```

또한, SQL 표준에서는 문자열 값에 홑따옴표가 포함돼 있을 때 홑따옴표를 두 번 연속해서 입력하면 된다.  
하지만 MySQL에서는 쌍따옴표와 홑따옴표를 포함하여 이러한 문제를 피해 가기도 한다.  
마찬가지로 문자열 값이 쌍따옴표를 가지고 있을 때는 쌍따옴표를 두 번 연속해서 사용할 수 있다.  
다음 예제는 MySQL에서 아무 문제 없이 사용할 수 있는 문자열 표기 방법이다.

```sql
SELECT * FROM departments WHERE dept_no='d''001'; -- SQL 표준
SELECT * FROM departments WHERE dept_no='d"001'; -- SQL 표준
SELECT * FROM departments WHERE dept_no="d'001"; -- MySQL만 지원
SELECT * FROM departments WHERE dept_no="d""001"; -- MySQL만 지원
```

### 숫자

숫자 값을 상수로 SQL에 사용할 때는 다른 DBMS와 마찬가지로 따옴표(' 또는 ") 없이 숫자 값을 입력하면 된다.  
문자열 형태로 따옴표를 사용하더라도 비교 대상이 숫자 값이거나 숫자 타입의 칼럼이면 MySQL 서버가 문자열 값을 숫자 값으로 자동 변환해 준다.  
**MySQL은 숫자 타입과 문자열 타입 간의 비교에서 숫자 타입을 우선시하므로 문자열 값을 숫자 값으로 변환한 후 비교를 수행**한다.

숫자 타입의 칼럼의 비교 대상으로 문자열을 넣으면 문자열 타입을 숫자로 변환하는데, 이때는 상숫값 하나만 변환하므로 성능과 관련된 문제가 발생하지 않는다.  
하지만 주어진 상숫값이 숫자 값인데 비교되는 칼럼이 문자열 칼럼일 경우, 문자열 칼럼을 숫자로 변환해서 비교한다.  
문자열 칼럼의 모든 문자열 값을 숫자로 변환해서 비교를 수행해야 하므로 문자열 칼럼에 인덱스가 있다 하더라도 이를 이용하지 못한다.  
문자열 칼럼에 알파벳과 같은 문자가 포함된 경우에는 숫자로 변환할 수 없으므로 쿼리 자체가 실패할 수도 있다.

### 날짜

다른 DBMS에서 날짜 타입을 비교하거나 INSERT 하려면 반드시 문자열을 DATE 타입으로 변환하는 코드가 필요하다.  
하지만 MySQL에서는 정해진 형태의 날짜 포맷으로 표기하면 MySQL 서버가 자동으로 DATE나 DATETIME 값으로 변환하기 때문에 복잡하게 STR_TO_DATE()와 같은 함수를 사용하지 않아도 된다.

### 불리언

BOOL이나 BOOLEAN이라는 타입이 있지만 사실 이것은 TINYINT 타입에 대한 동의어일 뿐이다.  
테이블의 칼럼을 BOOL로 생성한 뒤에 조회해 보면 칼럼의 타입이 TINYINT로 생성된다는 것을 알 수 있다.

## 7.3.2 MySQL 연산자

### 동등(Equal) 비교 (=, <=>)

동등 비교는 다른 DBMS에서와 마찬가지로 "=" 기호를 사용해 비교를 수행하면 된다.  
하지만 MySQL에서는 동등 비교를 위해 "<=>" 연산자도 제공한다.  
"<=>" 연산자는 "=" 연산자와 같으며, 부가적으로 NULL 값에 대한 비교까지 수행한다. (NULL을 하나의 값으로 인식하고 비교)  
MySQL에서는 이 연산자를 NULL-Safe 비교 연산자라고 한다.

### 부정(Not-Equal) 비교 (<>, !=)

"같지 않다" 비교를 위한 연산자는 "<>"를 일반적으로 많이 사용한다.  
이와 함께 C/C++의 연산자인 "!="도 Not-Equal 연산자로 사용할 수 있다.

### NOT 연산자 (!)

TRUE 또는 FALSE 연산의 결과를 반대로(부정) 만드는 연산자로 "NOT"을 사용한다.  
하지만 C/C++에서처럼 "!" 연산자를 같은 목적으로 사용할 수 있다.

### AND(&&) 와 OR(||) 연산자

일반적으로 DBMS에서는 불리언 표현식의 결과를 결합하기 위해 AND나 OR를 사용한다.  
MySQL에서는 AND와 OR뿐 아니라 "&&"와 "||"의 사용도 허용하고 있다.  
SQL의 가독성을 높이기 위해 다른 용도로 사용될 수 있는 "&&" 연산자와 "||" 연산자는 사용을 자제하는 것이 좋다.

### 나누기(/, DIV)와 나머지(%, MOD) 연산자

나누기 연산자는 일반적으로 알고 있는 "/" 연산자를 사용한다.  
나눈 몫의 정수 부분만 가져오려면 DIV 연산자를 사용하고, 나눈 결과 몫이 아닌 나머지를 가져오는 연산자로는 "%" 또는 MOD 연산자(함수)를 사용한다.

### REGEXP 연산자

문자열 값이 어떤 패턴을 만족하는지 확인하는 연산자이며, RLIKE는 REGEXP와 똑같은 비교를 수행하는 연산자다.  
REGEXP 연산자를 문자열 칼럼 비교에 사용할 때 REGEXP 조건의 비교는 인덱스 레인지 스캔을 사용할 수 없다.

### LIKE 연산자

REGEXP 연산자는 인덱스를 전혀 사용하지 못한다는 단점이 있지만, LIKE 연산자는 인덱스를 이용해 처리할 수도 있다.  
LIKE 연산자는 와일드카드 문자인 (%, _)가 검색어의 뒤쪽에 있다면 인덱스 레인지 스캔을 사용할 수 있지만 검색어의 앞쪽에 있다면 인덱스 레인지 스캔을 사용할 수 없다.

### BETWEEN 연산자

BETWEEN 연산자는 "크거나 같다"와 "작거나 같다"라는 두 개의 연산자를 하나로 합친 연산자다.  
BETWEEN과 연산자를 사용한 경우와 "크다" "작다" 비교를 사용한 경우의 성능 차이는 거의 없다.

### IN 연산자

IN은 여러 개의 값에 대해 동등 비교 연산을 수행하는 연산자다.  
여러 개의 값이 비교되지만 범위로 검색하는 것이 아니라 여러 번의 동등 비교로 실행하기 때문에 일반적으로 빠르게 처리된다.  

IN 연산자에 상숫값을 입력으로 전달하는 경우는 다른 DBMS 만큼 최적화해서 수행할 수 있다.  
하지만 IN 연산자의 입력이 상수가 아니라 서브 쿼리인 경우에는 상당히 느려질 수 있다.  
IN의 인자로 상수가 사용되면 이 상숫값이 쿼리의 입력 조건으로 사용되기 때문에 기대했던 대로 적절히 인덱스를 이용해 쿼리를 실행한다.  
하지만 IN의 입력으로 서브 쿼리를 사용할 때는 서브 쿼리가 먼저 실행되어 그 결괏값이 IN의 상숫값으로 전달되는 것이 아니라, 서브 쿼리의 외부가 먼저 실행되고 IN(subquery)는 체크 조건으로 사용된다.

## 7.3.3 MySQL 내장 함수

DBMS 종류에 관계없이 기본적인 기능의 내장 SQL 함수는 대부분 동일하게 제공된다.  
하지만 함수의 이름이나 사용법은 표준이 없으므로 DBMS 별로 거의 호환되지 않는다.  
MySQL의 함수는 기본적으로 제공하는 내장 함수와 사용자가 직접 작성해서 추가할 수 있는 사용자 정의 함수(UDF)로 구분된다.  

### NULL 값 비교 및 대체 (IFNULL, ISNULL)

IFNULL()은 칼럼이나 표현식의 값이 NULL 인지 비교하고, NULL이면 다른 값으로 대체하는 용도로 사용할 수 있는 함수다.  
ISNULL()은 인자로 전달된 표현식이나 칼럼의 값이 NULL 인지 아닌지 비교하는 함수다.

### 현재 시각 조회 (NOW, SYSDATE)

두 함수 모두 현재의 시간을 반환하는 함수로서 같은 기능을 수행하지만 작동 방식에서 큰 차이가 있다.  
하나의 SQL에서 NOW()는 같은 값을 가지지만 SYSDATE() 함수는 하나의 SQL 내에서도 호출되는 시점에 따라 값이 달라진다.  
SYSDATE() 함수는 이러한 특성 때문에 두 가지 큰 잠재적인 문제가 있다.

- SYSDATE() 함수가 사용된 SQL은 복제가 구축된 MySQL의 슬레이브에서 안정적으로 복제(Replication) 되지 못함
- SYSDATE() 함수와 비교되는 칼럼은 인덱스를 효율적으로 사용하지 못함

### 날짜와 시간의 포맷 (DATE_FORMAT, STR_TO_DATE)

DATETIME 타입의 칼럼이나 값을 원하는 형태의 문자열로 변환해야 할 때는 DATE_FORMAT() 함수를 이용하면 된다.  
날짜의 각 부분을 의미하는 지정자는 다음과 같다.

| 지정문자 | 내용                            |
| :------: | :------------------------------ |
|    %Y    | 4자리 년도                      |
|    %m    | 2자리 숫자 표시의 월(00 ~ 12)   |
|    %d    | 2자리 숫자 표시의 일자(00 ~ 31) |
|    %H    | 2자리 숫자 표시의 시(00 ~ 23)   |
|    %i    | 2자리 숫자 표시의 분(00 ~ 59)   |
|    %s    | 2자리 숫자 표시의 초(00 ~ 59)   |

SQL에서 표준 형태(년-월-일 시:분:초)로 입력된 문자열은 필요한 경우 자동적으로 DATETIME 타입으로 변환되어 처리된다.  
물론 이 밖에도 자동으로 DATETIME으로 자동 변환이 가능한 형태가 있다.  
하지만 그렇지 않은 형태는 MySQL 서버가 문자열에 사용된 날짜 타입의 포맷을 알 수 없으므로 명시적으로 STR_TO_DATE() 함수를 이용해 문자열을 DATETIME 타입으로 변환할 수 있다.

### 날짜와 시간의 연산 (DATE_ADD, DATE_SUB)

특정 날짜에서 연도나 월, 일 또는 시간 등을 더하거나 뺄 때는 DATE_ADD() 함수나 DATE_SUB() 함수를 사용한다.

### 타임스탬프 연산 (UNIX_TIMESTAMP, FROM_UNIXTIME)

UNIX_TIMESTAMP() 함수는 '1970-01-01 00:00:00'로부터 경과된 초의 수를 반환하는 함수다.  
FROM_UNIXTIME() 함수는 인자로 전달한 타임스탬프 값을 DATETIME 타입으로 변환하는 함수다.

### 문자열 처리 (RPAD, LPAD / RTRIM, LTRIM, TRIM)

RPAD(), LPAD() 함수는 문자열의 우측 또는 좌측에 문자를 덧붙여서 지정된 길이의 문자열로 만드는 함수다.
RTRIM(), LTRIM() 함수는 문자열의 우측 또는 좌측에 연속된 공백 문자(Space, NewLine, Tab)를 제거하는 함수다.  
TRIM() 함수는 LTRIM()과 RTRIM()을 동시에 수행하는 함수다.

### 문자열 결합 (CONCAT)

여러 개의 문자열을 연결해서 하나의 문자열로 반환하는 함수로, 인자의 개수는 제한이 없다.

### GROUP BY 문자열 결합 (GROUP_CONCAT)

COUNT(), MAX(), MIN(), AVG() 등과 같은 그룹 함수(Aggregate, 여러 레코드의 값을 병합해서 하나의 값을 만들어내는 함수) 중 하나다.  
주로 GROUP BY와 함께 사용하며, GROUP BY가 없는 SQL에서 사용하면 단 하나의 결괏값만 만들어낸다.

### 값의 비교와 대체 (CASE WHEN .. THEN .. END)

CASE WHEN은 프로그래밍 언어에서 제공하는 SWITCH 구문과 같은 역할을 한다.  
CASE로 시작하고 반드시 END로 끝나야 하며, WHEN .. THEN .. 은 필요한 만큼 반복해서 사용할 수 있다.

### 타입의 변환 (CAST, CONVERT)

프리페어 스테이트먼트를 제외하면 SQL은 텍스트(문자열) 기반으로 작동하기 때문에 SQL에 포함된 모든 입력 값은 문자열처럼 취급된다.  
이럴 때 만약 명시적으로 타입의 변환이 필요하다면 CAST() 함수를 이용하면 된다.  
CONVERT() 함수도 CAST() 함수와 거의 비슷하며, 단지 함수의 인자 사용 규칙만 조금 다르다.

### 이진 값과 16진수(Hex String) 문자열 변환 (HEX, UNHEX)

HEX() 함수는 이진 값을 사람이 읽을 수 있는 형태의 16진수 문자열로 변환하는 함수이고, UNHEX() 함수는 16진수의 문자열을 읽어서 이진 값으로 변환하는 함수다.

### 암호화 및 해시 함수 (MD5, SHA)

MD5와 SHA 모두 비대칭형 암호화 알고리즘인데, 인자로 전달된 문자열을 각각 지정된 비트 수의 해시 값을 만들어내는 함수다.  
SHA() 함수는 SHA-1 암호화 알고리즘을 사용하며, 결과로 160비트(20바이트) 해시 값을 반환한다.  
MD5() 함수는 메시지 다이제스트(Message Digest) 알고리즘을 사용해 128비트(16바이트) 해시 값을 반환한다.  
두 함수 모두 사용자의 비밀번호와 같은 암호화가 필요한 정보를 인코딩하는 데 사용된다.

### 처리 대기 (SLEEP)

SLEEP() 함수는 프로그래밍 언어나 셸 스크립트 언어에서 제공하는 "sleep" 기능을 수행한다.

### 벤치마크 (BENCHMARK)

BENCHMARK() 함수는 SLEEP() 함수와 같이 디버깅이나 간단한 함수의 성능 테스트용으로 아주 유용한 함수다.  
BENCHMARK() 함수의 반환값은 중요하지 않으며, 단지 지정한 횟수만큼 반복 실행하는 데 얼마나 시간이 소요됐는지가 중요할 뿐이다.
BENCHMARK() 함수로 얻은 쿼리나 함수의 성능은 그 자체로는 별로 의미가 없으며, 두 개의 동일 기능을 상대적으로 비교 분석하는 용도로 사용할 것을 권장한다.

### IP 주소 변환 (INET_ATON, INET_NTOA)

INET_ATON(), INET_NTOA() 함수를 이용해 IP 주소를 문자열이 아닌 부호 없는 정수 타입(UNSIGNED INTEGER)에 저장할 수 있게 제공한다.  

### MySQL 전용 암호화 (PASSWORD, OLD_PASSWORD)

PASSWORD(), OLD_PASSWORD() 함수는 MySQL DBMS 유저의 비밀번호를 관리하기 위한 함수이지, 일반 서비스의 고객 정보를 암호화하기 위한 용도로는 적합하지 않다.  
서비스용 고객 정보를 암호화할 때는 MD5() 함수나 SHA() 함수를 이용하는 것이 좋다.

### VALUES()

이 함수는 INSERT INTO ... ON DUPLICATE KEY UPDATE ... 형태의 SQL 문장에서만 사용할 수 있다.  
프라이머리 키나 유니크 키가 중복되는 경우에만 UPDATE를 수행하고, 그렇지 않으면 INSERT를 실행하는 문장이다.

### COUNT()

COUNT() 함수는 다들 잘 알고 있듯이 결과 레코드의 건수를 반환하는 함수다.
