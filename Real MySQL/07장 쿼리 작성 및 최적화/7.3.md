# 7.3 MySQL 연산자와 내장 함수

여타 DBMS에서 사용되는 기본적인 연산자는 MySQL에서도 거의 비슷하게 사용되지만 MySQL에서만 사용되는 연산자나 표기법이 있다.  
가능하다면 SQL의 가독성을 높이기 위해 ANSI 표준 형태의 연산자를 사용하길 권장한다.

## 7.3.1 리터럴 표기법

### 문자열

SQL 표준에서 문자열은 항상 홑따옴표(')를 사용해서 표시한다.  
하지만 MySQL에서는 다음과 같이 쌍따옴표를 사용해서 문자열을 표기할 수도 있다.

```sql
SELECT * FROM departments WHERE dept_no='d001';
SELECT * FROM departments WHERE dept_no="d001";
```

또한, SQL 표준에서는 문자열 값에 홑따옴표가 포함돼 있을 때 홑따옴표를 두 번 연속해서 입력하면 된다.  
하지만 MySQL에서는 쌍따옴표와 홑따옴표를 포함하여 이러한 문제를 피해 가기도 한다.  
마찬가지로 문자열 값이 쌍따옴표를 가지고 있을 때는 쌍따옴표를 두 번 연속해서 사용할 수 있다.  
다음 예제는 MySQL에서 아무 문제 없이 사용할 수 있는 문자열 표기 방법이다.

```sql
SELECT * FROM departments WHERE dept_no='d''001'; -- SQL 표준
SELECT * FROM departments WHERE dept_no='d"001'; -- SQL 표준
SELECT * FROM departments WHERE dept_no="d'001"; -- MySQL만 지원
SELECT * FROM departments WHERE dept_no="d""001"; -- MySQL만 지원
```

### 숫자

숫자 값을 상수로 SQL에 사용할 때는 다른 DBMS와 마찬가지로 따옴표(' 또는 ") 없이 숫자 값을 입력하면 된다.  
문자열 형태로 따옴표를 사용하더라도 비교 대상이 숫자 값이거나 숫자 타입의 칼럼이면 MySQL 서버가 문자열 값을 숫자 값으로 자동 변환해 준다.  
**MySQL은 숫자 타입과 문자열 타입 간의 비교에서 숫자 타입을 우선시하므로 문자열 값을 숫자 값으로 변환한 후 비교를 수행**한다.

숫자 타입의 칼럼의 비교 대상으로 문자열을 넣으면 문자열 타입을 숫자로 변환하는데, 이때는 상숫값 하나만 변환하므로 성능과 관련된 문제가 발생하지 않는다.  
하지만 주어진 상숫값이 숫자 값인데 비교되는 칼럼이 문자열 칼럼일 경우, 문자열 칼럼을 숫자로 변환해서 비교한다.  
문자열 칼럼의 모든 문자열 값을 숫자로 변환해서 비교를 수행해야 하므로 문자열 칼럼에 인덱스가 있다 하더라도 이를 이용하지 못한다.  
문자열 칼럼에 알파벳과 같은 문자가 포함된 경우에는 숫자로 변환할 수 없으므로 쿼리 자체가 실패할 수도 있다.

### 날짜

다른 DBMS에서 날짜 타입을 비교하거나 INSERT 하려면 반드시 문자열을 DATE 타입으로 변환하는 코드가 필요하다.  
하지만 MySQL에서는 정해진 형태의 날짜 포맷으로 표기하면 MySQL 서버가 자동으로 DATE나 DATETIME 값으로 변환하기 때문에 복잡하게 STR_TO_DATE()와 같은 함수를 사용하지 않아도 된다.

### 불리언

BOOL이나 BOOLEAN이라는 타입이 있지만 사실 이것은 TINYINT 타입에 대한 동의어일 뿐이다.  
테이블의 칼럼을 BOOL로 생성한 뒤에 조회해 보면 칼럼의 타입이 TINYINT로 생성된다는 것을 알 수 있다.

## 7.3.2 MySQL 연산자

### 동등(Equal) 비교 (=, <=>)

동등 비교는 다른 DBMS에서와 마찬가지로 "=" 기호를 사용해 비교를 수행하면 된다.  
하지만 MySQL에서는 동등 비교를 위해 "<=>" 연산자도 제공한다.  
"<=>" 연산자는 "=" 연산자와 같으며, 부가적으로 NULL 값에 대한 비교까지 수행한다. (NULL을 하나의 값으로 인식하고 비교)  
MySQL에서는 이 연산자를 NULL-Safe 비교 연산자라고 한다.

### 부정(Not-Equal) 비교(<>, !=)

"같지 않다" 비교를 위한 연산자는 "<>"를 일반적으로 많이 사용한다.  
이와 함께 C/C++의 연산자인 "!="도 Not-Equal 연산자로 사용할 수 있다.

### NOT 연산자 (!)

TRUE 또는 FALSE 연산의 결과를 반대로(부정) 만드는 연산자로 "NOT"을 사용한다.  
하지만 C/C++에서처럼 "!" 연산자를 같은 목적으로 사용할 수 있다.

### AND(&&) 와 OR(||) 연산자

일반적으로 DBMS에서는 불리언 표현식의 결과를 결합하기 위해 AND나 OR를 사용한다.  
MySQL에서는 AND와 OR뿐 아니라 "&&"와 "||"의 사용도 허용하고 있다.  
SQL의 가독성을 높이기 위해 다른 용도로 사용될 수 있는 "&&" 연산자와 "||" 연산자는 사용을 자제하는 것이 좋다.

### 나누기(/, DIV)와 나머지(%, MOD) 연산자

나누기 연산자는 일반적으로 알고 있는 "/" 연산자를 사용한다.  
나눈 몫의 정수 부분만 가져오려면 DIV 연산자를 사용하고, 나눈 결과 몫이 아닌 나머지를 가져오는 연산자로는 "%" 또는 MOD 연산자(함수)를 사용한다.

### REGEXP 연산자

문자열 값이 어떤 패턴을 만족하는지 확인하는 연산자이며, RLIKE는 REGEXP와 똑같은 비교를 수행하는 연산자다.  
REGEXP 연산자를 문자열 칼럼 비교에 사용할 때 REGEXP 조건의 비교는 인덱스 레인지 스캔을 사용할 수 없다.

### LIKE 연산자

REGEXP 연산자는 인덱스를 전혀 사용하지 못한다는 단점이 있지만, LIKE 연산자는 인덱스를 이용해 처리할 수도 있다.  
LIKE 연산자는 와일드카드 문자인 (%, _)가 검색어의 뒤쪽에 있다면 인덱스 레인지 스캔을 사용할 수 있지만 검색어의 앞쪽에 있다면 인덱스 레인지 스캔을 사용할 수 없다.

### BETWEEN 연산자

BETWEEN 연산자는 "크거나 같다"와 "작거나 같다"라는 두 개의 연산자를 하나로 합친 연산자다.  
BETWEEN과 연산자를 사용한 경우와 "크다" "작다" 비교를 사용한 경우의 성능 차이는 거의 없다.

### IN 연산자

IN은 여러 개의 값에 대해 동등 비교 연산을 수행하는 연산자다.  
여러 개의 값이 비교되지만 범위로 검색하는 것이 아니라 여러 번의 동등 비교로 실행하기 때문에 일반적으로 빠르게 처리된다.  

IN 연산자에 상숫값을 입력으로 전달하는 경우는 다른 DBMS 만큼 최적화해서 수행할 수 있다.  
하지만 IN 연산자의 입력이 상수가 아니라 서브 쿼리인 경우에는 상당히 느려질 수 있다.  
IN의 인자로 상수가 사용되면 이 상숫값이 쿼리의 입력 조건으로 사용되기 때문에 기대했던 대로 적절히 인덱스를 이용해 쿼리를 실행한다.  
하지만 IN의 입력으로 서브 쿼리를 사용할 때는 서브 쿼리가 먼저 실행되어 그 결괏값이 IN의 상숫값으로 전달되는 것이 아니라, 서브 쿼리의 외부가 먼저 실행되고 IN(subquery)는 체크 조건으로 사용된다.
