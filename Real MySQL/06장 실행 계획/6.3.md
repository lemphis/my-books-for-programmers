# 6.3 MySQL의 주요 처리 방식

풀 테이블 스캔을 제외한 나머지는 모두 스토리지 엔진이 아니라 MySQL 엔진에서 처리되는 내용이다.  
또한, MySQL 엔진에서 부가적으로 처리하는 작업은 대부분 성능에 미치는 영향력이 크다. (쿼리 성능 저하)

## 6.3.1 풀 테이블 스캔

인덱스를 처리하지 않고 테이블의 데이터를 처음부터 끝까지 읽어서 요청된 작업을 처리하는 작업이다.  
MySQL 옵티마이저는 다음과 같은 조건이 일치할 때 주로 풀 테이블 스캔을 선택한다.

- 테이블의 레코드 건수가 너무 작아서 인덱스를 통해 읽는 것보다 풀 테이블 스캔을 하는 편이 더 빠른 경우 (일반적으로 테이블이 페이지 1개로 구성된 경우)
- WHERE 절이나 ON 절에 인덱스를 이용할 수 있는 적절한 조건이 없는 경우
- 인덱스 레인지 스캔을 사용할 수 있는 쿼리라 하더라도 옵티마이저가 판단한 조건 일치 레코드 건수가 너무 많은 경우 (인덱스의 B-Tree를 샘플링해서 조사한 통계 정보 기준)

## 6.3.2 ORDER BY 처리(Using filesort)

정렬을 처리하기 위해서는 `인덱스를 이용`하는 방법과 쿼리가 실행될 때 `Filesort`라는 별도의 처리를 이용하는 방법으로 나눌 수 있다.

- 인덱스
  - INSERT, UPDATE, DELETE 쿼리가 실행될 때 이미 인덱스가 정렬돼있어서 순서대로 읽기만 하면 되므로 매우 빠름
  - INSERT, UPDATE, DELETE 작업 시 부가적인 인덱스 추가/삭제 작업이 필요하므로 느림
  - 인덱스 때문에 디스크 공간이 더 많이 필요
  - 인덱스의 개수가 늘어날수록 InnoDB의 버퍼 풀이나 MyISAM의 키 캐시용 메모리가 많이 필요함
- Filesort
  - 인덱스를 생성하지 않아도 되므로 인덱스를 이용했을 때의 단점이 장점으로 바뀜
  - 정렬해야 할 레코드가 많지 않으면 메모리에서 Filesort가 처리되므로 충분히 빠름
  - 정렬 작업이 쿼리 실행 시 처리되므로 레코드 대상 건수가 많아질수록 쿼리 응답 속도가 느려짐

### 소트 버퍼(Sort buffer)

MySQL은 정렬을 수행하기 위해 별도의 메모리 공간을 할당받아서 사용하는데, 이 메모리 공간을 `소트 버퍼`라고 한다.  
소트 버퍼는 정렬이 필요한 경우에만 할당되며, 버퍼의 크기는 정렬해야 할 레코드의 크기에 따라 가변적으로 증가하지만 최대 사용 가능한 소트 버퍼의 공간은 sort_buffer_size라는 시스템 변수로 설정할 수 있다.  
소트 버퍼를 위한 메모리 공간은 쿼리의 실행이 완료되면 즉시 시스템으로 반납된다.

정렬해야 할 레코드가 아주 소량이어서 메모리에 할당된 소트 버퍼만으로 정렬할 수 있다면 아주 빠르게 정렬이 처리될 것이다.  
**하지만 정렬해야 할 레코드의 건수가 소트 버퍼로 할당된 공간보다 크다면 MySQL은 정렬해야 할 레코드를 여러 조각으로 나누러 처리하는데, 이 과정에서 임시 저장을 위해 디스크를 사용한다.**  
메모리의 소트 버퍼에서 정렬을 수행하고, 그 결과를 임시로 디스크에 기록하고, 다음 레코드를 가져와서 다시 정렬해서 반복적으로 디스크에 저장하는 방식이다.

### 정렬의 처리 방식

쿼리에 ORDER BY가 사용되면 반드시 다음 3가지 처리 방식 중 하나로 정렬이 처리된다.  
일반적으로 아래쪽에 있는 정렬 방법으로 갈수록 처리가 느려진다.

| 정렬 처리 방법                                            | 실행 계획의 Extra 코멘트                          | 특징                                                                                                                                |
| --------------------------------------------------------- | ------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------- |
| 인덱스 사용한 정렬                                        | 별도의 내용 표기 없음                             | ORDER BY에 명시된 칼럼이 제일 먼저 읽는 테이블(조인이 사용된 경우 드라이빙 테이블)에 속하고, ORDER BY의 순서대로 생성된 인덱스 필요 |
| 드라이빙 테이블만 정렬 (조인이 없는 경우 포함)            | **Using filesort**가 표시됨                       | 조인에서 첫 번째 읽히는 테이블(드라이빙 테이블)의 칼럼만으로 ORDER BY 절이 작성되어야 함                                            |
| 조인 결과를 임시 테이블로 저장한 후, 임시 테이블에서 정렬 | **Using temporary; Using filesort**가 같이 표시됨 | 위 패턴 외의 쿼리에서는 항상 조인의 결과를 임시 테이블에 저장하고, 그 결과를 다시 정렬하는 과정을 거침                              |

## 6.3.3 GROUP BY 처리

GROUP BY 처리 결과는 임시 테이블이나 버퍼에 존재하는 값을 필터링하는 역할을 수행한다.  
GROUP BY에 사용된 조건은 인덱스를 사용해서 처리될 수 없으므로 HAVING 절을 튜닝하려고 인덱스를 생성하거나 다른 방법을 고민할 필요는 없다.

## 6.3.4 DISTINCT 처리

특정 칼럼의 유니크한 값만을 조회하려면 SELECT 쿼리에 DISTINCT를 사용한다.  

### SELECT DISTINCT

단순히 SELECT 되는 레코드 중에서 유니크한 레코드만 가져오고자 하면 SELECT DISTINCT 형태의 쿼리 문장을 사용한다.  
이 경우에는 GROUP BY와 거의 같은 방식으로 처리된다.  
다음의 두 쿼리는 정렬 관련 부분만 빼면 내부적으로 같은 작업을 수행한다. (SELECT DISTINCT의 경우 정렬이 보장되지 않는다)

```sql
SELECT DISTINCT emp_no FROM salaries;
SELECT emp_no FROM salaires GROUP BY emp_no;
```

## 6.3.5 임시 테이블(Using temporary)

**MySQL 엔진이 스토리지 엔진으로부터 받아온 레코드를 정렬하거나 그룹핑할 때는 내부적인 임시 테이블을 사용한다.**  
"내부적"이라는 단어가 포함된 것은 여기서 이야기하는 임시 테이블은 "CREATE TEMPORARY TABLE"로 만든 임시 테이블과는 다르기 때문이다.  
일반적으로 MySQL 엔진이 사용하는 임시 테이블은 처음에는 메모리에 생성됐다가 테이블의 크기가 커지면 디스크로 옮겨진다.  
MySQL 엔진이 내부적인 가공을 위해 생성하는 임시 테이블은 다른 세션이나 다른 쿼리에서는 볼 수 없으며 사용하는 것도 불가능하다.

### 임시 테이블이 필요한 쿼리

다음과 같은 패턴의 쿼리는 MySQL 엔진에서 별도의 데이터 가공 작업을 필요로 하므로 대표적으로 내부 임시 테이블을 생성하는 케이스다.  
물론 이 밖에도 인덱스를 사용하지 못할 때는 내부 임시 테이블을 생성해야 할 때가 많다.

- ORDER BY와 GROUP BY에 명시된 칼럼이 다른 쿼리
- ORDER BY나 GROUP BY에 명시된 칼럼이 조인의 순서상 첫 번째 테이블이 아닌 쿼리
- DISTINCT와 ORDER BY가 동시에 쿼리에 존재하는 경우
- DISTINCT가 인덱스로 처리되지 못하는 경우
- UNION이나 UNION DISTINCT가 사용된 쿼리 (select_type 칼럼이 UNION RESULT인 경우)
- UNION ALL이 사용된 쿼리 (select_type 칼럼이 UNION RESULT인 경우)
- 쿼리의 실행 계획에서 select_type이 DERIVED인 쿼리

어떤 쿼리의 실행 계획에서 임시 테이블을 사용하는지는 Extra 칼럼에 "Using temporary"라는 키워드가 표시되는지 확인하면 된다.  

### 임시 테이블이 디스크에 생성되는 경우(MyISAM 스토리지 엔진을 사용)

내부 임시 테이블은 기본적으로는 메모리상에 만들어지지만 다음과 같은 조건을 만족하면 메모리에 임시 테이블을 생성할 수 없으므로 디스크상에 MyISAM 테이블로 만들어진다.

- 임시 테이블에 저장해야 하는 내용 중 BLOB(Binary Large Object)나 TEXT와 같은 대용량 칼럼이 있는 경우
- 임시 테이블에 저장해야 하는 레코드의 전체 크기나 UNION이나 UNION ALL에서 SELECT 되는 칼럼 중에서 길이가 512바이트 이상인 크기의 칼럼이 있는 경우
- GROUP BY나 DISTINCT 칼럼에서 512바이트 이상인 크기의 칼럼이 있는 경우
- 임시 테이블에 저장할 데이터의 전체 크기(데이터의 바이트 크기)가 tmp_table_size 또는 max_heap_table_size 시스템 설정값보다 큰 경우

### 임시 테이블 관련 상태 변수

임시 테이블이 디스크에 생성됐는지 메모리에 생성됐는지 파악하려면 MySQL 서버의 상태 변수를 확인해 보면 된다.

```sql
SHOW SESSION STATUS LIKE 'Created_tmp%';
```

### 임시 테이블 관련 주의사항

레코드 건수가 많지 않으면 내부 임시 테이블이 메모리에 생성되고 MySQL의 서버의 부하에 크게 영향을 미치지는 않는다.  
성능상의 이슈가 될만한 부분은 내부 임시 테이블이 MyISAM 테이블로 디스크에 생성되는 경우다.

임시 테이블이 MEMORY(HEAP) 테이블로 물리 메모리에 생성되는 경우도 주의해야 할 사항이 있다.
MEMORY(HEAP) 테이블의 모든 칼럼은 고정 크기 칼럼이라는 점이다.  
만약 특정 칼럼이 VARCHAR(512)라고 하더라도, 실제 메모리 테이블에서 차지하는 공간은 512 * 3(문자 집합을 utf8로 가정) 바이트가 된다.  
이러한 임시 테이블의 저장 방식 때문에 SELECT 하는 칼럼은 최소화하고(특히 불필요하면 BLOB나 TEXT 칼럼은 배제하는 것이 좋음), 칼럼의 데이터 타입 선정도 가능한 한 작게 해주는 것이 좋다.

## 6.3.6 테이블 조인

MySQL은 다른 DBMS보다 조인을 처리하는 방식이 단순하다.  
현재 릴리스된 MySQL의 모든 버전에서 조인 방식은 네스티드-루프로 알려진 중첩된 루프와 같은 형태만 지원한다.  
그리고 조인되는 각 테이블 간의 레코드를 어떻게 연결할지에 따라 여러 가지 종류의 조인으로 나뉜다.

### 조인의 종류

조인의 종류는 다음과 같다.

- INNER JOIN
- OUTER JOIN
  - LEFT OUTER JOIN
  - RIGUT OUTER JOIN
  - FULL OUTER JOIN
- NATURAL JOIN
- CROSS JOIN (FULL JOIN, CARTESIAN JOIN)

조인의 처리에서 어느 테이블을 먼저 읽을지를 결정하는 것은 상당히 중요하며, 그에 따라 처리할 작업량이 상당히 달라진다.  
INNER JOIN은 어느 테이블을 먼저 읽어도 결과가 달라지지 않으므로 MySQL 옵티마이저가 조인의 순서를 조절해서 다양한 방법으로 최적화를 수행할 수 있다.  
하지만 OUTER JOIN은 반드시 OUTER가 되는 테이블을 먼저 읽어야 하기 때문에 조인 순서를 옵티마이저가 선택할 수 없다.

### JOIN (INNER JOIN)

일반적으로 "조인"이라 함은 INNER JOIN을 지칭하는데, 별도로 아우터 조인과 구분할 때 "이너 조인(INNER JOIN)"이라고도 한다.  
MySQL에서 조인은 네스티드-루프 방식만 지원한다.  
네스티드-루프란 일반적으로 프로그램을 작성할 때 두 개의 FOR나 WHILE과 같은 반복 루프 문장을 실행하는 형태로 조인이 처리되는 것을 의미한다.

```text
FOR (record1 IN TABLE1) {
  FOR (record2 IN TABLE2) {
    IF (record1.join_column == record2.join_column) {
      join_record_column(record1.*, record2.*);
    } ELSE {
      join_record_notfound();
    }
  }
}
```

두 개의 FOR 문장에서 바깥쪽을 `아우터(OUTER) 테이블`이라고 하며, 안쪽을 `이너(INNER) 테이블`이라고 표현한다.  
또한 아우터 테이블은 이너 테이블보다 먼저 읽어야 하며, 조인에서 주도적인 역할을 한다고 해서 `드라이빙(Driving) 테이블`이라고도 한다.  
이너 테이블은 조인에서 끌려가는 역할을 한다고 해서 `드리븐(Driven) 테이블`이라고도 한다.  
**중첩된 반복 루프에서 최종적으로 선택될 레코드가 안쪽 반복 루프(INNER 테이블)에 의해 결정되는 경우를 INNER JOIN이라고 한다.**

### OUTER JOIN

**OUTER 테이블의 내용에 따라 조인의 결과가 결정되는 경우를 OUTER JOIN이라고 한다.**  
물론 OUTER 테이블과 INNER 테이블의 관계(대표적으로 1:M 관계일 때)에 의해 최종 결과 레코드 건수가 늘어날 수는 있지만, OUTER 테이블의 레코드가 INNER 테이블에 일치하는 레코드가 없다고 해서 버려지지는 않는다.

```text
FOR (record1 IN TABLE1) {
  FOR (record2 IN TABLE2) {
    IF (record1.join_column == record2.join_column) {
      join_record_column(record1.*, record2.*);
    } ELSE {
      join_record_column(record1.*, NULL);
    }
  }
}
```

LEFT OUTER JOIN과 RIGHT OUTER JOIN은 결국 처리 내용이 같으므로 혼동을 막기 위해 **LEFT OUTER JOIN으로 통일해서 사용하는 것이 일반적**이다.
JOIN 키워드를 기준으로 왼쪽의 테이블, 오른쪽의 테이블 모두 OUTER JOIN을 하고 싶은 경우 사용하는 쿼리가 FULL OUTER JOIN인데, **MySQL에서는 FULL OUTER JOIN을 지원하지 않는다.**

**OUTER JOIN에서 레코드가 없을 수도 있는 쪽의 테이블에 대한 조건은 반드시 LEFT JOIN의 ON 절에 모두 명시하자.**  
그렇지 않으면 옵티마이저는 OUTER JOIN을 내부적으로 INNER JOIN으로 변형시켜서 처리해 버릴 수도 있다.  
LEFT OUTER JOIN의 ON 절에 명시되는 조건은 조인되는 레코드가 있을 때만 적용된다.  
하지만 WHERE 절에 명시되는 조건은 OUTER JOIN이나 INNER JOIN에 관계없이 조인된 결과에 대해 모두 적용된다.
**그래서 OUTER JOIN으로 연결되는 테이블이 있는 쿼리에서는 가능하다면 모든 조건을 ON 절에 명시하는 습관을 들이는 것이 좋다.**
