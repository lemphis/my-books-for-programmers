# 6.2 실행 계획 분석

MySQL에서 쿼리의 실행 계획을 확인하려면 `EXPLAIN` 명령을 사용하면 된다.  
아무런 옵션 없이 EXPLAIN 명령을 사용하면 기본적인 쿼리 실행 계획만 보인다.  
하지만 **EXPLAIN EXTENDED**나 **EXPLAIN PARTITIONS** 명령을 이용해 더 상세한 실행 계획을 확인할 수 있다.

## 6.2.1 id 칼럼

실행 계획에서 가장 왼쪽에 표시되는 id 칼럼은 단위 SELECT 쿼리별로 부여되는 식별자 값이다.  
만약 하나의 SELECT 문장 안에서 여러 개의 테이블을 조인하면 조인되는 테이블 개수만큼 실행 계획 레코드가 출력되지만 같은 id가 부여된다.

## 6.2.2 select_type 칼럼

각 단위 SELECT 쿼리가 어떤 타입의 쿼리인지 표시되는 칼럼이다.  
select_type 칼럼에 표시될 수 있는 값은 다음과 같다.

- SIMPLE
    - UNION이나 서브 쿼리를 사용하지 않는 단순한 SELECT 쿼리인 경우 (조인이 포함된 경우도 마찬가지)
    - 쿼리가 아무리 복잡하더라도 실행 계획에서 select_type이 SIMPLE인 단위 쿼리는 반드시 하나만 존재
    - 일반적으로 제일 바깥 SELECT 쿼리가 해당됨
- PRIMARY
    - UNION이나 서브 쿼리가 포함된 SELECT 쿼리의 실행 계획에서 가장 바깥쪽에 있는 단위 쿼리인 경우
    - SIMPLE과 마찬가지로 select_type이 PRIMARY인 단위 쿼리는 하나만 존재
- UNION
    - UNION으로 결합하는 단위 SELECT 쿼리 가운데 첫 번째를 제외한 두 번째 이후 단위 SELECT 쿼리인 경우
    - UNION의 첫 번째 단위 SELECT는 UNION 쿼리로 결합된 전체 집합의 select_type이 표시됨
- DEPENDENT UNION
    - UNION이나 UNION ALL로 결합된 단위 쿼리가 외부의 영향에 의해 영향받는 경우 (외부 쿼리의 값을 참조하여 처리될 때)
- UNION RESULT
    - UNION 결과를 담아두는 테이블
    - 실제 쿼리에서 단위 쿼리가 아니기 때문에 별도로 id 값은 부여되지 않음
- SUBQUERY
    - FROM절 이외에서 사용되는 서브 쿼리인 경우
- DEPENDENT SUBQUERY
    - 서브 쿼리가 바깥쪽 SELECT 쿼리에서 정의된 칼럼을 사용하는 경
- DERIVED
    - FROM절에 사용된 서브 쿼리인 경우
    - 단위 SELECT 쿼리의 실행 결과를 메모리나 디스크에 임시 테이블을 생성하는 것을 의미
- UNCACHEABLE SUBQUERY
    - 서브 쿼리의 결과를 서브 쿼리에 포함된 요소에 의해 캐시가 불가능한 경우
    - 다음과 같은 요소들이 서브 쿼리에 사용되었을 경우 캐시를 사용 불가능
        - 사용자 변수
        - NOT-DETERMINISTIC 속성의 스토어드 루틴
        - UUID()나 RAND() 같이 결과값이 호출할 때마다 달라지는 함수
- UNCACHEABLE UNION
    - UNION, UNCACHEABLE 속성이 혼합된 select_type

## 6.2.3 table 칼럼

MySQL의 실행 계획은 테이블 기준으로 표시된다.  
만약 테이블의 이름에 별칭이 부여된 경우에는 별칭이 표시된다.  
별도의 테이블을 사용하지 않는 SELECT 쿼리는 table 칼럼에 null이 표시된다.

## 6.2.4 type 칼럼

MySQL 서버가 각 테이블의 레코드를 어떤 방식으로 읽었는지를 의미한다.  
MySQL에서는 하나의 테이블로부터 레코드를 읽는 작업도 조인처럼 처리한다.  
다음 접근 방식은 성능이 빠른 순서대로 나열된 것이다.

- system
    - 레코드가 1건만 존재하는 테이블 또는 한 건도 존재하지 않는 테이블을 참조하는 형태의 접근 방법
    - InnoDB 테이블에서는 나타나지 않음
- const
    - 테이블의 레코드 건수에 관계없이 쿼리가 PK 또는 UK 칼럼을 이용하는 WHERE 조건을 가지고 있으며, 반드시 1건을 반환하는 쿼리의 처리 방식
    - 다른 DBMS에서는 유니크 인덱스 스캔(UNIQUE INDEX SCAN)이라고 표현
    - 옵티마이저가 쿼리를 최적화하는 단계에서 모두 상수화함
- eq_ref
    - 여러 테이블이 조인되는 쿼리의 실행 계획에서만 표시됨
    - 조인에서 처음 읽은 테이블의 칼럼 값을, 그다음 읽어야 할 테이블의 PK나 UK 칼럼의 검색 조건에 사용될 때의 접근 방법
    - 두 번째 이후에 읽는 테이블의 type 칼럼에 표시됨
    - 두 번째 이후에 읽는 테이블에서 반드시 1건만 존재한다는 보장이 있어야 사용할 수 있는 접근 방법
        - 두 번째 이후에 읽히는 테이블을 UK로 검색할 때 그 UK는 NOT NULL이어야 함
        - 다중 칼럼으로 만들어진 PK나 UNIQUE INDEX라면 인덱스의 모든 칼럼이 비교 조건에 사용되어야 함
- ref
    - eq_ref와 달리 조인의 순서와 관계없이 사용됨
    - PK나 UK 등의 제약 조건 없음
    - 인덱스의 종류와 관계없이 동등 조건으로 검색할 때의 접근 방법
- fulltext
    - MySQL의 전문 검색(Fulltext) 인덱스를 사용해 레코드를 읽는 접근 방법
    - 전문 인덱스를 사용할 수 있는 SQL에서는 쿼리의 비용과는 관계없이 거의 매번 fulltext 접근 방법을 사용
        - fulltext보다 명백히 빠른 const, eq_ref, ref 접근 방법을 사용할 수 있는 쿼리에서 억지로 fulltext 접근 방법을 사용하지는 않음
- ref_or_null
    - ref 접근 방식에 NULL 비교가 추가된 형태
- unique_subquery
    - WHERE 조건에서 사용될 수 있는 IN (subquery) 형태의 쿼리를 위한 접근 방식
    - 서브 쿼리에서 중복되지 않은 유니크한 값이 반환될 때 사용
- index_subquery
    - IN (subquery) 에서 subquery가 중복된 값을 반환할 수는 있지만 중복된 값을 인덱스를 이용해 제거할 수 있을 때 사용
    - IN절 안에 있는 중복 값을 아주 낮은 비용으로 제거함 (별도의 정렬 작업이 필요하지 않음)
- range
    - 인덱스 레인지 스캔 형태의 접근 방법 (범위로 검색하는 경우)
    - 주로 \<, \>, IS NULL, BETWEEN, IN, LIKE 등의 연산자를 이용해 인덱스를 검색할 때 사용
- index_merge
    - 두 개 이상의 인덱스를 이용해 각각의 검색 결과를 만들어낸 후 그 결과를 병합하는 처리 방식
    - 여러 인덱스를 읽어야 하므로 일반적으로 range 접근 방식보다 효율성이 떨어짐
    - AND와 OR 연산이 복잡하게 연결된 쿼리에서는 제대로 최적화되지 못할 때가 많음
    - 전문 검색 인덱스를 사용하는 쿼리에서는 적용되지 않음
    - 처리된 결과가 항상 2개 이상의 집합이 되기 때문에 그 두 집합의 교집합이나 합집합 또는 중복 제거와 같은 부가 작업이 더 필요함
- index
    - 인덱스를 처음부터 끝까지 읽는 인덱스 풀 스캔 방식 (range 접근 방식과 같이 효율적으로 인덱스의 필요한 부분을 읽는 것이 아님)
    - 아래의 조건 중 1, 2번을 동시에 만족하거나 1, 3번을 동시에 만족해야 사용되는 읽기 방식
        1. range, const, ref와 같은 접근 방식으로 인덱스를 사용하지 못하는 경우
        2. 인덱스에 포함된 칼럼만으로 처리할 수 있는 쿼리인 경우
        3. 인덱스를 이용해 정려이나 그룹핑 작업이 가능한 경우 (별도의 정렬 작업을 피할 수 있는 경우)
- ALL
    - 풀 테이블 스캔 접근 방식
    - 가장 마지막에 선택되는 가장 비효율적인 방법
    - 데이터웨어하우스나 배치 프로그램처럼 대용량의 레코드를 처리하는 쿼리에서는 잘못 튜닝된 쿼리(억지로 인덱스를 사용하도록 튜닝된 쿼리)보다 더 나은 접근 방법이 되기도 함