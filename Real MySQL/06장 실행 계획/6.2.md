# 6.2 실행 계획 분석

MySQL에서 쿼리의 실행 계획을 확인하려면 `EXPLAIN` 명령을 사용하면 된다.  
아무런 옵션 없이 EXPLAIN 명령을 사용하면 기본적인 쿼리 실행 계획만 보인다.  
하지만 **EXPLAIN EXTENDED**나 **EXPLAIN PARTITIONS** 명령을 이용해 더 상세한 실행 계획을 확인할 수 있다.

## 6.2.1 id 칼럼

실행 계획에서 가장 왼쪽에 표시되는 id 칼럼은 단위 SELECT 쿼리별로 부여되는 식별자 값이다.  
만약 하나의 SELECT 문장 안에서 여러 개의 테이블을 조인하면 조인되는 테이블 개수만큼 실행 계획 레코드가 출력되지만 같은 id가 부여된다.

## 6.2.2 select_type 칼럼

각 단위 SELECT 쿼리가 어떤 타입의 쿼리인지 표시되는 칼럼이다.  
select_type 칼럼에 표시될 수 있는 값은 다음과 같다.

- SIMPLE
  - UNION이나 서브 쿼리를 사용하지 않는 단순한 SELECT 쿼리인 경우 (조인이 포함된 경우도 마찬가지)
  - 쿼리가 아무리 복잡하더라도 실행 계획에서 select_type이 SIMPLE인 단위 쿼리는 반드시 하나만 존재
  - 일반적으로 제일 바깥 SELECT 쿼리가 해당됨
- PRIMARY
  - UNION이나 서브 쿼리가 포함된 SELECT 쿼리의 실행 계획에서 가장 바깥쪽에 있는 단위 쿼리인 경우
  - SIMPLE과 마찬가지로 select_type이 PRIMARY인 단위 쿼리는 하나만 존재
- UNION
  - UNION으로 결합하는 단위 SELECT 쿼리 가운데 첫 번째를 제외한 두 번째 이후 단위 SELECT 쿼리인 경우
  - UNION의 첫 번째 단위 SELECT는 UNION 쿼리로 결합된 전체 집합의 select_type이 표시됨
- DEPENDENT UNION
  - UNION이나 UNION ALL로 결합된 단위 쿼리가 외부의 영향에 의해 영향받는 경우 (외부 쿼리의 값을 참조하여 처리될 때)
- UNION RESULT
  - UNION 결과를 담아두는 테이블
  - 실제 쿼리에서 단위 쿼리가 아니기 때문에 별도로 id 값은 부여되지 않음
- SUBQUERY
  - FROM 절 이외에서 사용되는 서브 쿼리인 경우
- DEPENDENT SUBQUERY
  - 서브 쿼리가 바깥쪽 SELECT 쿼리에서 정의된 칼럼을 사용하는 경
- DERIVED
  - FROM 절에 사용된 서브 쿼리인 경우
  - 단위 SELECT 쿼리의 실행 결과를 메모리나 디스크에 임시 테이블을 생성하는 것을 의미
- UNCACHEABLE SUBQUERY
  - 서브 쿼리의 결과를 서브 쿼리에 포함된 요소에 의해 캐시가 불가능한 경우
  - 다음과 같은 요소들이 서브 쿼리에 사용되었을 경우 캐시를 사용 불가능
    - 사용자 변수
    - NOT-DETERMINISTIC 속성의 스토어드 루틴
    - UUID()나 RAND() 같이 결과값이 호출할 때마다 달라지는 함수
- UNCACHEABLE UNION
  - UNION, UNCACHEABLE 속성이 혼합된 select_type

## 6.2.3 table 칼럼

MySQL의 실행 계획은 테이블 기준으로 표시된다.  
만약 테이블의 이름에 별칭이 부여된 경우에는 별칭이 표시된다.  
별도의 테이블을 사용하지 않는 SELECT 쿼리는 table 칼럼에 null이 표시된다.

## 6.2.4 type 칼럼

MySQL 서버가 각 테이블의 레코드를 어떤 방식으로 읽었는지를 의미한다.  
MySQL에서는 하나의 테이블로부터 레코드를 읽는 작업도 조인처럼 처리한다.  
다음 접근 방식은 성능이 빠른 순서대로 나열된 것이다.

- system
  - 레코드가 1건만 존재하는 테이블 또는 한 건도 존재하지 않는 테이블을 참조하는 형태의 접근 방법
  - InnoDB 테이블에서는 나타나지 않음
- const
  - 테이블의 레코드 건수에 관계없이 쿼리가 PK 또는 UK 칼럼을 이용하는 WHERE 조건을 가지고 있으며, 반드시 1건을 반환하는 쿼리의 처리 방식
  - 다른 DBMS에서는 유니크 인덱스 스캔(UNIQUE INDEX SCAN)이라고 표현
  - 옵티마이저가 쿼리를 최적화하는 단계에서 모두 상수화함
- eq_ref
  - 여러 테이블이 조인되는 쿼리의 실행 계획에서만 표시됨
  - 조인에서 처음 읽은 테이블의 칼럼 값을, 그다음 읽어야 할 테이블의 PK나 UK 칼럼의 검색 조건에 사용될 때의 접근 방법
  - 두 번째 이후에 읽는 테이블의 type 칼럼에 표시됨
  - 두 번째 이후에 읽는 테이블에서 반드시 1건만 존재한다는 보장이 있어야 사용할 수 있는 접근 방법
    - 두 번째 이후에 읽히는 테이블을 UK로 검색할 때 그 UK는 NOT NULL이어야 함
    - 다중 칼럼으로 만들어진 PK나 UNIQUE INDEX라면 인덱스의 모든 칼럼이 비교 조건에 사용되어야 함
- ref
  - eq_ref와 달리 조인의 순서와 관계없이 사용됨
  - PK나 UK 등의 제약 조건 없음
  - 인덱스의 종류와 관계없이 동등 조건으로 검색할 때의 접근 방법
- fulltext
  - MySQL의 전문 검색(Fulltext) 인덱스를 사용해 레코드를 읽는 접근 방법
  - 전문 인덱스를 사용할 수 있는 SQL에서는 쿼리의 비용과는 관계없이 거의 매번 fulltext 접근 방법을 사용
    - fulltext보다 명백히 빠른 const, eq_ref, ref 접근 방법을 사용할 수 있는 쿼리에서 억지로 fulltext 접근 방법을 사용하지는 않음
- ref_or_null
  - ref 접근 방식에 NULL 비교가 추가된 형태
- unique_subquery
  - WHERE 조건에서 사용될 수 있는 IN (subquery) 형태의 쿼리를 위한 접근 방식
  - 서브 쿼리에서 중복되지 않은 유니크한 값이 반환될 때 사용
- index_subquery
  - IN (subquery) 에서 subquery가 중복된 값을 반환할 수는 있지만 중복된 값을 인덱스를 이용해 제거할 수 있을 때 사용
  - IN 절 안에 있는 중복 값을 아주 낮은 비용으로 제거함 (별도의 정렬 작업이 필요하지 않음)
- range
  - 인덱스 레인지 스캔 형태의 접근 방법 (범위로 검색하는 경우)
  - 주로 \<, \>, IS NULL, BETWEEN, IN, LIKE 등의 연산자를 이용해 인덱스를 검색할 때 사용
- index_merge
  - 두 개 이상의 인덱스를 이용해 각각의 검색 결과를 만들어낸 후 그 결과를 병합하는 처리 방식
  - 여러 인덱스를 읽어야 하므로 일반적으로 range 접근 방식보다 효율성이 떨어짐
  - AND와 OR 연산이 복잡하게 연결된 쿼리에서는 제대로 최적화되지 못할 때가 많음
  - 전문 검색 인덱스를 사용하는 쿼리에서는 적용되지 않음
  - 처리된 결과가 항상 2개 이상의 집합이 되기 때문에 그 두 집합의 교집합이나 합집합 또는 중복 제거와 같은 부가 작업이 더 필요함
- index
  - 인덱스를 처음부터 끝까지 읽는 인덱스 풀 스캔 방식 (range 접근 방식과 같이 효율적으로 인덱스의 필요한 부분을 읽는 것이 아님)
  - 아래의 조건 중 1, 2번을 동시에 만족하거나 1, 3번을 동시에 만족해야 사용되는 읽기 방식
    1. range, const, ref와 같은 접근 방식으로 인덱스를 사용하지 못하는 경우
    2. 인덱스에 포함된 칼럼만으로 처리할 수 있는 쿼리인 경우
    3. 인덱스를 이용해 정렬이나 그룹핑 작업이 가능한 경우 (별도의 정렬 작업을 피할 수 있는 경우)
- ALL
  - 풀 테이블 스캔 접근 방식
  - 가장 마지막에 선택되는 가장 비효율적인 방법
  - 데이터웨어하우스나 배치 프로그램처럼 대용량의 레코드를 처리하는 쿼리에서는 잘못 튜닝된 쿼리(억지로 인덱스를 사용하도록 튜닝된 쿼리)보다 더 나은 접근 방법이 되기도 함

## 6.2.5 possible_keys

MySQL 옵티마이저가 최적의 실행 계획을 만들기 위해 후보로 선정됐던 접근 방식에서 사용되는 인덱스의 목록이다.

## 6.2.6 key

최종 선택된 실행 계획에서 사용하는 인덱스를 의미한다.  
쿼리를 튜닝할 때 key 칼럼에 의도했던 인덱스가 표시되는지 확인하는 것이 중요하다.  
key 칼럼에 표시되는 값이 PRIMARY인 경우에는 PK를 사용하다는 의미이며, 그 이외의 값은 모두 테이블이나 인덱스를 생성할 때 부여했던 고유 이름이다.  
실행 계획의 type 칼럼이 아닌 경우에는 반드시 테이블 하나당 하나의 인덱스만 이용할 수 있다.

## 6.2.7 key_len

쿼리를 처리하기 위해 다중 칼럼으로 구성된 인덱스에서 몇 바이트까지 사용했는지(몇 개의 칼럼까지 사용했는지) 우리에게 알려 준다.

## 6.2.8 ref

참조 조건(equal 비교 조건)으로 어떤 값이 제공됐는지 보여 준다.  
만약 상숫값을 지정했다면 const로 표시되고, 다른 테이블의 칼럼 값이면 그 테이블명과 칼럼명이 표시된다.

가끔 쿼리의 실행 계획에서 ref 칼럼의 값이 func라고 표시될 때가 있다.  
이는 참조용으로 사용되는 값을 그대로 사용한 것이 아니라, 콜레이션 변환이나 값 자체의 연산을 거쳐서 참조됐다는 것을 의미한다.  
사용자가 명시적으로 값을 변환할 때뿐만 아니라, MySQL 서버가 내부적으로 값을 변환해야 할 때도 ref 칼럼에는 func가 출력된다.  
문자 집합이 일치하지 않는 두 문자열 칼럼을 조인한다거나, 숫자 타입의 칼럼과 문자열 타입의 칼럼으로 조인할 때가 대표적인 예다.  
가능하다면 MySQL 서버가 이런 변환을 하지 않아도 되도록 조인 칼럼의 타입은 일치시키는 것이 좋다.

## 6.2.9 rows

MySQL 옵티마이저가 비용을 산정하는 방법은 각 처리 방법이 얼마나 많은 레코드를 읽고 비교해야 하는지 예측해 보는 것이다.  
rows 칼럼은 실행 계획의 효율성 판단을 위해 예측했던 레코드 건수를 보여준다.  
더 정확히는 쿼리를 처리하기 위해 얼마나 많은 레코드를 디스크로부터 읽고 체크해야 하는지를 의미한다.
각 스토리지 엔진별로 가지고 있는 통계 정보를 참조해 MySQL 옵티마이저가 산출해 낸 예상 값이라서 정확하지 않다.  
LIMIT가 포함되는 쿼리는 rows 칼럼에 표시되는 값이 오차가 너무 심해서 별로 도움이 되지 않는다.

## 6.2.10 Extra

쿼리의 실행 계획에서 성능에 관련된 중요한 내용이 표시된다.  
고정된 몇 개의 문장이 표시되며, 일반적으로 2~3개씩 같이 표시된다.  
아래 순서는 성능과 무관하다.

- const row not found (MySQL 5.1부터)
  - const 접근 방식으로 테이블을 읽었지만 실제로 해당 테이블에 레코드가 1건도 존재하지 않는 경우
- Distinct
  - 쿼리의 DISTINCT 처리를 위해 조인하지 않아도 되는 항목은 무시하고 꼭 필요한 것만 조인했다는 점을 표현
- Full scan on NULL key
  - col1 IN(SELECT col2 FROM ...) 과 조건이 포함된 쿼리에서 자주 발생할 수 있음
  - col1의 값이 NULL이 된다면 결과적으로 조건은 NULL IN (SELECT col2 FROM ...) 과 같이 바뀜
  - MySQL이 쿼리를 실행하는 중 col1이 NULL을 만나면 예비책으로 풀 테이블 스캔을 사용할 것이라는 사실을 알려주는 키워드
- Impossible HAVING (MySQL 5.1부터)
  - 쿼리에 사용된 HAVING 절의 조건을 만족하는 레코드가 없을 때 표시
- Impossible WHERE (MySQL 5.1부터)
  - 쿼리에 사용된 WHERE 조건이 항상 FALSE가 될 수밖에 없는 경우 표시
- Impossible WHERE noticed after reading const tables
  - MySQL이 쿼리의 일부분을 실행해 보고 WHERE 조건이 항상 FALSE라고 판단할 경우 표시
- No matching min/max row (MySQL 5.1부터)
  - MIN()이나 MAX()와 같은 집합 함수가 있는 쿼리의 조건절에 일치하는 레코드가 한 건도 없을 때 표시
- no matching row in const table (MySQL 5.1부터)
  - const 방식으로 접근할 때 일치하는 레코드가 없는 경우
- No tables used (MySQL 5.0의 "No tables"에서 키워드 변경됨)
  - FROM 절이 없는 쿼리 문장이나 "FROM DUAL" 형태의 쿼리 실행 계획에서 표시
- Not exists
  - 아우터 조인을 이용해 안티-조인(Anti-JOIN)을 수행하는 쿼리 실행 계획에서 표시
  - A 테이블에는 존재하지만 B 테이블에는 존재하지 않는 값을 조회해야 할 때 주로 NOT IN (subquery) 형태나 NOT EXIST 연산자를 사용하지만, 레코드 건수가 많을 경우 아우터 조인을 이용하면 빠른 성능을 낼 수 있음
- Range checked for each record (index map: N)
  - 매 레코드마다 인덱스 레인지 스캔을 체크하는 경우 표시
  - (index map: N)은 사용할지 말지를 판단하는 후보 인덱스의 순번을 나타냄 (N은 16진수)
  - 후보 인덱스의 순번은 "SHOW CREATE TABLE {table}" 명령으로 테이블의 구조를 조회했을 때 출력되는 인덱스 순서임
  - type 칼럼에는 ALL로 표시됨
- Scanned N databases (MySQL 5.1부터)
  - 개선된 조회를 통해 메타 정보를 검색할 경우 표시
  - MySQL 5.1부터는 INFORMATION_SCHEMA DB를 빠르게 조회할 수 있게 개선됨
- Select tables optimized away
  - MIN() 또는 MAX()만 SELECT 절에 사용되거나 GROUP BY로 MIN(), MAX()를 조회하는 쿼리가 적절한 인덱스를 사용할 수 없을 때 인덱스를 오름차순 또는 내림차순으로 1건만 읽는 형태의 최적화가 적용될 때 표시
- Skip_open_table, Open_frm_only, Open_trigger_only, Open_full_table (MySQL 5.1부터)
  - INFORMATION_SCHEMA DB의 메타 정보를 조회하는 SELECT 쿼리의 실행 계획에서만 표시되는 내용
  - 테이블의 메타 정보가 저장된 파일(\*.FRM)과 트리거가 저장된 파일(\*.TRG) 또는 데이터 파일 중에서 필요한 파일만 읽었는지 또는 불가피하게 모든 파일을 다 읽었는지 등의 정보를 보여줌
    - Skip_open_table: 테이블의 메타 정보가 저장된 파일을 별도로 읽을 필요가 없음
    - Open_frm_only: 테이블의 메타 정보가 저장된 파일(\*.FRM)만 열어서 읽음
    - Open_trigger_only: 트리거 정보가 저장된 파일(\*.TRG)만 열어서 읽음
    - Open_full_table: 최적화되지 못해서 테이블 메타 정보 파일(\*.FRM)과 데이터(\*.MYD) 및 인덱스 파일(\*.MYI)까지 모두 읽음
- unique row not found (MySQL 5.1부터)
  - 두 개의 테이블이 각각 유니크(PK 포함) 칼럼으로 아우터 조인을 수행하는 쿼리에서 아우터 테이블에 일치하는 레코드가 존재하지 않을 때 표시
- Using filesort
  - ORDER BY 처리가 인덱스를 사용하지 못할 경우 표시
  - ORDER BY를 처리하기 위해 인덱스를 이용할 수도 있지만 적절한 인덱스를 사용하지 못할 경우 MySQL 서버가 조회된 레코드를 다시 한 번 정렬해야 함
  - 조회된 레코드를 정렬용 메모리 버퍼(Sort buffer)에 복사해 퀵 소트 알고리즘 수행
  - 많은 부하를 일으키므로 가능하다면 쿼리를 튜닝하거나 인덱스를 생성하는 게 좋음
- Using index (커버링 인덱스)
  - 데이터 파일을 전혀 읽지 않고 인덱스만 읽어서 쿼리를 모두 처리할 수 있을 때 표시
  - 인덱스를 이용해 처리하는 쿼리에서 가장 큰 부하를 차지하는 부분은 인덱스를 검색해 일치하는 레코드의 나머지 칼럼 값을 가져오기 위해 데이터 파일을 찾아서 가져오는 작업임
- Using index for group-by
  - GROUP BY 처리가 인덱스를 필요한 부분에만 이용할 때 표시 (루스 인덱스 스캔)
  - GROUP BY 처리를 위해 MySQL 서버는 그룹핑 기준 칼럼을 이용해 정렬 작업을 수행하고 다시 정렬된 결과를 그룹핑하는 형태의 고부하 작업을 필요로 함
  - GROUP BY 처리가 인덱스(B-Tree 인덱스에 한해)를 이용하면 정렬된 인덱스 칼럼을 순서대로 읽으면서 그룹핑 작업만 수행하므로 상당히 효율적이고 빠르게 처리됨
  - 타이트 인덱스 스캔(AVG()나 SUM(), COUNT(\*) 같이 GROUP BY 처리를 위해 인덱스를 순서대로 쭉 읽는 방식) 방식은 Using index for group-by 가 표시되지 않음
  - WHERE 절에서 사용하는 인덱스에 의해서 사용 여부가 영향을 받음
    - WHERE 조건절이 없는 경우
      - GROUP BY와 조회하는 칼럼이 루스 인덱스 스캔을 사용할 수 있는 조건만 갖추면 됨
      - 그렇지 못한 쿼리는 타이트 인덱스 스캔이나 별도의 정렬 과정을 통해 처리됨
    - WHERE 조건절이 있지만 검색을 위해 인덱스를 사용하지 못하는 경우
      - 먼저 GROUP BY를 위해 인덱스를 읽은 후, WHERE 조건의 비교를 위해 데이터 레코드를 읽음 (루스 인덱스 스캔 사용 불가)
    - WHERE 조건절이 있으며 검색을 위해 인덱스를 사용하는 경우
      - WHERE 절의 조건이 검색하는 데 사용한 인덱스를 GROUP BY 처리가 다시 사용할 수 있을 때만 루스 인덱스 스캔을 사용할 수 있음
      - WHERE 조건절이 사용할 수 있는 인덱스와 GROUP BY 절이 사용할 수 있는 인덱스가 다른 경우에는 일반적으로 옵티마이저는 WHERE 조건절이 인덱스를 사용하도록 실행 계획 수립
  - DISTINCT나 GROUP BY가 포함된 쿼리에서 최적의 튜닝 방법
- Using join buffer (MySQL 5.1부터)
  - 드라이빙 테이블에서 읽은 레코드를 임시로 보관해두는 메모리 공간(조인 버퍼)이 사용되는 실행 계획에서 표시
  - 조인이 수행될 때 드리븐 테이블의 조인 칼럼에 적절한 인덱스가 없어서 발생하는 비효율적인 검색을 보완하기 위해 드라이빙 테이블에서 읽은 레코드를 임시 공간에 보관함
- Using sort_union(...), Using union(...), Using intersect(...)
  - 두 개 이상의 인덱스로부터 읽은 결과를 어떻게 병합했는지에 대해 조금 더 상세하기 설명하기 위해 표시
  - 쿼리가 index_merge 접근 방식으로 실행되는 경우 2개 이상의 인덱스가 동시에 사용될 수 있음
  - 다음 3개 중에서 하나의 메시지를 선택적으로 출력
    - Using intersect(...)
      - 각각의 인덱스를 사용할 수 있는 조건이 AND로 연결된 경우 각 처리 결과에서 교집합을 추출해내는 작업을 수행했다는 의미
    - Using union(...)
      - 각각의 인덱스를 사용할 수 있는 조건이 OR로 연결된 경우 각 처리 결과에서 합집합을 추출해내는 작업을 수행했다는 의미
    - Using sort_union(...)
      - Using union과 같은 작업을 수행하지만 Using union으로 처리될 수 없는 경우(OR로 연결된 상대적으로 대량의 range 조건들) 이 방식으로 처리
- Using temporary
  - 쿼리를 처리하는 동안 중간 결과를 담아 두기 위해 임시 테이블(Temporary table)을 사용한 경우 표시
- Using where
  - MySQL 엔진 레이어에서 별도의 가공을 해서 필터링(여과) 작업을 처리한 경우 표시
- Using where with pushed condition
  - Condition push down이 적용됐으며 NDB 클러스터 스토리지 엔진을 사용하는 경우 표시

## 6.2.11 EXPLAIN EXTENDED(Filtered 칼럼)

MySQL 5.1 이상 버전이라 하더라도 스토리지 엔진에서 최종적으로 사용자에게 전달되는 레코드만 가져오는 것은 아니다.  
조인과 같은 여러 가지 이유로 여전이 각 스토리지 엔진에서 읽어 온 레코드를 MySQL 엔진에서 필터링한다.  
실행 계획에서 filtered 칼럼은 MySQL 엔진에 의해 필터링 되어 제거된 레코드는 제외하고 최종적으로 레코드가 얼마나 남았는지의 비율이 표시된다.  
여기에 출력되는 filtered 칼럼의 정보는 실제 값이 아니라 단순히 통계 정보로부터 예측된 값이다.

## 6.2.12 EXPLAIN EXTENDED(추가 옵티마이저 정보)

EXPLAIN EXTENDED 명령의 또 다른 기능은 분석된 파스 트리를 재조합해서 쿼리 문장과 비슷한 순서대로 나열해서 보여주는 것이다.  
EXPLAIN EXTENDED 명령을 실행한 직후, SHOW WARNINGS 명령을 실행하면 옵티마이저가 분석해서 다시 재조합한 쿼리 문장을 보여준다.  
SHOW WARNINGS 명령으로 출력된 내용은 표준 SQL 문장이 아니다.

## 6.2.13 EXPLAIN PARTITIONS(Partitions 칼럼)

EXPLAIN 명령 뒤에 PARTITIONS 옵션을 사용하면 쿼리를 실행하기 위해 테이블의 파티션 중에서 어떤 파티션을 사용했는지 등의 정보를 조회할 수 있다.  
파티션이 여러 개인 테이블에서 불필요한 파티션을 빼고 쿼리를 수행하기 위해 접근해야 할 것으로 판단되는 테이블만 골라내는 과정을 파티션 프루닝(partition pruning)이라고 한다.
