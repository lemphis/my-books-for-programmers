# 4.4 InnoDB 스토리지 엔진의 잠금

InnoDB 스토리지 엔진은 MySQL에서 제공하는 잠금과는 별개로 스토리지 엔진 내부에서 **레코드 기반의 잠금 방식**을 탑재하고 있다.  
InnoDB는 레코드 기반의 잠금 방식 때문에 MyISAM보다는 훨씬 뛰어난 동시성 처리를 제공할 수 있다.  
하지만 이원화된 잠금 처리 탓에 InnoDB 스토리지 엔진에서 사용되는 잠금에 대한 정보는 MySQL 명령을 이용해 접근하기가 상당히 까다롭다.

MySQL 5.1부터 InnoDB 플러그인 스토리지 엔진이 도입되면서부터 InnoDB의 트랜잭션과 잠금 그리고 잠금 대기 중인 트랜잭션의 목록을 조회할 수 있는 방법이 도입됐다.  
MySQL 서버의 INFORMATION_SCHEMA 데이터베이스에 존재하는 INNODB_TRX, INNODB_LOCKS, INNODB_LOCK_WAITS 테이블을 조인해서 조회하면 현재 어떤 트랜잭션이 어떤 잠금을 대기하고 있고 해당 잠금을 어느 트랜잭션이 가지고 있는지 확인할 수 있으며, 장시간 잠금을 가지고 있는 클라이언트를 종료시키는 것도 가능하다.

## 4.4.1 InnoDB의 잠금 방식

- 비관적 잠금 (Optimistic locking)
  - 현재 트랜잭션에서 변경하고자 하는 레코드에 대해 잠금을 획득하고 변경 작업을 처리하는 방식
- 낙관적 잠금 (Pessimistic locking)
  - 우선 변경 작업을 진행하고, 마지막에 잠금 충돌이 있었는지 확인해 문제가 있었다면 ROLLBACK 처리하는 방식
  - 각 트랜잭션이 같은 레코드를 변경할 가능성은 상당히 희박할 것이라고(낙관적으로) 가정함

## 4.4.2 InnoDB의 잠금 종류

InnoDB 스토리지 엔진은 레코드 기반 잠금 기능을 제공하며, 잠금 정보가 상당히 작은 공간으로 관리되기 때문에 레코드 락이 페이지 락으로 또는 테이블 락으로 레벨 업되는 경우(락 에스컬레이션)는 없다.  
일반 상용 DBMS와는 조금 다르게 InnoDB 스토리지 엔진에서는 레코드 락뿐 아니라 레코드와 레코드 사이의 간격을 잠그는 갭(GAP) 락이라는 것이 존재한다.

- 레코드 락 (Record lock, Record only lock)
  - 레코드 자체만을 잠그는 것이며, 다른 상용 DBMS의 레코드 락과 동일한 역할을 함
  - InnoDB 스토리지 엔진은 레코드 자체가 아니라 인덱스의 레코드를 잠금 (인덱스가 하나도 없는 테이블이라 하더라도 내부적으로 자동 생성된 클러스터 인덱스를 이용해 잠금을 설정)
  - InnoDB에서는 대부분 보조 인덱스를 이용한 변경 작업은 넥스트 키 락(Next key lock) 또는 갭 락(Gap lock)을 사용하지만, 프라이머리 키 또는 유니크 인덱스에 의한 변경 작업은 갭(Gap)에 대해서는 잠그지 않고 레코드 자체에 대해서만 락을 적용
- 갭 락 (Gap lock)
  - 레코드 그 자체가 아니라 레코드와 바로 인접한 레코드 사이의 간격만을 잠그는 것
  - 레코드와 레코드 사이의 간격에 새로운 레코드가 생성(INSERT) 되는 것을 제어하는 역할을 함
  - 갭 락이라는 것은 개념일 뿐 자체적으로 사용되진 않고, 넥스트 키 락의 일부로 사용됨
- 넥스트 키 락 (Next key lock)
  - 레코드 락과 갭 락을 합쳐 놓은 형태의 잠금
  - 바이너리 로그에 기록되는 쿼리가 슬레이브에서 실행될 때 마스터에서 만들어낸 결과와 동일한 결과를 만들어내도록 보장하는 것이 주 목적
- 자동 증가 락 (Auto increment lock)
  - AUTO_INCREMENT 칼럼이 사용된 테이블에 동시에 여러 레코드가 INSERT 되는 경우, 저장되는 각 레코드는 중복되지 않고 저장된 순서대로 증가한 일련번호 값을 가져야 하는데, InnoDB 스토리지 엔진은 이를 위해 내부적으로 AUTO_INCREMENT 락이라고 하는 테이블 수준의 잠금 사용
  - INSERT, REPLACE 쿼리 문장과 같이 새로운 레코드를 저장하는 쿼리에서만 필요
  - 아주 짧은 시간 동안만 걸렸다가 해제되는 잠금이라서 대부분의 경우 문제 되지 않음

## 4.4.3 인덱스와 잠금

**InnoDB의 잠금은 레코드를 잠그는 것이 아니라 인덱스를 잠그는 방식으로 처리**된다.  
즉, 변경해야 할 레코드를 찾기 위해 검색한 인덱스의 레코드를 모두 잠가야 한다.
MySQL의 InnoDB에서 인덱스 설계가 중요한 이유는 이 때문이다.  
인덱스가 없는 경우에는 테이블을 풀 스캔하며 UPDATE 처리를 하는데, 이 과정에서 모든 레코드를 잠그게 된다.

## 4.4.4 트랜잭션 격리 수준과 잠금

InnoDB에서 넥스트 키 락을 필요하게 만드는 주원인은 복제를 위한 바이너리 로그 때문이다.  
레코드 기반의 바이너리 로그(Row based binary log)를 사용하거나 바이너리 로그를 사용하지 않는 경우에는 InnoDB의 갭 락이나 넥스트 키 락의 사용을 대폭 줄일 수 있다.

## 4.4.5 레코드 수준의 잠금 및 해제

### MySQL 5.0 이하의 잠금 확인 및 해제

MySQL 5.0 이하의 버전의 InnoDB에서는 각 트랜잭션이 어떤 잠금을 가지고 있는지 명확하게 알 수 없다.  
근본적인 원인에 해당하는 트랜잭션을 찾기 어렵다면 오래 기다리고 있는 트랜잭션의 커넥션을 모두 종료해 버리는 것이 가장 빠른 해결책이 될 것이다.

### MySQL 5.1 이상의 잠금 확인 및 해제

MySQL 5.1 이상의 버전의 InnoDB에서는 INFORMATION_SCHEMA DB에 INNODB_TRX, INNODB_LOCKS, INNODB_LOCK_WAITS라는 테이블을 이용해 각 트랜잭션이 어떤 잠금을 기다리고 있는지, 기다리고 있는 잠금은 어떤 트랜잭션이 가지고 있는지 쉽게 조회할 수 있다.
