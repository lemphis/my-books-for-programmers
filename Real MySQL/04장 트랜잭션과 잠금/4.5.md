# 4.5 MySQL의 격리 수준

`트랜잭션의 격리 수준(isolation level)`이란 동시에 여러 트랜잭션이 처리될 때, **특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회되는 데이터를 볼 수 있도록 허용할지 말지를 결정하는 것**이다.

데이터베이스의 격리 수준을 이야기하면 항상 함께 언급되는 3가지 부정합 문제점이 있다.

|                 |  DIRTY READ   | NON-REPEATABLE READ |           PHANTOM READ            |
| :-------------: | :-----------: | :-----------------: | :-------------------------------: |
| READ UNCOMMITED |     발생      |        발생         |               발생                |
|  READ COMMITED  | 발생하지 않음 |        발생         |               발생                |
| REPEATABLE READ | 발생하지 않음 |    발생하지 않음    | 발생 (InnoDB에서는 발생하지 않음) |
|  SERIALIZABLE   | 발생하지 않음 |    발생하지 않음    |           발생하지 않음           |

일반적인 온라인 서비스 용도의 데이터베이스는 READ COMMITED와 REPEATABLE READ 둘 중에서 하나를 사용한다.

## 4.5.1 READ UNCOMMITED

각 트랜잭션의 변경 내용이 COMMIT이나 ROLLBACK 여부에 상관없이 다른 트랜잭션에서 보인다.  
어떤 트랜잭션에서 처리한 작업이 완료되지 않았는데도 다른 트랜잭션에서 볼 수 있게 되는 현상을 `더티 리드(Dirty read)`라 하고, 더티 리드가 허용되는 격리 수준이 READ UNCOMMITED다.  
READ UNCOMMITED는 RDBMS 표준에서는 트랜잭션의 격리 수준으로 인정하지 않을 정도로 정합성에 문제가 많은 격리 수준이다.

## 4.5.2 READ COMMITED

오라클 DBMS에서 기본적으로 사용되는 격리 수준이며, 온라인 서비스에서 가장 많이 선택되는 격리 수준이다.  
트랜잭션에서 데이터를 변경했더라도 COMMIT이 완료된 데이터만 다른 트랜잭션에서 조회할 수 있다.  
READ COMMITED 격리 수준에서도 하나의 트랜잭션에서 동일 데이터를 여러 번 읽을 때 `NON-REPEATABLE READ`라는 부정합 문제가 있을 수 있다.

## 4.5.3 REPEATABLE READ

MySQL의 InnoDB 스토리지 엔진에서 기본적으로 사용되는 격리 수준이다.  
바이너리 로그를 가진 MySQL의 장비에서는 최소 REPEATABLE READ 격리 수준 이상을 사용해야 한다.  
InnoDB는 트랜잭션이 ROLLBACK 될 가능성에 대비해 변경하기 전 언두(Undo) 공간에 백업해두고 실제 레코드 값을 변경한다.  
이러한 변경 방식을 `MVCC(Multi Version Concurrency Control)`라고 한다.  
READ COMMITED도 MVCC를 이용해 COMMIT 되기 전의 데이터를 보여주지만, REPEATABLE READ와 READ COMMITED의 차이는 언두 영역에 백업된 레코드의 여러 버전 가운데 몇 번째 이전 버전까지 찾아서 들어가야 하는지에 있다.  
트랜잭션 내에서 실행되는 모든 SELECT 쿼리는 트랜잭션 번호가 자신의 트랜잭션 번호보다 작은(이전에 실행된) 트랜잭션 번호에서 변경된 것만 보게 한다.

모든 InnoDB의 트랜잭션은 순차적으로 증가하는 고유한 트랜잭션 번호를 가지며, 언두 영역에 백업된 모든 레코드는 변경을 발생시킨 트랜잭션의 번호가 포함되어 있다.  
그리고 언두 영역의 백업된 데이터는 InnoDB 스토리지 엔진이 불필요하다고 판단하는 시점에 주기적으로 삭제한다.  
REPEATABLE READ 격리 수준에서는 MVCC를 보장하기 위해 실행 중인 트랜잭션 가운데 가장 오래된 트랜잭션 번호보다 트랜잭션 번호가 앞선 언두 영역의 데이터는 삭제할 수가 없다.

REPEATABLE READ 격리 수준에서도 다른 트랜잭션에서 수행한 변경 작업에 의해 레코드가 보였다가 안 보였다가 하는 부정합 현상인 `PHANTOM READ(또는 PHANTOM ROW)` 현상이 발생할 수 있다.  
레코드에 쓰기 잠금이 필요한 쿼리를 실행할 때, 언두 레코드에는 잠금을 걸 수 없어서 언두 영역의 변경 전 데이터를 가져오는 것이 아니라 현재 레코드의 값을 가져오기 때문에 PHANTOM READ 현상이 발생한다.

## 4.5.4 SERIALIZABLE

가장 단순한 격리 수준이지만 가장 엄격한 격리 수준이다.  
InnoDB 테이블에서 기본적으로 순수한 SELECT 작업(INSERT ... SELECT ... 또는 CREATE TABLE ... AS SELECT ... 가 아닌)은 아무런 레코드 잠금도 설정하지 않고 실행된다.  
하지만 트랜잭션 격리 수준이 SERIALIZABLE로 설정되면 읽기 작업도 공유 잠금(읽기 잠금)을 획득해야만 하며, 동시에 다른 트랜잭션은 그러한 레코드를 변경하지 못하게 된다.
