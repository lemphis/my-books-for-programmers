# 7.8 국소적 상속 확장 클래스 사용 Introduce Local Extension

_사용 중인 서버 클래스에 여러 개의 메서드를 추가해야 하는데 클래스를 수정할 수 없을 땐 새 클래스를 작성하고 그 안에 필요한 여러 개의 메서드를 작성하자._  
_이 상속 확장 클래스를 원본 클래스의 하위 클래스나 래퍼 클래스로 만들자._

## 동기

클래스 제작자도 신이 아니므로 개발자에게 필요한 메서드가 전부 든 클래스를 만드는 건 불가능에 가깝다.  
원본 클래스를 수정할 수 있다면야 당연히 필요한 메서드를 추가하는 것이 최선의 방법이겠지만, 원본 클래스를 수정하는 것이 불가능할 때가 대부분이다.  
필요한 메서드가 한두 개일 때는 [외래 클래스에 메서드 추가](../CHAPTER%2007%20객체%20간의%20기능%20이동/7.7.md) 기법을 실시하면 된다.  
하지만 필요한 메서드 수가 세 개 이상이면 그 기법으로는 무리다.  
그러므로 필요한 메서드들을 적당한 곳에 모아둬야 한다.  
이렇게 하는 확실한 방법은 보편적인 객체지향 기법인 하위 클래스화(subclassing)와 래퍼화(wrapping)를 실시하는 것이다.
이렇게 만든 하위 클래스와 래퍼 클래스를 국소적 상속 확장 클래스(local extension)라고 부른다.  
국소적 상속 확장 클래스는 별도의 클래스지만 상속 확장하는 클래스의 하위 타입이다.  
따라서 국소적 상속 확장 클래스는 원본 클래스의 모든 기능도 사용 가능하면서 추가 기능도 들어 있다.  
원본 클래스를 사용할 것이 아니라 국소적 상속 확장 클래스를 인스턴스화해서 사용하자.

국소적 상속 확장 클래스를 사용하면 메서드와 데이터가 체계적인 단위로 묶여야 한다는 원칙이 저절로 지켜진다.  
필요한 메서드가 국소적 상속 확장 클래스 안에 있어야 함에도 불구하고 엉뚱한 클래스에 들어 있는 상태로 방치하면 그 엉뚱한 클래스들이 복잡해져서 그 메서드는 재사용하기 힘들어진다.

## 방법

1. 상속 확장 클래스를 작성한 후 원본 클래스의 하위 클래스나 래퍼 클래스로 만들자.
2. 상속 확장 클래스에 변환 생성자 메서드를 작성하자.
   - 생성자는 원본 클래스를 인자로 받는다. 하위 클래스의 경우 적절한 상위 클래스 생성자를 호출하며, 래퍼 클래스의 경우 대리 필드에 그 인자를 할당한다.
3. 상속 확장 클래스에 새 기능을 추가하자.
4. 필요한 위치마다 원본 클래스를 상속 확장 클래스로 수정하자.
5. 이 클래스용으로 정의된 외래 메서드를 전부 상속 확장 클래스로 옮기자.

## 예제

```java
class MfDateWrap {
    private Date _original;

    public MfDateWrap(String dateString) {
        _original = new Date(dateString);
    }

    public MfDateWrap(Date arg) {
        _original = arg;
    }

    public int getYear() {
        return _original.getYear();
    }

    public int getMonth() {
        return _original.getMonth();
    }

    public int getDate() {
        return _original.getDate();
    }

    Date nextDay() {
        return new Date(getYear(), getMonth(), getDate() + 1);
    }
}
```
