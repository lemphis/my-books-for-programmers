# 6.3 응용 서비스의 구현

응용 서비스는 표현 영역과 도메인 영역을 연결하는 매개체 역할을 하는데 이는 **디자인 패턴에서 파사드(facade)와 같은 역할**을 한다.

## 6.3.1 응용 서비스의 크기

응용 서비스 자체의 구현은 어렵지 않지만 몇 가지 생각할 거리가 있다.  
그중 하나가 응용 서비스의 크기다.  
응용 서비스는 회원 가입하기, 회원 탈퇴하기, 회원 암호 변경하기와 같은 기능을 구현하기 위해 도메인 모델을 사용하게 된다.  
이 경우 응용 서비스는 보통 다음의 두 가지 방법 중 한 가지 방식으로 구현한다.

- 한 응용 서비스 클래스에 도메인의 모든 기능 구현하기
  - 동일한 로직을 위한 코드 중복을 제거하기 쉬움
  - 한 서비스 클래스의 크기(코드 줄 수)가 커짐
  - 연관성이 적은 코드가 한 클래스에 함께 위치할 가능성이 높아져 결과적으로 관련 없는 코드가 뒤섞여 코드를 이해하는 데 방해됨
- 구분되는 기능별로 응용 서비스 클래스를 따로 구현하기
  - 한 응용 서비스 클래스에서 한 개 내지 2~3개의 기능을 구현함
  - 클래스 개수는 많아지지만 한 클래스에 관련 기능을 모두 구현하는 것과 비교해서 코드 품질을 일정 수준으로 유지하는 데 도움이 됨
  - 각 클래스 별로 필요한 의존 객체만 포함하므로 다른 기능을 구현한 코드에 영향을 받지 않음
  - 각 기능마다 동일한 로직을 구현할 경우 여러 클래스에 중복해서 동일한 코드를 구현할 가능성이 있음

여러 클래스에 중복해서 동일한 코드를 구현해야 하는 경우는 다음과 같이 별도 클래스에 로직을 구현해서 코드가 중복되는 것을 방지할 수 있다.

```java
// 각 응용 서비스에서 공통되는 로직을 별도 클래스로 구현
public final class MemberServiceHelper {
    public static Member findExistingMember(MemberRepository repo, String memberId) {
        Member member = memberRepository.findById(memberId);
        if (member == null) {
            throw new NoMemberException(memberId);
            return member;
        }
    }
}

// 공통 로직을 제공하는 메서드를 응용 서비스에서 사용
import static com.myshop.member.application.MemberServiceHelper .*;

public class ChangePasswordService {
    private MemberRepository memberRepository;

    public void changePassword(String memberId, String curPw, String newPw) {
        Member member = findExistingMember(memberRepository, memberId);
        member.changePassword(curPw, newPw);
    }
}
```

한 도메인과 관련된 기능을 하나의 응용 서비스 클래스에서 모두 구현하는 방식보다 **구분되는 기능을 별도의 서비스 클래스로 구분하는 방식을 사용**한다.

## 6.3.2 응용 서비스의 인터페이스와 클래스

응용 서비스를 구현할 때 논쟁이 될 만한 것이 인터페이스가 필요한 지이다.

인터페이스가 필요한 몇 가지 상황이 있는데 그중 하나는 구현 클래스가 여러 개인 경우다.  
구현 클래스가 다수 존재하거나 런타임에 구현 객체를 교체해야 할 때 인터페이스를 유용하게 사용할 수 있다.  
그런데 응용 서비스는 런타임에 교체하는 경우가 거의 없고 한 응용 서비스의 구현 클래스가 두 개인 경우도 드물다.

이런 이유로 인터페이스와 클래스를 따로 구현하면 소스 파일만 많아지고 구현 클래스에 대한 간접 참조가 증가해서 전체 구조가 복잡해진다.  
따라서 **인터페이스가 명확하기 필요하기 전까지는 응용 서비스에 대한 인터페이스를 작성하는 것이 좋은 선택이라고 볼 수는 없다**.

## 6.3.3 메서드 파라미터와 값 리턴

응용 서비스가 제공하는 메서드는 도메인을 이용해서 사용자가 요구한 기능을 실행하는 데 필요한 값을 파라미터로 전달받아야 한다.  
필요한 각 값을 개별 파라미터로 전달받을 수도 있고, 값 전달을 위해 별도 데이터 클래스를 만들어 전달받을 수도 있다.

**스프링 MVC와 같은 웹 프레임워크는 웹 요청 파라미터를 자바 객체로 변환하는 기능을 제공**하므로 **응용 서비스에 데이터로 전달할 요청 파라미터가 두 개 이상 존재하면 데이터 전달을 위한 별도 클래스를 사용**하는 것이 편리하다.

응용 서비스의 결과를 표현 영역에서 사용해야 하면 응용 서비스 메서드의 결과로 필요한 데이터를 리턴한다.  
결과 데이터가 필요한 대표적인 예가 식별자다.  
예를 들어 온라인 쇼핑몰은 주문 후 주문 상세 내역을 볼 수 있는 링크를 바로 보여주는데, 이 링크를 제공하려면 방금 요청한 주문의 번호를 알아야 한다.

응용 서비스에서 애그리거트 객체를 그대로 리턴할 수도 있다.  
응용 서비스에서 애그리거트 자체를 리턴하면 코딩은 편할 수 있지만 도메인의 로직 실행을 응용 서비스와 표현 영역 두 곳에서 할 수 있게 된다.  
이것은 기능 실행 로직을 응용 서비스와 표현 영역에 분산시켜 코드의 응집도를 낮추는 원인이 된다.  
애그리거트의 상태를 변경하는 응용 서비스가 애그리거트를 리턴해도 애그리거트가 제공하는 기능을 컨트롤러나 뷰 코드에서 실행하면 안 된다는 규칙을 정할 수 있겠지만, 그보다는 **응용 서비스는 표현 영역에서 필요한 데이터만 리턴하는 것이 기능 실행 로직의 응집도를 높이는 확실한 방법**이다.

## 6.3.4 표현 영역에 의존하지 않기

응용 서비스의 파라미터 타입을 결정할 때 주의할 점은 **표현 영역과 관련된 타입을 사용하면 안 된다**는 점이다.  
응용 서비스에서 표현 영역에 대한 의존이 발생하면 응용 서비스만 단독으로 테스트하기가 어려워진다.  
게다가 표현 영역의 구현이 변경되면 응용 서비스의 구현도 함께 변경돼야 하는 문제도 발생한다.  
또한 응용 서비스가 표현 영역의 역할까지 대신하는 상황이 벌어질 수도 있다.

위와 같은 문제가 발생하지 않도록 하려면 철저하게 응용 서비스가 표현 영역의 기술을 사용하지 않도록 해야 한다.  
이를 지키기 위한 가장 쉬운 방법이 서비스 메서드의 파라미터와 리턴 타입으로 표현 영역의 구현 기술을 사용하지 않는 것이다.

## 6.3.5 트랜잭션 처리

트랜잭션을 관리하는 것은 응용 서비스의 중요한 역할이다.

스프링과 같은 프레임워크가 제공하는 트랜잭션 관리 기능을 이용하면 쉽게 트랜잭션을 처리할 수 있다.

프레임워크가 제공하는 트랜잭션 기능을 적극 사용하는 것이 좋다.  
프레임워크가 제공하는 규칙을 따르면 간단한 설정만으로 트랜잭션을 시작하여 커밋하고 익셉션이 발생하면 롤백할 수 있다.  
스프링은 @Transactional이 적용된 메서드가 RuntimeException을 발생시키면 트랜잭션을 롤백하고 그렇지 않으면 커밋하므로 이 규칙에 따라 코드를 작성하면 트랜잭션 처리 코드를 간결하게 유지할 수 있다.
