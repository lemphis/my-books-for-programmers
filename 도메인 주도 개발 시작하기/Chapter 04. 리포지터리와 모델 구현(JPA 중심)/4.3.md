# 4.3 매핑 구현

## 4.3.1 엔티티와 밸류 기본 매핑 구현

애그리거트와 JPA 매핑을 위한 기본 규칙은 다음과 같다.

- 애그리거트 루트는 엔티티이므로 @Entity로 매핑 설정한다.

헌 테이블에 엔티티와 밸류 데이터가 같이 있다면

- 밸류는 @Embeddable로 매핑 설정한다.
- 밸류 타입 프로퍼티는 @Embedded로 매핑 설정한다.

@Embeddable 타입에 설정한 칼럼 이름과 실제 칼럼 이름이 다르면 @AttribureOverrides 애너테이션을 이용해서 매핑할 칼럼 이름을 변경한다.

## 4.3.2 기본 생성자

엔티티와 밸류의 생성자는 객체를 생성할 때 필요한 것을 전달받는다.  
예를 들어 Receiver 밸류 타입은 생성 시점에 수취인 이름과 연락처를 생성자 파라미터로 전달받는다.  
Receiver가 불변 타입이면 생성 시점에 필요한 값을 모두 전달받으므로 값을 변경하는 set 메서드를 제공하지 않는다.  
이는 Receiver 클래스에 기본 생성자를 추가할 필요가 없다는 것을 의미한다.

하지만 **JPA에서 @Entity와 @Embeddable로 클래스를 매핑하려면 기본 생성자를 제공**해야 한다.  
DB에서 데이터를 읽어와 매핑된 객체를 생성할 때 기본 생성자를 사용해서 객체를 생성하기 때문이다.  
이런 기술적인 제약으로 Receiver와 같은 불변 타입은 기본 생성자가 필요 없음에도 불구하고 기본 생성자를 추가해야 한다.

기본 생성자는 JPA 프로바이더가 객체를 생성할 때만 사용한다.  
기본 생성자를 다른 코드에서 사용하면 값이 없는 온전하지 못한 객체를 만들게 된다.  
이런 이유로 **다른 코드에서 기본 생성자를 사용하지 못하도록 protected로 선언**한다.

## 4.3.3 필드 접근 방식 사용

JPA는 필드와 메서드의 두 가지 방식으로 매핑을 처리할 수 있다.  
메서드 방식을 사용하려면 프로퍼티를 위한 get/set 메서드를 구현해야 한다.  
엔티티에 프로퍼티를 위한 공개 get/set 메서드를 추가하면 도메인의 의도가 사라지고 객체가 아닌 데이터 기반으로 엔티티를 구현할 가능성이 높아진다.  
특히 set 메서드는 내부 데이터를 외부에서 변경할 수 있는 수단이 되기 때문에 캡슐화를 깨는 원인이 될 수 있다.

엔티티가 객체로서 제 역할을 하려면 외부에 set 메서드 대신 의도가 잘 드러나는 기능을 제공해야 한다.  
밸류 타입을 불변으로 구현하려면 set 메서드 자체가 필요 없는데 JPA의 구현 방식 때문에 공개 set 메서드를 추가하는 것도 좋지 않다.

객체가 제공할 기능 중심으로 엔티티를 구현하게끔 유도하려면 **JPA 매핑 처리를 프로퍼티 방식이 아닌 필드 방식으로 선택**해서 불필요한 get/set 메서드를 구현하지 말아야 한다.

> JPA 구현체인 하이버네이트는 @Access를 이용해서 명시적으로 접근 방식을 지정하지 않으면 @Id나 @EmbeddedId가 어디에 위치했느냐에 따라 접근 방식을 결정한다.  
> @Id나 @EmbeddedId가 필드에 위치하면 필드 접근 방식을 선택하고 get 메서드에 위치하면 메서드 접근 방식을 선택한다.

## 4.3.4 AttributeConverter를 이용한 밸류 매핑 처리

int, long, String, LocalDate와 같은 타입은 DB 테이블의 한 개 칼럼에 매핑된다.  
이와 비슷하게 밸류 타입의 프로퍼티를 한 개 칼럼에 매핑해야 할 때도 있다.

두 개 이상의 프로퍼티를 가진 밸류 타입을 한 개 칼럼에 매핑하려면 `AttributeConverter`를 사용하면 된다.  
AttributeConverter는 다음과 같이 밸류 타입과 칼럼 데이터 간의 변환을 처리하기 위한 기능을 정의하고 있다.

```java
public interface AttributeConverter<X,Y> {
    public Y convertToDatabaseColumn (X attribute);
    public X convertToEntityAttribute (Y dbData);
}
```

타입 파라미터 X는 밸류 타입이고 Y는 DB 타입이다.  
convertToDatabaseColumn() 메서드는 밸류 타입을 DB 칼럼 값으로 변환하는 기능을 구현하고 convertToEntityAttribute() 메서드는 DB 칼럼 값을 밸류로 변환하는 기능을 구현한다.

AttributeConverter 인터페이스를 구현한 클래스는 @Converter 애너테이션을 적용한다.  
@Converter 애너테이션의 autoApply 속성을 true로 지정하면 모델에 출현하는 모든 밸류 타입의 프로퍼티에 대해 Converter를 자동으로 적용하고, false로 지정하면(기본값) 프로퍼티 값을 변환할 때 사용할 Converter를 직접 지정해야 한다.

## 4.3.5 밸류 컬렉션: 별도 테이블 매핑

밸류 컬렉션을 별도 테이블로 매핑할 때는 @ElementCollection과 @CollectionTable을 함께 사용한다.  
@OrderColumn 애너테이션을 이용해서 지정한 칼럼에 리스트의 인덱스 값을 저장한다.

## 4.3.6 밸류 컬렉션: 한 개 칼럼 매핑

밸류 컬렉션을 별도 테이블이 아닌 한 개 칼럼에 저장해야 할 때가 있다.  
예를 들어 도메인 모델에는 이메일 주소 목록을 Set으로 보관하고 DB에는 한 개 칼럼에 콤마로 구분해서 저장해야 할 때가 있다.  
이때 AttributeConverter를 사용하면 밸류 컬렉션을 한 개 칼럼에 쉽게 매핑할 수 있다.  
단 AttributeConverter를 사용하려면 밸류 컬렉션을 표현하는 새로운 밸류 타입을 추가해야 한다.

## 4.3.7 밸류를 이용한 ID 매핑

식별자라는 의미를 부각시키기 위해 식별자 자체를 밸류 타입으로 만들 수도 있다.  
밸류 타입을 식별자로 매핑하려면 @Id 대신 @EmbeddedId 애너테이션을 사용해야 한다.

JPA에서 식별자 타입은 Serializable 타입이어야 하므로 식별자로 사용할 밸류 타입은 Serializable 인터페이스를 상속받아야 한다.

밸류 타입으로 식별자를 구현할 때 얻을 수 있는 장점은 **식별자에 기능을 추가**할 수 있다는 점이다.

JPA는 내부적으로 엔티티를 비교할 목적으로 equals() 메서드와 hashcode() 값을 사용하므로 식별자로 사용할 밸류 타입은 이 두 메서드를 알맞게 구현해야 한다.

## 4.3.8 별도 테이블에 저장하는 밸류 매핑

**애그리거트에서 루트 엔티티를 뺀 나머지 구성요소는 대부분 밸류**이다.  
루트 엔티티 외에 또 다른 엔티티가 있다면 진짜 엔티티인지 의심해 봐야 한다.  
단지 별도 테이블에 데이터를 저장한다고 해서 엔티티인 것은 아니다.

밸류가 아니라 엔티티가 확실하다면 해당 엔티티가 다른 애그리거트는 아닌지 확인해야 한다.  
특히 자신만의 라이프 사이클을 갖는다면 구분되는 애그리거트일 가능성이 높다.

**애그리거트가 속한 객체가 밸류인지 엔티티인지 구분하는 방법은 고유 식별자를 갖는지를 확인**하는 것이다.  
하지만 식별자를 찾을 때 매핑되는 테이블의 식별자를 애그리거트 구성요소의 식별자와 동일한 것으로 착각하면 안 된다.  
별도 테이블로 저장하고 테이블에 PK가 있다고 해서 테이블과 매핑되는 애그리거트 구성요소가 항상 고유 식별자를 갖는 것은 아니기 때문이다.

밸류를 매핑한 테이블을 지정하기 위해 @SecondaryTable과 @AttributeOverride를 사용한다.  
@SecondaryTable을 이용하면 조회 시 두 테이블을 조인해서 데이터를 조회한다.

## 4.3.9 밸류 컬렉션을 @Entity로 매핑하기

개념적으로 밸류인데 구현 기술의 한계나 팀 표준 때문에 @Entity를 사용해야 할 때도 있다.  

JPA는 @Embeddedable 타입의 클래스 상속 매핑을 지원하지 않는다.  
상속 구조를 갖는 밸류 타입을 사용하려면 @Embeddedable 대신 @Entity를 이용해서 상속 매핑으로 처리해야 한다.  
밸류 타입을 @Entity로 매핑하므로 식별자 매핑을 위한 필드도 추가해야 한다.  
또한 구현 클래스를 구분하기 위한 타입 식별(discriminator) 칼럼을 추가해야 한다.

## 4.3.10 ID 참조와 조인 테이블을 이용한 단방향 M-N 매핑

3장에서 애그리거트 간 집합 연관은 성능 상의 이유로 피해야 한다고 했다.  
그럼에도 불구하고 요구사항을 구현하는 데 집합 연관을 사용하는 것이 유리하다면 ID 참조를 이용한 단방향 집합 연관을 적용해 볼 수 있다.
