# 4.4 애그리거트 로딩 전략

JPA 매핑을 설정할 때 항상 기억해야 할 점은 애그리거트에 속한 객체가 모두 모여야 완전한 하나가 된다는 것이다.

조회 시점에서 애그리거트를 완전한 상태가 되도록 하려면 애그리거트 루트에서 연관 매핑의 조회 방식을 즉시 로딩(FetchType.EAGER)으로 설정하면 된다.  
즉시 로딩 방식으로 설정하면 애그리거트 루트를 로딩하는 시점에 애그리거트에 속한 모든 객체를 함께 로딩할 수 있는 장점이 있지만 이것이 항상 좋은 것은 아니다.  
특히 컬렉션에 대해 로딩 전략을 FetchType.EAGER로 설정하면 오히려 즉시 로딩 방식이 문제가 될 수 있다.  
FetchType.EAGER로 설정하고 애그리거트 루트를 조회하면 관련된 모든 테이블에 카타시안(Cartesian) 조인을 사용하고 이는 쿼리 결과에 중복을 발생시킨다.  
물론 하이버네이트가 중복된 데이터를 알맞게 제거해서 객체로 적절하게 변환해 주지만 애그리거트가 커지면 문제가 될 수 있다.  
보통 조회 성능 때문에 즉시 로딩 방식을 사용하지만 이렇게 조회되는 데이터 개수가 많아지면 즉시 로딩 방식을 사용할 때 성능(실행 빈도, 트래픽, 지연 로딩 시 실행 속도 등)을 검토해 봐야 한다.

애그리거트는 개념적으로 하나여야 한다.  
하지만 루트 엔티티를 로딩하는 시점에 애그리거트에 속한 객체를 모두 로딩해야 하는 것은 아니다.  
애그리거트가 완전해야 하는 이유는 두 가지 정도로 생각해 볼 수 있다.

- 상태를 변경하는 기능을 실행할 때 애그리거트 상태가 완전해야 하기 때문
- 표현 영역에서 애그리거트의 상태 정보를 보여줄 때 필요하기 때문

이 중 두 번째는 별도의 조회 전용 기능과 모델을 구현하는 방식을 사용하는 것이 더 유리하기 때문에 애그리거트의 완전한 로딩과 관련된 문제는 상태 변경과 더 관련이 있다.  
상태 변경 기능을 실행하기 위해 조회 시점에 즉시 로딩을 이용해서 애그리거트를 완전한 상태로 로딩할 필요는 없다.  
JPA는 트랜잭션 범위 내에서 지연 로딩을 허용하기 때문에 실제로 상태를 변경하는 시점에 필요한 구성요소만 로딩해도 문제가 되지 않는다.  
게다가 일반적인 애플리케이션은 상태 변경 기능을 실행하는 빈도보다 조회 기능을 실행하는 빈도가 훨씬 높다.  
그러므로 상태 변경을 위해 지연 로딩을 사용할 때 발생하는 추가 쿼리로 인한 실행 속도 저하는 보통 문제가 되지 않는다.

이런 이유로 애그리거트 내의 모든 연관을 즉시 로딩으로 설정할 필요는 없다.  
지연 로딩은 동작 방식이 항상 동일하기 때문에 즉시 로딩처럼 경우의 수를 따질 필요가 없다는 장점이 있다(즉시 로딩 설정은 @Entity나 @Embeddable에 대해 다르게 동작하고, JPA 프로바이더에 따라 구현 방식이 다를 수도 있다).  
물론 지연 로딩은 즉시 로딩보다 쿼리 실행 횟수가 많아질 가능성이 더 높다.  
따라서 무조건 즉시 로딩이나 지연 로딩으로만 설정하기보다는 **애그리거트에 맞게 즉시 로딩과 지연 로딩을 선택**해야 한다.
