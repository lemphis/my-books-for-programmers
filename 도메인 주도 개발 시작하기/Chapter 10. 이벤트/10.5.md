# 10.5 비동기 이벤트 처리

회원 가입 신청을 하면 검증을 위해 이메일을 보내는 서비스가 많다.  
회원 가입 신청을 하자마자 바로 내 메일함에 검증 이메일이 도착할 필요는 없다.  
이메일이 몇 초 뒤에 도착해도 문제 되지 않는다.  
10~20초 후에 이메일이 도착해도 되고, 심지어 이메일을 받지 못하면 다시 받을 수 있는 기능을 이용하면 된다.

비슷하게 주문을 취소하자마자 바로 결제를 취소하지 않아도 된다.  
수십 초 내에 결제 취소가 이루어지면 된다.  
며칠 뒤에 결제가 확실하게 되면 문제없을 때도 있다.

이렇게 우리가 구현해야 할 것 중에서 'A 하면 이어서 B 하라'라는 내용을 담고 있는 요구사항은 실제로 'A 하면 최대 언제까지 B 하라'인 경우가 많다.  
즉, 일정 시간 안에만 후속 조치를 처리하면 되는 경우가 적지 않다.  
게다가 'A 하면 이어서 B 하라'라는 요구사항에서 B를 하는 데 실패하면 일정 간격으로 재시도를 하거나 수동 처리를 해도 상관없는 경우가 있다.  
앞의 이메일 인증 예가 이에 해당한다.

'A 하면 일정 시간 안에 B 하라'라는 요구사항에서 'A 하면'은 이벤트로 볼 수도 있다.  
'회원 가입 신청을 하면 인증 이메일을 보내라'라는 요구사항에서 '회원 가입 신청을 하면'은 '회원 가입 신청함 이벤트'로 볼 수 있다.  
따라서 '인증 이메일을 보내라' 기능은 '회원 가입 신청함 이벤트'를 처리하는 핸들러에서 보낼 수 있다.

앞서 말했듯 'A 하면 이어서 B 하라'라는 요구사항 중에서 'A 하면 최대 언제까지 B 하라'로 바꿀 수 있는 요구사항은 이벤트를 비동기로 처리하는 방식으로 구현할 수 있다.  
다시 말해서 A 이벤트가 발생하면 별도 스레드로 B를 수행하는 핸들러를 실행하는 방식으로 요구사항을 구현할 수 있다.

이벤트를 비동기로 구현할 수 있는 방법은 다양한데, 이 절에서는 다음 네 가지 방식으로 비동기 이벤트 처리를 구현하는 방법에 대해 살펴보자.

- 로컬 핸들러를 비동기로 실행하기
- 메시지 큐를 사용하기
- 이벤트 저장소와 이벤트 포워더 사용하기
- 이벤트 저장소와 이벤트 제공 API 사용하기

네 가지 방식은 각자 구현하는 방식도 다르고 그에 따른 장점과 단점이 있다.

## 10.5.1 로컬 핸들러 비동기 실행

이벤트 핸들러를 비동기로 실행하는 방법은 이벤트 핸들러를 별도 스레드로 실행하는 것이다.  
스프링이 제공하는 `@Async` 애너테이션을 사용하면 손쉽게 비동기로 이벤트 핸들러를 실행할 수 있다.  
이를 위해 다음 두 가지만 하면 된다.

- @EnableAsync 애너테이션을 이용해서 비동기 기능을 활성화한다.
- 이벤트 핸들러 메서드에 @Async 애너테이션을 붙인다.

## 10.5.2 메시징 시스템을 이용한 비동기 구현

비동기로 이벤트를 처리해야 할 때 사용하는 또 다른 방법은 카프카(Kafka)나 래빗MQ(RabbitMQ)와 같은 메시징 시스템을 사용하는 것이다.  
이벤트가 발생하면 이벤트 디스패처는 이벤트를 메시지 큐에 보낸다.  
메시지 큐는 이벤트를 메시지 리스너에게 전달하고, 메시지 리스너는 알맞은 이벤트 핸들러를 이용해서 이벤트를 처리한다.  
이때 이벤트를 메시지 큐에 저장하는 과정과 메시지 큐에서 이벤트를 읽어와 처리하는 과정은 별도 스레드나 프로세스로 처리된다.

필요하다면 이벤트를 발생시키는 도메인 기능과 메시지 큐에 이벤트를 저장하는 절차를 한 트랜잭션으로 묶어야 한다.  
도메인 기능을 실행한 결과를 DB에 반영하고 이 과정에서 발생한 이벤트를 메시지 큐에 저장하는 것을 같은 트랜잭션 범위에서 실행하려면 글로벌 트랜잭션이 필요하다.

글로벌 트랜잭션을 사용하면 안전하게 이벤트를 메시지 큐에 전달할 수 있는 장점이 있지만 반대로 글로벌 트랜잭션으로 인해 성능이 떨어지는 단점도 있다.  
글로벌 트랜잭션을 지원하지 않는 메시징 시스템도 있다.

메시지 큐를 사용하면 보통 이벤트를 발생시키는 주체와 이벤트 핸들러가 별도 프로세스에서 동작한다.  
이것은 이벤트 발생 JVM과 이벤트 처리 JVM이 다르다는 것을 의미한다.  
물론 한 JVM에서 이벤트 발생 주체와 이벤트 핸들러가 메시지 큐를 이용해서 이벤트를 주고받을 수 있지만, 동일 JVM에서 비동기 처리를 위해 메시지 큐를 사용하는 것은 시스템을 복잡하게 만들 뿐이다.

래빗MQ처럼 많이 사용하는 메시징 시스템은 글로벌 트랜잭션 지원과 함께 클러스터와 고가용성을 지원하기 때문에 안정적으로 메시지를 전달할 수 있는 장점이 있다.  
또한 다양한 개발 언어와 통신 프로토콜을 지원하고 있다.  
메시지를 전달하기 위해 많이 사용되는 것 중 카프카도 있다.  
카프카는 글로벌 트랜잭션을 지원하진 않지만 다른 메시징 시스템에 비해 높은 성능을 보여준다.

## 10.5.3 이벤트 저장소를 통한 이벤트 처리

이벤트를 비동기로 처리하는 또 다른 방법은 이벤트를 일단 DB에 저장한 뒤에 별도 프로그램을 이용해서 이벤트 핸들러에 전달하는 것이다.

이벤트가 발생하면 핸들러는 스토리지에 이벤트를 저장한다.  
포워더는 주기적으로 이벤트 저장소에서 이벤트를 가져와 이벤트 핸들러를 실행한다.  
포워더는 별도 스레드를 이용하기 때문에 이벤트 발행과 처리가 비동기로 처리된다.

이 방식은 도메인의 상태와 이벤트 저장소로 동일한 DB를 사용한다.  
즉, 도메인의 상태 변화와 이벤트 저장이 로컬 트랜잭션으로 처리된다.  
이벤트를 물리적 저장소에 보관하기 때문에 핸들러가 이벤트 처리에 실패할 경우 포워더는 다시 이벤트 저장소에서 이벤트를 읽어와 핸들러를 실행하면 된다.

이벤트 저장소를 이용한 두 번째 방법은 이벤트를 외부에 제공하는 API를 사용하는 것이다.  
API 방식과 포워더 방식의 차이점은 이벤트를 전달하는 방식에 있다.  
포워더 방식이 포워더를 통해서 이벤트를 외부에 전달한다면, API 방식은 외부 핸들러가 API 서버를 통해 이벤트 목록을 가져간다.  
포워더 방식은 이벤트를 어디까지 처리했는지 추적하는 역할이 포워더에 있다면 API 방식에서는 이벤트 목록을 요구하는 외부 핸들러가 자신이 어디까지 이벤트를 처리했는지 기억해야 한다.
