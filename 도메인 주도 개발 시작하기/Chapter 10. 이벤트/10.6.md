# 10.6 이벤트 적용 시 추가 고려 사항

이벤트를 구현할 때 추가로 고려할 점이 있다.

첫 번째는 이벤트 소스를 이벤트 클래스에 추가할지에 대한 여부이다.  
'Order가 발생시킨 이벤트만 조회하기'처럼 특정 주체가 발생시킨 이벤트만 조회하는 기능을 구현하려면 이벤트에 발생 주체 정보를 추가해야 한다.

두 번째는 포워더에서 전송 실패를 얼마나 허용할 것이냐에 대한 것이다.  
포워더는 이벤트 전송에 실패하면 실패한 이벤트부터 다시 읽어와 전송을 시도한다.  
그런데 특정 이벤트에서 계속 전송에 실패하면 그 이벤트 때문에 나머지 이벤트를 전송할 수 없게 된다.  
따라서 포워더를 구현할 때는 실패한 이벤트의 재전송 횟수 제한을 두어야 한다.  
예를 들어 동일 이벤트를 전송하는 데 3회 실패했다면 해당 이벤트는 생략하고 다음 이벤트로 넘어간다는 등의 정책이 필요하다.

> 처리에 실패한 이벤트를 생략하지 않고 별도 실패용 DB나 메시지 큐에 저장하기도 한다.  
> 처리에 실패한 이벤트를 물리적인 저장소에 남겨두면 이후 실패 이유 분석이나 후처리에 도움이 된다.

세 번째는 이벤트 손실에 대한 것이다.  
이벤트 발생과 이벤트 저장을 한 트랜잭션으로 처리하기 때문에 트랜잭션에 성공하면 이벤트가 저장소에 보관된다는 것을 보장할 수 있다.  
반면에 로컬 핸들러를 이용해서 이벤트를 비동기로 처리할 경우 이벤트 처리에 실패하면 이벤트를 유실하게 된다.

네 번째는 이벤트 순서에 대한 것이다.  
이벤트 발생 순서대로 외부 시스템에 전달해야 할 경우, 이벤트 저장소를 사용하는 것이 좋다.  
이벤트 저장소는 저장소에 이벤트를 발생 순서대로 저장하고 그 순서대로 이벤트 목록을 제공하기 때문이다.  
반면에 메시징 시스템은 사용 기술에 따라 이벤트 발생 순서와 메시지 전달 순서가 다를 수도 있다.

다섯 번째는 이벤트 재처리에 대한 것이다.  
동일한 이벤트를 다시 처리해야 할 때 이벤트를 어떻게 할지 결정해야 한다.  
가장 쉬운 방법은 마지막으로 처리한 이벤트의 순번을 기억해 두었다가 이미 처리한 순번의 이벤트가 도착하면 해당 이벤트를 처리하지 않고 무시하는 것이다.  
예를 들어 회원 가입 신청 이벤트가 처음 도착하면 이메일을 발송하는데, 동일한 순번의 이벤트가 다시 들어오면 이메일을 발송하지 않는 방식으로 구현한다.  
이 외에 이벤트를 멱등으로 처리하는 방법도 있다.

> 연산을 여러 번 적용해도 결과가 달라지지 않는 성질을 `멱등성(idempotent)`이라고 한다.  
> 이벤트 핸들러가 멱등성을 가지면 시스템 장애로 인해 같은 이벤트가 중복해서 발생해도 결과적으로 동일 상태가 된다.  
> 이는 이벤트 중복 발생이나 중복 처리에 대한 부담을 줄여준다.

## 10.6.1 이벤트 처리와 DB 트랜잭션 고려

앞에서 이벤트를 적용할 때 고려할 점을 알아봤는데 이 절에서는 DB 트랜잭션 관점에서 고려해야 할 점을 살펴보자.  
**이벤트를 처리할 때는 DB 트랜잭션을 함께 고려**해야 한다.  
예를 들어 주문 취소와 환불 기능을 다음과 같이 이벤트를 이용해서 구현했다고 하자.

- 주문 취소 기능은 주문 취소 이벤트를 발생시킨다.
- 주문 취소 이벤트 핸들러는 환불 서비스에 환불 처리를 요청한다.
- 환불 서비스는 외부 API를 호출해서 결제를 취소한다.

주문 취소 이벤트를 동기로 처리할 경우, 주문 취소 이벤트를 발행한 후 트랜잭션 처리가 성공적으로 끝나지 않았다면 결제는 취소됐는데 DB에는 주문이 취소되지 않은 상태로 남게 된다.  
주문 취소 이벤트를 비동기로 처리할 경우, 환불 서비스가 외부 API 호출에 실패하면 DB에는 주문이 취소된 상태로 데이터가 바뀌었는데 결제는 취소되지 않은 상태로 남게 된다.

이벤트 처리를 동기로 하든 비동기로 하든 이벤트 처리 실패와 트랜잭션 실패를 함께 고려해야 한다.  
트랜잭션 실패와 이벤트 처리 실패를 모두 고려하면 복잡해지므로 경우의 수를 줄이면 도움이 된다.  
경우의 수를 줄이는 방법은 트랜잭션이 성공할 때만 이벤트 핸들러를 실행하는 것이다.

스프링은 `@TransactionalEventListener` 애너테이션을 지원한다.  
이 애너테이션은 스프링 트랜잭션 상태에 따라 이벤트 핸들러를 실행할 수 있게 한다.  
다음은 이 애너테이션을 사용한 코드의 예를 보여준다.

```java
@Configuration
@TransactionalEventListener(
    classes = OrderCanceledEvent.class,
    phase = TransactionPhase.AFTER_COMMIT
)
public void handle(OrderCanceledEvent event) {
    refundService.refund(event.getOrderNumber());
}
```

위 코드에서 phase 속성 값으로 TransactionPhase.AFTER_COMMIT을 지정했다.  
이 값을 사용하면 스프링은 트랜잭션 커밋에 성공한 뒤에 핸들러 메서드를 실행한다.  
중간에 에러가 발생해서 트랜잭션이 롤백 되면 핸들러 메서드를 실행하지 않는다.  
이 기능을 사용하면 이벤트 핸들러를 실행했는데 트랜잭션이 롤백 되는 상황은 발생하지 않는다.

이벤트 저장소로 DB를 사용해도 동일한 효과를 볼 수 있다.  
이벤트 발생 코드와 이벤트 저장 처리를 한 트랜잭션으로 처리하면 된다.  
이렇게 하면 트랜잭션이 성공할 때만 이벤트가 DB에 저장되므로, 트랜잭션은 실패했는데 이벤트 핸들러가 실행되는 상황은 발생하지 않는다.

트랜잭션이 성공할 때만 이벤트 핸들러를 실행하게 되면 트랜잭션 실패에 대한 경우의 수가 줄어 이제 이벤트 처리 실패만 고민하면 된다.  
이벤트 특성에 따라 재처리 방식을 결정하면 된다.
