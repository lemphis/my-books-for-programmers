# 3.1 쿠버네티스 이해하기

컨테이너 인프라 환경이란 리눅스 운영 체제의 커널 하나에서 여러 개의 컨테이너가 격리된 상태로 실행되는 인프라 환경을 말합니다.

구글이 쿠버네티스를 오픈소스로 공개하면서 컨테이너 인프라 환경을 좀 더 효율적으로 관리할 수 있게 되면서 컨테이너 인프라 환경이 성장하게 되었습니다.

쿠버네티스를 컨테이너 관리 도구라고 설명했지만, 실제로 쿠버네티스는 컨테이너 오케스트레이션을 위한 솔루션입니다.  
오케스트레이션(Orchestration)이란 복잡한 단계를 관리하고 요소들의 유기적인 관계를 미리 정의해 손쉽게 사용하도록 서비스를 제공하는 것을 의미합니다.

2021년을 기준으로 대부분 IT 기업에서는 쿠버네티스와 관련된 프로젝트를 진행하고 있거나 이미 자사 솔루션으로 흡수 및 통합했습니다.

## 3.1.2 쿠버네티스 구성 방법

쿠버네티스를 구성하는 방법은 크게 세 가지입니다.

1. 퍼블릭 클라우드 업체에서 제공하는 관리형 쿠버네티스인 EKS(Amazon Elastic Kubernetes Service), AKS(Azure Kubernetes Services), GKE(Google Kubernetes Engine)
2. 설치형 쿠버네티스인 수세의 Rancher, 레드햇의 OpenShift
3. 사용하는 시스템에 쿠버네티스 클러스터를 자동으로 구성해주는 구성형 쿠버네티스인 kubeadm, kops(Kubernetes Operations), KRIB(Kubernetes Rebar Integrated Bootstrap), kubespray

## 3.1.4 파드 배포를 중심으로 쿠버네티스 구성 요소 살펴보기

아래는 관리자나 개발자가 파드 배포 명령을 수행했을 때 실행되는 순서와 각 요소들의 역할입니다.

1. 마스터 노드
    1. kubectl
        - 쿠버네티스 클러스터에 명령을 내리는 역할
        - 다른 구성 요소들과 다르게 바로 실행되는 명령 형태인 바이너리(binary)로 배포되기 때문에 마스터 노드에 있을 필요는 없음
        - 통상적으로 API 서버와 주로 통신
    2. API 서버
        - 쿠버네티스 클러스터의 중심 역할을 하는 통로
        - 주로 상태 값을 저장하는 etcd와 통신하지만 그 밖의 요소들 또한 API 서버를 중심에 두고 통신하므로 API 서버의 역할이 매우 중요
    3. etcd
        - 구성 요소들의 상태 값이 모두 저장되는 곳
        - etcd의 정보만 백업돼 있다면 긴급한 장애 상황에서도 쿠버네티스 클러스터 복구 가능
        - 분산 저장 가능한 key-value 저장소이므로, 복제해 여러 곳에 저장해 두면 하나의 etcd에서 장애가 나더라도 시스템 가용성 확보 가능
    4. 컨트롤러 매니저
        - 쿠버네티스 클러스터의 오브젝트 상태를 관리
    5. 스케줄러
        - 노드의 상태와 자원, 레이블, 요구 조건 등을 고려해 파드를 어떤 워커 노드에 생성할 것인지를 결정하고 할당
2. 워커 노드
    1. kubelet
        - 파드의 구성 내용(PodSpec)을 받아서 컨테이너 런타임으로 전달하고, 파드 안의 컨테이너들이 정상적으로 작동하는지 모니터링
    2. 컨테이너 런타임(CRI, Container Runtime Interface)
        - 파드를 이루는 컨테이너의 실행을 담당
        - 파드 안에서 다양한 종류의 컨테이너가 문제 없이 작동하게 만드는 표준 인터페이스
    3. 파드(Pod)
        - 한 개 이상의 컨테이너로 단일 목적의 일을 하기 위해서 모인 단위
        - 언제라도 죽을 수 있는 존재
3. 선택 가능한 구성 요소
    1. 네트워크 플러그인
        - 쿠버네티스 클러스터의 통신을 위해서 네트워크 플러그인을 선택하고 구성해야 함
        - 일반적으로 CNI(Container Network Interface)로 구성
        - 주로 사용하는 CNI는 캘리코(Calico), 플래널(Flannel), 실리움(Cilium), 큐브 라우터(Kube-router), 로마나(Romana), 위브넷(WeaveNet), Canal이
          있음
    2. CoreDNS
        - 빠르고 유연한 DNS 서버
        - 쿠버네티스 클러스터에서 도메인 이름을 이용해 통신하는 데 사용
        - 실무에서 쿠버네티스 클러스터를 구성하여 사용할 때는 IP보다 도메인 네임을 편리하게 관리해 주는 CoreDNS를 사용하는 것이 일반적

## 3.1.5 파드의 생명주기로 쿠버네티스 구성 요소 살펴보기

쿠버네티스의 가장 큰 장점은 쿠버네티스의 구성 요소마다 하는 일이 명확하게 구분돼 각자의 역할만 충실하게 수행하면 클러스터 시스템이 안정적으로 운영된다는 점입니다.  
이렇게 각자의 역할이 명확하게 나뉘어진 것은 마이크로서비스 아키텍처(MSA) 구조와도 밀접하게 연관됩니다.  
아래는 파드의 생명주기입니다. 생명주기(life cycle)는 파드가 생성, 수정, 삭제되는 과정을 나타냅니다.

1. kubectl을 통해 API 서버에 파드 생성을 요청
2. (업데이트가 있을 때마다 매번) API 서버에 전달된 내용이 있으면 API 서버는 etcd에 전달된 내용을 모두 기록해 클러스터의 상태 값을 최신으로 유지
3. API 서버에 파드 생성이 요청된 것을 컨트롤러 매니저가 인지하면 컨트롤러 매니저는 파드를 생성하고, 이 상태를 API 서버에 전달
4. API 서버에 파드가 생성됐다는 정보를 스케줄러가 인지, 스케줄러는 생성된 파드를 어떤 워커 노드에 적용할지 조건을 고려해 결정하고 해당 워커 노드에 파드 띄우도록 요청
5. API 서버에 전달된 정보대로 지정한 워커 노드에 파드가 속해 있는지 스케줄러가 kubelet으로 확인
6. kubelet에서 컨테이너 런타임으로 파드 생성 요청
7. 파드 생성
8. 파드 사용 가능

쿠버네티스는 작업을 순서대로 진행하는 워크플로(workflow, 작업 절차) 구조가 아니라 **선언적인(declarative)** 시스템 구조를 가지고 있습니다.  
각 요소가 추구하는 **상태(desired status)**를 선언하면 **현재 상태(current status)**와 맞는지 점검하고 그것에 맞추려고 노력하는 구조로 되어 있습니다.  
따라서 추구하는 상태를 API 서버에 선언하면 다른 요소들이 API 서버에 와서 현재 상태와 비교하고 그에 맞게 상태를 변경하려고 합니다.  
여기서 API는 현재 상태 값을 가지고 있는데, 이것을 보존해야 해서 etcd가 필요합니다.  
다만, 워커 노드는 워크플로 구조에 따라 설계됐습니다.  
쿠버네티스가 kubelet과 컨테이너 런타임을 통해 파드를 새로 생성하고 제거해야 하는 구조여서 선언적인 방식으로 구조화하기에는 어려움이 있기 때문입니다.  
또한 명령이 절차적으로 전달되는 방식은 시스템의 성능을 높이는 데 효율적입니다.  
하지만 마스터 노드는 이미 생성된 파드들을 유기적으로 연결하므로 쿠버네티스 클러스터를 안정적으로 유지하려면 선언적인 시스템이 더 낫습니다.