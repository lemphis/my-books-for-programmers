# 79. 과도한 동기화는 피하라

과도한 동기화는 성능을 떨어뜨리고, 교착상태에 빠뜨리고, 심지어 예측할 수 없는 동작을 발생시키기도 한다.  
**응답 불가(liveness failure)와 안전 실패(safety failure)를 피하려면 메서드나 동기화 블록 안에서는 제어를 절대로 클라이언트에 양도하면 안 된다.**  
예를 들어 동기화된 영역 안에서는 재정의할 수 있는 메서드는 호출하면 안 되며, 클라이언트가 넘겨준 함수 객체를 호출해서도 안 된다.

**기본 규칙은 동기화 영역에서는 가능한 한 일을 적게 하는 것이다.**

가변 클래스를 작성하려거든 다음 두 선택지 중 하나를 따르자.

- 동기화를 전혀 하지 않고, 그 클래스를 동시에 사용해야 하는 클래스가 외부에서 알아서 동기화하게 함
  - java.util이 사용한 방법
- 동기화를 내부에서 수행해 스레드 안전한 클래스로 만듦
  - 단, 클라이언트가 외부에서 객체 전체에 락을 거는 것보다 동시성을 월등히 개선할 수 있을 때 사용
  - java.util.concurrent가 사용한 방법
  - 여러 기법을 통해 동시성을 높여줄 수 있음
    - 락 분할(lock splitting)
    - 락 스트라이핑(lock striping)
    - 비차단 동시성 제어(nonblocking concurrency control)
